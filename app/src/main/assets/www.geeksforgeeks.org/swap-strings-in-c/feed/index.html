<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: C function to Swap strings</title>
	<atom:link href="http://www.geeksforgeeks.org/swap-strings-in-c/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/swap-strings-in-c/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Aakash</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-37362</link>
		<dc:creator><![CDATA[Aakash]]></dc:creator>
		<pubDate>Sun, 01 Jun 2014 12:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-37362</guid>
		<description><![CDATA[Here we are already have a pointer worthRef, so we can pass this pointer directly to the function C , here we are not changing the pointer but the value pointed to by pointer..
 whereas in method 1, we are changing the pointer value itself, so we are passing a reference to that pointer]]></description>
		<content:encoded><![CDATA[<p>Here we are already have a pointer worthRef, so we can pass this pointer directly to the function C , here we are not changing the pointer but the value pointed to by pointer..<br />
 whereas in method 1, we are changing the pointer value itself, so we are passing a reference to that pointer</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Santosh Panigrahy</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-33446</link>
		<dc:creator><![CDATA[Santosh Panigrahy]]></dc:creator>
		<pubDate>Thu, 13 Mar 2014 00:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-33446</guid>
		<description><![CDATA[@geeksforgeeks in method 1 we can write the swap function without using the temp variable .
void swap1(char **str1_ptr, char **str2_ptr)
{
*str1_ptr = *str1_ptr + (*str1_ptr - *str2_ptr);
*str2_ptr = *str1_ptr - (*str1_ptr - *str2_ptr)/2;
*str1_ptr = *str1_ptr - (*str1_ptr - *str2_ptr)*2;
}]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks in method 1 we can write the swap function without using the temp variable .<br />
void swap1(char **str1_ptr, char **str2_ptr)<br />
{<br />
*str1_ptr = *str1_ptr + (*str1_ptr &#8211; *str2_ptr);<br />
*str2_ptr = *str1_ptr &#8211; (*str1_ptr &#8211; *str2_ptr)/2;<br />
*str1_ptr = *str1_ptr &#8211; (*str1_ptr &#8211; *str2_ptr)*2;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Santosh Panigrahy</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-33447</link>
		<dc:creator><![CDATA[Santosh Panigrahy]]></dc:creator>
		<pubDate>Thu, 13 Mar 2014 00:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-33447</guid>
		<description><![CDATA[@geeksforgeeks in method 1 we can write the swap function without using the temp variable .
void swap1(char **str1_ptr, char **str2_ptr)
{
*str1_ptr = *str1_ptr + (*str1_ptr - *str2_ptr);
*str2_ptr = *str1_ptr - (*str1_ptr - *str2_ptr)/2;
*str1_ptr = *str1_ptr - (*str1_ptr - *str2_ptr)*2;
}]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks in method 1 we can write the swap function without using the temp variable .<br />
void swap1(char **str1_ptr, char **str2_ptr)<br />
{<br />
*str1_ptr = *str1_ptr + (*str1_ptr &#8211; *str2_ptr);<br />
*str2_ptr = *str1_ptr &#8211; (*str1_ptr &#8211; *str2_ptr)/2;<br />
*str1_ptr = *str1_ptr &#8211; (*str1_ptr &#8211; *str2_ptr)*2;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: arcish</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-31632</link>
		<dc:creator><![CDATA[arcish]]></dc:creator>
		<pubDate>Sun, 19 Jan 2014 09:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-31632</guid>
		<description><![CDATA[can someone answer this ? http://www.geeksforgeeks.org/forums/topic/given-a-bst-find-all-sequences-of-nodes-from-root-that-generates-the-same-bst-2/.]]></description>
		<content:encoded><![CDATA[<p>can someone answer this ? <a href="http://www.geeksforgeeks.org/forums/topic/given-a-bst-find-all-sequences-of-nodes-from-root-that-generates-the-same-bst-2/" rel="nofollow">http://www.geeksforgeeks.org/forums/topic/given-a-bst-find-all-sequences-of-nodes-from-root-that-generates-the-same-bst-2/</a>.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Marsha Donna</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-31631</link>
		<dc:creator><![CDATA[Marsha Donna]]></dc:creator>
		<pubDate>Sun, 19 Jan 2014 08:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-31631</guid>
		<description><![CDATA[@geeksforgeeks in method 2 str1 array is passed to function swap and In C, array parameters are always treated as pointers..... in question  no 9 it was mentioned that  a separate parameter for array size (or length) should be passed (to a function accepting array parameter) then howcome  

char *temp = (char *)malloc((strlen(str1) + 1) * sizeof(char));


works?????pls clarify??]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks in method 2 str1 array is passed to function swap and In C, array parameters are always treated as pointers&#8230;.. in question  no 9 it was mentioned that  a separate parameter for array size (or length) should be passed (to a function accepting array parameter) then howcome  </p>
<p>char *temp = (char *)malloc((strlen(str1) + 1) * sizeof(char));</p>
<p>works?????pls clarify??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Marsha Donna</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-31620</link>
		<dc:creator><![CDATA[Marsha Donna]]></dc:creator>
		<pubDate>Sat, 18 Jan 2014 20:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-31620</guid>
		<description><![CDATA[@geeksforgeeks :the following extact was obtained from stanford pdf:
When passing by reference, the caller does not always need to use &#038; to compute a new pointer to the value of interest. Sometimes the caller already has a pointer to the value of interest, and so no new pointer computation is required. The pointer to the value of interest can be passed through unchanged.
For example, suppose B() is changed so it calls a C() function which adds 2 to the value of interest...
// Takes the value of interest by reference and adds 2.
void C(int* worthRef) {
*worthRef = *worthRef + 2;
}
// Adds 1 to the value of interest, and calls C().
void B(int* worthRef) {
*worthRef = *worthRef + 1; // add 1 to value of interest as before
C(worthRef); // NOTE no &#038; required. We already have
// a pointer to the value of interest, so
// it can be passed through directly.
}
this contradicts with metho1 please clarify..]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks :the following extact was obtained from stanford pdf:<br />
When passing by reference, the caller does not always need to use &amp; to compute a new pointer to the value of interest. Sometimes the caller already has a pointer to the value of interest, and so no new pointer computation is required. The pointer to the value of interest can be passed through unchanged.<br />
For example, suppose B() is changed so it calls a C() function which adds 2 to the value of interest&#8230;<br />
// Takes the value of interest by reference and adds 2.<br />
void C(int* worthRef) {<br />
*worthRef = *worthRef + 2;<br />
}<br />
// Adds 1 to the value of interest, and calls C().<br />
void B(int* worthRef) {<br />
*worthRef = *worthRef + 1; // add 1 to value of interest as before<br />
C(worthRef); // NOTE no &amp; required. We already have<br />
// a pointer to the value of interest, so<br />
// it can be passed through directly.<br />
}<br />
this contradicts with metho1 please clarify..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sandeep</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-26692</link>
		<dc:creator><![CDATA[sandeep]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 12:30:15 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-26692</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: coder</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-18775</link>
		<dc:creator><![CDATA[coder]]></dc:creator>
		<pubDate>Tue, 28 May 2013 07:13:09 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-18775</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;stdio.h&#062;

swap(char *first, char *second, int len)
{
	char temp = 0;
	printf(&#034;len = %d\n&#034;, len);

	while (((*first) &#124;&#124; (*second)) &#038;&#038; (len-1)) {
		temp = *first;
		*first = *second;
		*second = temp;
		first++;second++;len--;
	}
}

int
main()
{
	char first[10] = &#034;hello&#034;;
	char second[20] = &#034;world&#034;;

	printf(&#034;%s %s\n&#034;, first, second);
	swap(first, second, 
		(sizeof(first)&#060;(sizeof(second)))? sizeof(first): sizeof(second));
	printf(&#034;%s %s\n&#034;, first, second);
}


&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
#include &lt;stdio.h&gt;

swap(char *first, char *second, int len)
{
	char temp = 0;
	printf(&quot;len = %d\n&quot;, len);

	while (((*first) || (*second)) &amp;&amp; (len-1)) {
		temp = *first;
		*first = *second;
		*second = temp;
		first++;second++;len--;
	}
}

int
main()
{
	char first[10] = &quot;hello&quot;;
	char second[20] = &quot;world&quot;;

	printf(&quot;%s %s\n&quot;, first, second);
	swap(first, second, 
		(sizeof(first)&lt;(sizeof(second)))? sizeof(first): sizeof(second));
	printf(&quot;%s %s\n&quot;, first, second);
}


</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: migf1</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-6395</link>
		<dc:creator><![CDATA[migf1]]></dc:creator>
		<pubDate>Wed, 09 Nov 2011 10:37:26 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-6395</guid>
		<description><![CDATA[For some speed improvement, those 3 calls to strcpy() can be replaced with calls to memcpy()


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
...
	/* do the swapping */
	memcpy( dummy, s, size );
	memcpy( s, t, size );
	memcpy( t, dummy, size );
...
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>For some speed improvement, those 3 calls to strcpy() can be replaced with calls to memcpy()</p>
<pre> <code language="C">
...
	/* do the swapping */
	memcpy( dummy, s, size );
	memcpy( s, t, size );
	memcpy( t, dummy, size );
...
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: migf1</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-6391</link>
		<dc:creator><![CDATA[migf1]]></dc:creator>
		<pubDate>Tue, 08 Nov 2011 16:29:05 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-6391</guid>
		<description><![CDATA[Continuing my last comment, a possible implementation for the proposed swapping function, could be the following (please note that I have not tested it extensively). 

It trusts that ssize and tsize are passed with correct values, and that the c-strings s and t are both either NULL or null-terminated strings. Truncation of the longest c-string occurs before the swapping only if the current length of that string is greater than the smaller of the values of ssize and tsize. It returns a positive or a negative int reflecting the number of bytes truncated from s or t, respectively, or 0 if no truncation took place or if an error occurred. In case of errors, it assigns corrsponding values to the global var errno ( #include &quot;errno.h&quot;) for further examination.

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int s_swap( char s[], char t[], const size_t ssize, const size_t tsize )
{
	char *dummy = NULL;
	size_t size = 0U, len = 0U;
	int retval = 0;

	/* sanity checks */
	if ( !s &#124;&#124; !t ) { errno = EFAULT; return 0; }
	if ( ssize &#060; 1U &#124;&#124; tsize &#060; 1U ) { errno = EINVAL; return 0; };

	size = ssize &#060; tsize ? ssize : tsize;

	dummy = malloc( size * sizeof(char) );
	if ( !dummy ) {
		errno = ENOMEM;
		return 0;
	}

	/* determine possible truncation */
	len = strlen( s );
	if ( size &#060; len+1 )
		retval = (len+1) - size;
	len = strlen( t );
	if ( size &#060; len+1 )
		retval = size - (len+1);

	/* ensure null-termination */
	s[ size-1 ] = &#039;&#092;&#048;&#039;;
	t[ size-1 ] = &#039;&#092;&#048;&#039;;

	/* do the swapping */
	strcpy( dummy, s );
	strcpy( s, t );
	strcpy( t, dummy );

	free( dummy );
	return retval;
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Continuing my last comment, a possible implementation for the proposed swapping function, could be the following (please note that I have not tested it extensively). </p>
<p>It trusts that ssize and tsize are passed with correct values, and that the c-strings s and t are both either NULL or null-terminated strings. Truncation of the longest c-string occurs before the swapping only if the current length of that string is greater than the smaller of the values of ssize and tsize. It returns a positive or a negative int reflecting the number of bytes truncated from s or t, respectively, or 0 if no truncation took place or if an error occurred. In case of errors, it assigns corrsponding values to the global var errno ( #include &#8220;errno.h&#8221;) for further examination.</p>
<pre> <code language="C">
int s_swap( char s[], char t[], const size_t ssize, const size_t tsize )
{
	char *dummy = NULL;
	size_t size = 0U, len = 0U;
	int retval = 0;

	/* sanity checks */
	if ( !s || !t ) { errno = EFAULT; return 0; }
	if ( ssize &lt; 1U || tsize &lt; 1U ) { errno = EINVAL; return 0; };

	size = ssize &lt; tsize ? ssize : tsize;

	dummy = malloc( size * sizeof(char) );
	if ( !dummy ) {
		errno = ENOMEM;
		return 0;
	}

	/* determine possible truncation */
	len = strlen( s );
	if ( size &lt; len+1 )
		retval = (len+1) - size;
	len = strlen( t );
	if ( size &lt; len+1 )
		retval = size - (len+1);

	/* ensure null-termination */
	s[ size-1 ] = '&#092;&#048;';
	t[ size-1 ] = '&#092;&#048;';

	/* do the swapping */
	strcpy( dummy, s );
	strcpy( s, t );
	strcpy( t, dummy );

	free( dummy );
	return retval;
}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: migf1</title>
		<link>http://www.geeksforgeeks.org/swap-strings-in-c/#comment-6388</link>
		<dc:creator><![CDATA[migf1]]></dc:creator>
		<pubDate>Tue, 08 Nov 2011 09:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5276#comment-6388</guid>
		<description><![CDATA[There are a couple of work-arounds.

One is to define 2 separate char pointers, assign them to each of the strings and then use the 1st method to swap their addresses. The downside is that we can no longer use directly the original strings in the rest of our program:

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int main()
{
  char str1[] = &#034;geeks&#034;;
  char str2[] = &#034;forgeeks to geeks&#034;;
  char *pstr1 = str1;
  char *pstr2 = str2;

  swap1( &#038;pstr1, &#038;pstr2 );
  ...
  ...&lt;/code&gt; &lt;/pre&gt;

Another one is to force the swapping to truncate the longest of the strings before the swapping takes place. The downside is obvious, especially because it uses strlen() instead of sizeof() to decide upon the truncation:

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
void swap2b( char *str1, char *str2 )
{
	char *dummy = NULL;
	size_t len = 0U, len1 = 0U, len2 = 0U;

	/* sanity checks */
	if ( !str1 &#124;&#124; !str2 )
		return 0;

	len1 = strlen( str1 );
	len2 = strlen( str2 );
	size = len1 &#060; len2 ? len1 : len2;

	dummy = calloc( len+1, sizeof(char) );
	if ( !dummy )
		return;

	/* do the swapping */
	strncpy( dummy, str1, len );
	dummy[len] = &#039;&#092;&#048;&#039;;
	strncpy( str1, str2, len );
	str1[len] = &#039;&#092;&#048;&#039;;
	strncpy( str2, dummy, len );
	str2[len] = &#039;&#092;&#048;&#039;;

	free( dummy );
	return;

}
&lt;/code&gt; &lt;/pre&gt;

And a 3rd (and probably the best one), is to pass the sizeof() of each string as parameters to the function. It will use those values for deciding upon the truncation, and nevertheless it is a superset of both of the previous variations of the 2nd method:

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
void s_swap2c( char s[], char t[], const size_t ssize, const size_t tsize )
{
	char *dummy = NULL;
	size_t size = 0U;

	/* sanity checks */
	if ( !s &#124;&#124; !t &#124;&#124; ssize &#060; 1U &#124;&#124; tsize &#060; 1U )
		return;

	size = ssize &#060; tsize ? ssize : tsize;

	dummy = malloc( size * sizeof(char) );
	if ( !dummy )
		return 0;

	s[ size-1 ] = &#039;&#092;&#048;&#039;;
	t[ size-1 ] = &#039;&#092;&#048;&#039;;

	/* do the swapping */
	strcpy( dummy, s );
	strcpy( s, t );
	strcpy( t, dummy );

	free( dummy );
	return;
}
&lt;/code&gt; &lt;/pre&gt;

As long as no string-literal is used, this function is safe and it works with c-strings of arbitrary type (static or dynamic), size &#038; length, reducing the truncation chances to the minimum.

Providing both of the strings are defined as arrays of char, a safe call to such a function would be as following:

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
	swap2c( s, t, sizeof(s), sizeof(t) );
&lt;/code&gt; &lt;/pre&gt;

It also works for dynamically allocated strings, although in that case the 1st method is 
the best one (swapping their addresses) since among other things sizeof() should be replaced with the sizes those strings were dynamically allocated.

With some adjustment the function could return a positive or a negative int, depending on whether the 1st or the 2nd string, respectively, got truncated or 0 if no truncation took place (this int could also reflect the number of chars that got truncated... e.g. -3 would mean that 3 chars were truncated from the 2nd string).]]></description>
		<content:encoded><![CDATA[<p>There are a couple of work-arounds.</p>
<p>One is to define 2 separate char pointers, assign them to each of the strings and then use the 1st method to swap their addresses. The downside is that we can no longer use directly the original strings in the rest of our program:</p>
<pre> <code language="C">
int main()
{
  char str1[] = &quot;geeks&quot;;
  char str2[] = &quot;forgeeks to geeks&quot;;
  char *pstr1 = str1;
  char *pstr2 = str2;

  swap1( &amp;pstr1, &amp;pstr2 );
  ...
  ...</code> </pre>
<p>Another one is to force the swapping to truncate the longest of the strings before the swapping takes place. The downside is obvious, especially because it uses strlen() instead of sizeof() to decide upon the truncation:</p>
<pre> <code language="C">
void swap2b( char *str1, char *str2 )
{
	char *dummy = NULL;
	size_t len = 0U, len1 = 0U, len2 = 0U;

	/* sanity checks */
	if ( !str1 || !str2 )
		return 0;

	len1 = strlen( str1 );
	len2 = strlen( str2 );
	size = len1 &lt; len2 ? len1 : len2;

	dummy = calloc( len+1, sizeof(char) );
	if ( !dummy )
		return;

	/* do the swapping */
	strncpy( dummy, str1, len );
	dummy[len] = '&#092;&#048;';
	strncpy( str1, str2, len );
	str1[len] = '&#092;&#048;';
	strncpy( str2, dummy, len );
	str2[len] = '&#092;&#048;';

	free( dummy );
	return;

}
</code> </pre>
<p>And a 3rd (and probably the best one), is to pass the sizeof() of each string as parameters to the function. It will use those values for deciding upon the truncation, and nevertheless it is a superset of both of the previous variations of the 2nd method:</p>
<pre> <code language="C">
void s_swap2c( char s[], char t[], const size_t ssize, const size_t tsize )
{
	char *dummy = NULL;
	size_t size = 0U;

	/* sanity checks */
	if ( !s || !t || ssize &lt; 1U || tsize &lt; 1U )
		return;

	size = ssize &lt; tsize ? ssize : tsize;

	dummy = malloc( size * sizeof(char) );
	if ( !dummy )
		return 0;

	s[ size-1 ] = '&#092;&#048;';
	t[ size-1 ] = '&#092;&#048;';

	/* do the swapping */
	strcpy( dummy, s );
	strcpy( s, t );
	strcpy( t, dummy );

	free( dummy );
	return;
}
</code> </pre>
<p>As long as no string-literal is used, this function is safe and it works with c-strings of arbitrary type (static or dynamic), size &amp; length, reducing the truncation chances to the minimum.</p>
<p>Providing both of the strings are defined as arrays of char, a safe call to such a function would be as following:</p>
<pre> <code language="C">
	swap2c( s, t, sizeof(s), sizeof(t) );
</code> </pre>
<p>It also works for dynamically allocated strings, although in that case the 1st method is<br />
the best one (swapping their addresses) since among other things sizeof() should be replaced with the sizes those strings were dynamically allocated.</p>
<p>With some adjustment the function could return a positive or a negative int, depending on whether the 1st or the 2nd string, respectively, got truncated or 0 if no truncation took place (this int could also reflect the number of chars that got truncated&#8230; e.g. -3 would mean that 3 chars were truncated from the 2nd string).</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:24:53 -->

<!-- Compression = gzip -->