<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 26 (Largest Independent Set Problem)</title>
	<atom:link href="http://www.geeksforgeeks.org/largest-independent-set-problem/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/largest-independent-set-problem/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-37905</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Sun, 08 Jun 2014 08:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-37905</guid>
		<description><![CDATA[GeeksforGeeks:

The below 2 lines are redundant. The DP algorithm will work without these 2 lines.

if (root-&#062;left == NULL &#038;&#038; root-&#062;right == NULL)
 return (root-&#062;liss = 1);]]></description>
		<content:encoded><![CDATA[<p>GeeksforGeeks:</p>
<p>The below 2 lines are redundant. The DP algorithm will work without these 2 lines.</p>
<p>if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)<br />
 return (root-&gt;liss = 1);</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: aman</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-34585</link>
		<dc:creator><![CDATA[aman]]></dc:creator>
		<pubDate>Fri, 11 Apr 2014 11:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-34585</guid>
		<description><![CDATA[Yes it can be done taking in consideration the notion of bipartite graph.]]></description>
		<content:encoded><![CDATA[<p>Yes it can be done taking in consideration the notion of bipartite graph.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: hj</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-32273</link>
		<dc:creator><![CDATA[hj]]></dc:creator>
		<pubDate>Thu, 06 Feb 2014 17:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-32273</guid>
		<description><![CDATA[Can this problem be seen as a variant of Graph Coloring Problem? The largest number of nodes having the same color will form largest independent set.
Of course the graph coloring depends on the order in which vertices are seen.. On the other hand, we can find independent subsets and use for graph coloring?]]></description>
		<content:encoded><![CDATA[<p>Can this problem be seen as a variant of Graph Coloring Problem? The largest number of nodes having the same color will form largest independent set.<br />
Of course the graph coloring depends on the order in which vertices are seen.. On the other hand, we can find independent subsets and use for graph coloring?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: hj</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-32272</link>
		<dc:creator><![CDATA[hj]]></dc:creator>
		<pubDate>Thu, 06 Feb 2014 17:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-32272</guid>
		<description><![CDATA[I was thinking the same too.. but on second thought, this in fact forms the minimum independent set, apart from the case where there are two levels. 
Consider the case where there are 5 levels.. (assume complete tree) root + leaves + some elements from 3rd level can also be included in the largest independent set.]]></description>
		<content:encoded><![CDATA[<p>I was thinking the same too.. but on second thought, this in fact forms the minimum independent set, apart from the case where there are two levels.<br />
Consider the case where there are 5 levels.. (assume complete tree) root + leaves + some elements from 3rd level can also be included in the largest independent set.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guru Gorantla</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-32199</link>
		<dc:creator><![CDATA[Guru Gorantla]]></dc:creator>
		<pubDate>Tue, 04 Feb 2014 21:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-32199</guid>
		<description><![CDATA[It need not contain leaves all the time. For example if a tree has a depth say &quot;d&quot; and dth row represent only leaves. Let this dth row contain only one leaf then your LISS need not contain Leafed row. why ? In general when we consider an example we tend to take a almost balanced binary tree, as we increase depth d, the number of nodes in that depth increases with d(if almost balanced) . So instead consider a tree with only one leaf.]]></description>
		<content:encoded><![CDATA[<p>It need not contain leaves all the time. For example if a tree has a depth say &#8220;d&#8221; and dth row represent only leaves. Let this dth row contain only one leaf then your LISS need not contain Leafed row. why ? In general when we consider an example we tend to take a almost balanced binary tree, as we increase depth d, the number of nodes in that depth increases with d(if almost balanced) . So instead consider a tree with only one leaf.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Cristian Florica</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-31666</link>
		<dc:creator><![CDATA[Cristian Florica]]></dc:creator>
		<pubDate>Mon, 20 Jan 2014 12:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-31666</guid>
		<description><![CDATA[What is the approach for the &quot;Maximum Weighted Independent Set (MWIS) problem&quot;?]]></description>
		<content:encoded><![CDATA[<p>What is the approach for the &#8220;Maximum Weighted Independent Set (MWIS) problem&#8221;?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-30633</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Tue, 10 Dec 2013 16:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-30633</guid>
		<description><![CDATA[#include
using namespace std;
struct node
{
    node* lchild;
    int data;
    node* rchild;
    node(int d)
    {
        data=d;
        lchild=NULL;
        rchild=NULL;
    }
}*root=NULL;
void create(node* &#038;root,int d)
{
    int n;
    if(d==-1)
       return;
    if(root==NULL)
      root=new node(d);
    cout&#060;&#060;&#034;enter the left child of &#034;&#060;&#060;d&#060;&#062;n;
    create(root-&#062;lchild,n);
    cout&#060;&#060;&#034;enter the right child of &#034;&#060;&#060;d&#060;&#062;n;
    create(root-&#062;rchild,n);
}
int fun(node* root,int arr[],int &#038;size)
{
    if(root==NULL)
       return 1;
    if((!root-&#062;lchild)&#038;&#038;(!root-&#062;rchild))
      {
          arr[size++]=root-&#062;data;
          return 0;
      }
    int k1=fun(root-&#062;lchild,arr,size);
    int k2=fun(root-&#062;rchild,arr,size);
    if((k1)&#038;&#038;(k2))
    {
        arr[size++]=root-&#062;data;
        return 0;
    }
    else
      return 1;
}
int main()
{
    int arr[50],size,n;
    cout&#060;&#062;n;
    create(root,n);
    int k=fun(root,arr,size);
    for(int i=0;i&#060;size;i++)
    {
        cout&#060;&#060;arr[i]&#060;&#060;&#034; &#034;;
    }
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
using namespace std;<br />
struct node<br />
{<br />
    node* lchild;<br />
    int data;<br />
    node* rchild;<br />
    node(int d)<br />
    {<br />
        data=d;<br />
        lchild=NULL;<br />
        rchild=NULL;<br />
    }<br />
}*root=NULL;<br />
void create(node* &amp;root,int d)<br />
{<br />
    int n;<br />
    if(d==-1)<br />
       return;<br />
    if(root==NULL)<br />
      root=new node(d);<br />
    cout&lt;&lt;&quot;enter the left child of &quot;&lt;&lt;d&lt;&gt;n;<br />
    create(root-&gt;lchild,n);<br />
    cout&lt;&lt;&quot;enter the right child of &quot;&lt;&lt;d&lt;&gt;n;<br />
    create(root-&gt;rchild,n);<br />
}<br />
int fun(node* root,int arr[],int &amp;size)<br />
{<br />
    if(root==NULL)<br />
       return 1;<br />
    if((!root-&gt;lchild)&amp;&amp;(!root-&gt;rchild))<br />
      {<br />
          arr[size++]=root-&gt;data;<br />
          return 0;<br />
      }<br />
    int k1=fun(root-&gt;lchild,arr,size);<br />
    int k2=fun(root-&gt;rchild,arr,size);<br />
    if((k1)&amp;&amp;(k2))<br />
    {<br />
        arr[size++]=root-&gt;data;<br />
        return 0;<br />
    }<br />
    else<br />
      return 1;<br />
}<br />
int main()<br />
{<br />
    int arr[50],size,n;<br />
    cout&lt;&gt;n;<br />
    create(root,n);<br />
    int k=fun(root,arr,size);<br />
    for(int i=0;i&lt;size;i++)<br />
    {<br />
        cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;<br />
    }<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nitesh</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-30358</link>
		<dc:creator><![CDATA[Nitesh]]></dc:creator>
		<pubDate>Tue, 03 Dec 2013 06:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-30358</guid>
		<description><![CDATA[LIS will always contain leaves? is there any case in which it will not?? 

# if it always contains leafs then a better solution is

# include
# include
# include
int arr[100],t;
struct node
{   int data,flag;
    struct node *left, *right;
};
int lic(node *root)
{
    if(root==NULL)
    return 0;
    else
    {
        int a = lic(root-&#062;left);
        int b = lic(root-&#062;right);
        int f;
        if(a==0&#038;&#038;b==0)
        f=0;
        else if(a!=0&#038;&#038;b!=0)
        f=root-&#062;left-&#062;flag&#124;&#124;root-&#062;right-&#062;flag;
        else if(a==0)
        f=root-&#062;right-&#062;flag;
        else
        f=root-&#062;left-&#062;flag;

        if(f==1)
        {
            root-&#062;flag=0;
            return a+b;
        }
        else
        {
          root-&#062;flag=1;
          arr[t++]=root-&#062;data;
          return a+b+1;
        }
    }
}

struct node* newNode( int data )
{
    struct node* temp = (struct node *) malloc( sizeof(struct node) );
    temp-&#062;data = data;
    temp-&#062;left = temp-&#062;right = NULL;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us construct the tree given in the above diagram
    struct node *root         = newNode(20);
    root-&#062;left                = newNode(8);
    root-&#062;left-&#062;left          = newNode(4);
    root-&#062;left-&#062;right         = newNode(12);
    root-&#062;left-&#062;right-&#062;left   = newNode(10);
    root-&#062;left-&#062;right-&#062;right  = newNode(14);
    root-&#062;right               = newNode(22);
    root-&#062;right-&#062;right        = newNode(25);
    t=0;
    printf (&quot;Size of the Largest Independent Set is %d n&quot;, lic(root));
    for(int i=0;i&#060;t;++i)
    printf(&#034;%d &#034;,arr[i]);

    return 0;
}
]]></description>
		<content:encoded><![CDATA[<p>LIS will always contain leaves? is there any case in which it will not?? </p>
<p># if it always contains leafs then a better solution is</p>
<p># include<br />
# include<br />
# include<br />
int arr[100],t;<br />
struct node<br />
{   int data,flag;<br />
    struct node *left, *right;<br />
};<br />
int lic(node *root)<br />
{<br />
    if(root==NULL)<br />
    return 0;<br />
    else<br />
    {<br />
        int a = lic(root-&gt;left);<br />
        int b = lic(root-&gt;right);<br />
        int f;<br />
        if(a==0&amp;&amp;b==0)<br />
        f=0;<br />
        else if(a!=0&amp;&amp;b!=0)<br />
        f=root-&gt;left-&gt;flag||root-&gt;right-&gt;flag;<br />
        else if(a==0)<br />
        f=root-&gt;right-&gt;flag;<br />
        else<br />
        f=root-&gt;left-&gt;flag;</p>
<p>        if(f==1)<br />
        {<br />
            root-&gt;flag=0;<br />
            return a+b;<br />
        }<br />
        else<br />
        {<br />
          root-&gt;flag=1;<br />
          arr[t++]=root-&gt;data;<br />
          return a+b+1;<br />
        }<br />
    }<br />
}</p>
<p>struct node* newNode( int data )<br />
{<br />
    struct node* temp = (struct node *) malloc( sizeof(struct node) );<br />
    temp-&gt;data = data;<br />
    temp-&gt;left = temp-&gt;right = NULL;<br />
    return temp;<br />
}</p>
<p>// Driver program to test above functions<br />
int main()<br />
{<br />
    // Let us construct the tree given in the above diagram<br />
    struct node *root         = newNode(20);<br />
    root-&gt;left                = newNode(8);<br />
    root-&gt;left-&gt;left          = newNode(4);<br />
    root-&gt;left-&gt;right         = newNode(12);<br />
    root-&gt;left-&gt;right-&gt;left   = newNode(10);<br />
    root-&gt;left-&gt;right-&gt;right  = newNode(14);<br />
    root-&gt;right               = newNode(22);<br />
    root-&gt;right-&gt;right        = newNode(25);<br />
    t=0;<br />
    printf (&#8220;Size of the Largest Independent Set is %d n&#8221;, lic(root));<br />
    for(int i=0;i&lt;t;++i)<br />
    printf(&quot;%d &quot;,arr[i]);</p>
<p>    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Preetam Dwivedi</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-30312</link>
		<dc:creator><![CDATA[Preetam Dwivedi]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 07:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-30312</guid>
		<description><![CDATA[recursion code goes into infinite loop for keys 1-50 or more elements why?]]></description>
		<content:encoded><![CDATA[<p>recursion code goes into infinite loop for keys 1-50 or more elements why?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saurabh</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-29638</link>
		<dc:creator><![CDATA[saurabh]]></dc:creator>
		<pubDate>Thu, 07 Nov 2013 22:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-29638</guid>
		<description><![CDATA[in the given example 60 and 70 are from adjacent levels but yet they form a solution. And by your algorithm you will end up with answer 4 for the same case.]]></description>
		<content:encoded><![CDATA[<p>in the given example 60 and 70 are from adjacent levels but yet they form a solution. And by your algorithm you will end up with answer 4 for the same case.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/largest-independent-set-problem/#comment-29510</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 02 Nov 2013 13:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114526#comment-29510</guid>
		<description><![CDATA[is the solution nothing but the root and all the leaves possible for a tree...i know there would be an exception when there r two levels but else for other cases ,my conclusion is right,isnt it?? pls help]]></description>
		<content:encoded><![CDATA[<p>is the solution nothing but the root and all the leaves possible for a tree&#8230;i know there would be an exception when there r two levels but else for other cases ,my conclusion is right,isnt it?? pls help</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:49 -->

<!-- Compression = gzip -->