<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: QuickSort on Doubly Linked List</title>
	<atom:link href="http://www.geeksforgeeks.org/quicksort-for-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Klaus</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-39525</link>
		<dc:creator><![CDATA[Klaus]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 11:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-39525</guid>
		<description><![CDATA[if (h != NULL &#038;&#038; l != h &#038;&#038; l != h-&#062;next)
    {
        struct node *p = partition(l, h);
        _quickSort(l, p-&#062;prev);
        _quickSort(p-&#062;next, h);
    }
Why we are doing l!=h-&#062;next comparison]]></description>
		<content:encoded><![CDATA[<p>if (h != NULL &amp;&amp; l != h &amp;&amp; l != h-&gt;next)<br />
    {<br />
        struct node *p = partition(l, h);<br />
        _quickSort(l, p-&gt;prev);<br />
        _quickSort(p-&gt;next, h);<br />
    }<br />
Why we are doing l!=h-&gt;next comparison</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: brahma</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-38297</link>
		<dc:creator><![CDATA[brahma]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 09:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-38297</guid>
		<description><![CDATA[hear is my implementation swapping nodes instead of data...  i used same logic of single linked list 
http://ideone.com/uXGl81

@geeks can you tell me is there any decrease in run time by implementing in double linked list]]></description>
		<content:encoded><![CDATA[<p>hear is my implementation swapping nodes instead of data&#8230;  i used same logic of single linked list<br />
<a href="http://ideone.com/uXGl81" rel="nofollow">http://ideone.com/uXGl81</a></p>
<p>@geeks can you tell me is there any decrease in run time by implementing in double linked list</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: LinkedListFML</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-37464</link>
		<dc:creator><![CDATA[LinkedListFML]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 23:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-37464</guid>
		<description><![CDATA[Can someone give an implementation based on SWAPPING POINTERS instead of DATA. I tried a lot but was unsuccessful :(]]></description>
		<content:encoded><![CDATA[<p>Can someone give an implementation based on SWAPPING POINTERS instead of DATA. I tried a lot but was unsuccessful üôÅ</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: theCuriosityEnthusiast</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-37057</link>
		<dc:creator><![CDATA[theCuriosityEnthusiast]]></dc:creator>
		<pubDate>Fri, 30 May 2014 10:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-37057</guid>
		<description><![CDATA[I&#039;m new to this so can someone explain why randomized Quicksort cannot be efficiently implemented in a LL??]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m new to this so can someone explain why randomized Quicksort cannot be efficiently implemented in a LL??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: madan raj</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-37046</link>
		<dc:creator><![CDATA[madan raj]]></dc:creator>
		<pubDate>Fri, 30 May 2014 05:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-37046</guid>
		<description><![CDATA[l!=h-&#062;next case works 
when there are less than 2 elements in sublists
and when pivot pointer is the same as end element 

case try for 5 and 8 

p will be pointing to 8 

quicksort (5,5) //avoided l==h
and
quicksort(null,8) in this case l==h-&#062;next so avoided]]></description>
		<content:encoded><![CDATA[<p>l!=h-&gt;next case works<br />
when there are less than 2 elements in sublists<br />
and when pivot pointer is the same as end element </p>
<p>case try for 5 and 8 </p>
<p>p will be pointing to 8 </p>
<p>quicksort (5,5) //avoided l==h<br />
and<br />
quicksort(null,8) in this case l==h-&gt;next so avoided</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vishal</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-35530</link>
		<dc:creator><![CDATA[Vishal]]></dc:creator>
		<pubDate>Fri, 02 May 2014 13:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-35530</guid>
		<description><![CDATA[what does this statement do ?

i = (i == NULL)? l : i-&#062;next;]]></description>
		<content:encoded><![CDATA[<p>what does this statement do ?</p>
<p>i = (i == NULL)? l : i-&gt;next;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pushkar</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-29475</link>
		<dc:creator><![CDATA[Pushkar]]></dc:creator>
		<pubDate>Thu, 31 Oct 2013 20:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-29475</guid>
		<description><![CDATA[Hey!.. Here in this code when recursive function &quot;void _quickSort(struct node* l, struct node *h)&quot; is narrowed down to two elements then the pivot element is either the first or second element .so..
case 1:when pivot element is the first element (p==l)
            _quickSort(l, p-&#062;prev); set l as l and h as the previous element of p(or l) so                     the condition l!=h-&#062;next is violated()
case 1:when pivot element is the second element (p==h) 
            _quickSort(p-&#062;next,h); set h as h and l as the next element of p(or h) so                         the condition l!=h-&#062;next is violated
Hope it would help you!!!]]></description>
		<content:encoded><![CDATA[<p>Hey!.. Here in this code when recursive function &#8220;void _quickSort(struct node* l, struct node *h)&#8221; is narrowed down to two elements then the pivot element is either the first or second element .so..<br />
case 1:when pivot element is the first element (p==l)<br />
            _quickSort(l, p-&gt;prev); set l as l and h as the previous element of p(or l) so                     the condition l!=h-&gt;next is violated()<br />
case 1:when pivot element is the second element (p==h)<br />
            _quickSort(p-&gt;next,h); set h as h and l as the next element of p(or h) so                         the condition l!=h-&gt;next is violated<br />
Hope it would help you!!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Javed</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-29148</link>
		<dc:creator><![CDATA[Javed]]></dc:creator>
		<pubDate>Sun, 20 Oct 2013 22:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-29148</guid>
		<description><![CDATA[to put the pivot which is the last element, at its correct place.]]></description>
		<content:encoded><![CDATA[<p>to put the pivot which is the last element, at its correct place.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: edward</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-28088</link>
		<dc:creator><![CDATA[edward]]></dc:creator>
		<pubDate>Tue, 24 Sep 2013 23:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-28088</guid>
		<description><![CDATA[why need   swap (&#038;arr[i + 1], &#038;arr[h]); after loop?]]></description>
		<content:encoded><![CDATA[<p>why need   swap (&amp;arr[i + 1], &amp;arr[h]); after loop?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nehamahajan</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-27757</link>
		<dc:creator><![CDATA[nehamahajan]]></dc:creator>
		<pubDate>Tue, 17 Sep 2013 06:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-27757</guid>
		<description><![CDATA[h is last node of every sublist so h-&#062;next is possible and l!= h-&#062;next. It simply means that there must be more than two elements in sublists.]]></description>
		<content:encoded><![CDATA[<p>h is last node of every sublist so h-&gt;next is possible and l!= h-&gt;next. It simply means that there must be more than two elements in sublists.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: LinuxWorld</title>
		<link>http://www.geeksforgeeks.org/quicksort-for-linked-list/#comment-23074</link>
		<dc:creator><![CDATA[LinuxWorld]]></dc:creator>
		<pubDate>Thu, 01 Aug 2013 23:43:22 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=117304#comment-23074</guid>
		<description><![CDATA[sorting the list using linked list

#include
#include

struct Node
{
	int data ;
	struct Node  * next ;
};
typedef struct Node Node ;

Node *middle(Node *head)
{
	Node *temp ;
	if(head-&#062;next == NULL)
		return head ;
	else if(head-&#062;next-&#062;next == NULL)
		return head ;
// clearly there must be at least  three nodes in the list
	temp = head ;
	head = head-&#062;next ;
	while(head &#038;&#038; head-&#062;next)
		{
			temp = temp-&#062;next ;
			head = head-&#062;next-&#062;next ;
		}
	return temp ;
}
	

Node *merge_sort(Node *head)
{

	Node *list1 ,*list2 ;
	Node *temp , *newhead  = NULL ,*rear;
	if(!head &#124;&#124;head-&#062;next == NULL)	
		return head ;
	
	temp = middle(head) ;
	list2 = temp-&#062;next ;
	temp-&#062;next = NULL ;
	list1 = merge_sort(head) ;
	list2  = merge_sort(list2) ;

	while(list1 &#038;&#038; list2 )
	{
		if(list1-&#062;data &#062; list2-&#062;data)
			{
				if(newhead == NULL)
				{
					newhead = list2 ;
					rear = newhead ;
					list2 = list2-&#062;next ;
				}
				else
				{
					rear-&#062;next = list2 ;
					list2 = list2-&#062;next ;
					rear = rear-&#062;next ;
				}
			}
		else
						{
				if(newhead == NULL)
				{
					newhead = list1 ;
					rear = newhead ;
					list1 = list1-&#062;next ;
				}
				else
				{
					rear-&#062;next = list1 ;
					list1 = list1-&#062;next ;
					rear = rear-&#062;next ;
				}
			}
	}

	if(list1)
		rear-&#062;next = list1 ;
	else
		rear-&#062;next = list2 ;

	return newhead ;
}

Node *insert(Node *head , int val)
{
	Node *temp = malloc(sizeof(Node)) ;
	temp-&#062;data = val ;
	temp-&#062;next = NULL ;
	if(!head)
		return temp ;
	
	temp-&#062;next = head ;
	return temp ;
}

void deleteList(Node *head)
{
	if(!head)
		return ;

	deleteList(head-&#062;next) ;
	free(head) ;
}

void DeleteIter(Node *head)
{
	Node *temp ;
	while(head)
	{
		temp = head-&#062;next ;
		free(head) ;
		head = temp;
	}
}

void display(Node *head)
{
	while(head)
	{
		printf(&quot;  %d  &quot;,head-&#062;data) ;
		head = head-&#062;next ;
	}		
}

int main()
{
  int data[100] = {33, 19, 17, 62, 39, 35, 26, 49, 36, 50, 21, 49, 55, 47, 20, 64, 25, 34, 22, 21, 57, 12, 44, 20, 34, 18, 47, 66, 58, 47, 52, 7, 8, 66, 35, 21, 55, 17, 15, 35, 61, 63, 59, 26, 1, 62, 52, 31, 11, 24, 21, 49, 64, 64, 16, 26, 38, 34, 25, 32, 24, 46, 38, 54, 47, 6, 47, 15, 14, 59, 64, 31, 39, 38, 24, 32, 5, 64, 50, 64, 50, 32, 21, 17, 32, 18, 46, 32, 20, 31, 38, 47, 55, 60, 40, 6, 47, 38, 20, 41} ;
	Node *head = NULL ;
	int i  ;
	for(i = 0 ; i &#060; 100 ; i++)
		head = insert(head , data[i]) ;
	
	display(head) ;
	head = merge_sort(head) ;
	printf(&#034;\n\n\n\n&#034;) ;
	display(head) ;
	DeleteIter(head) ;
return 0 ;
}]]></description>
		<content:encoded><![CDATA[<p>sorting the list using linked list</p>
<p>#include<br />
#include</p>
<p>struct Node<br />
{<br />
	int data ;<br />
	struct Node  * next ;<br />
};<br />
typedef struct Node Node ;</p>
<p>Node *middle(Node *head)<br />
{<br />
	Node *temp ;<br />
	if(head-&gt;next == NULL)<br />
		return head ;<br />
	else if(head-&gt;next-&gt;next == NULL)<br />
		return head ;<br />
// clearly there must be at least  three nodes in the list<br />
	temp = head ;<br />
	head = head-&gt;next ;<br />
	while(head &amp;&amp; head-&gt;next)<br />
		{<br />
			temp = temp-&gt;next ;<br />
			head = head-&gt;next-&gt;next ;<br />
		}<br />
	return temp ;<br />
}</p>
<p>Node *merge_sort(Node *head)<br />
{</p>
<p>	Node *list1 ,*list2 ;<br />
	Node *temp , *newhead  = NULL ,*rear;<br />
	if(!head ||head-&gt;next == NULL)<br />
		return head ;</p>
<p>	temp = middle(head) ;<br />
	list2 = temp-&gt;next ;<br />
	temp-&gt;next = NULL ;<br />
	list1 = merge_sort(head) ;<br />
	list2  = merge_sort(list2) ;</p>
<p>	while(list1 &amp;&amp; list2 )<br />
	{<br />
		if(list1-&gt;data &gt; list2-&gt;data)<br />
			{<br />
				if(newhead == NULL)<br />
				{<br />
					newhead = list2 ;<br />
					rear = newhead ;<br />
					list2 = list2-&gt;next ;<br />
				}<br />
				else<br />
				{<br />
					rear-&gt;next = list2 ;<br />
					list2 = list2-&gt;next ;<br />
					rear = rear-&gt;next ;<br />
				}<br />
			}<br />
		else<br />
						{<br />
				if(newhead == NULL)<br />
				{<br />
					newhead = list1 ;<br />
					rear = newhead ;<br />
					list1 = list1-&gt;next ;<br />
				}<br />
				else<br />
				{<br />
					rear-&gt;next = list1 ;<br />
					list1 = list1-&gt;next ;<br />
					rear = rear-&gt;next ;<br />
				}<br />
			}<br />
	}</p>
<p>	if(list1)<br />
		rear-&gt;next = list1 ;<br />
	else<br />
		rear-&gt;next = list2 ;</p>
<p>	return newhead ;<br />
}</p>
<p>Node *insert(Node *head , int val)<br />
{<br />
	Node *temp = malloc(sizeof(Node)) ;<br />
	temp-&gt;data = val ;<br />
	temp-&gt;next = NULL ;<br />
	if(!head)<br />
		return temp ;</p>
<p>	temp-&gt;next = head ;<br />
	return temp ;<br />
}</p>
<p>void deleteList(Node *head)<br />
{<br />
	if(!head)<br />
		return ;</p>
<p>	deleteList(head-&gt;next) ;<br />
	free(head) ;<br />
}</p>
<p>void DeleteIter(Node *head)<br />
{<br />
	Node *temp ;<br />
	while(head)<br />
	{<br />
		temp = head-&gt;next ;<br />
		free(head) ;<br />
		head = temp;<br />
	}<br />
}</p>
<p>void display(Node *head)<br />
{<br />
	while(head)<br />
	{<br />
		printf(&#8221;  %d  &#8220;,head-&gt;data) ;<br />
		head = head-&gt;next ;<br />
	}<br />
}</p>
<p>int main()<br />
{<br />
  int data[100] = {33, 19, 17, 62, 39, 35, 26, 49, 36, 50, 21, 49, 55, 47, 20, 64, 25, 34, 22, 21, 57, 12, 44, 20, 34, 18, 47, 66, 58, 47, 52, 7, 8, 66, 35, 21, 55, 17, 15, 35, 61, 63, 59, 26, 1, 62, 52, 31, 11, 24, 21, 49, 64, 64, 16, 26, 38, 34, 25, 32, 24, 46, 38, 54, 47, 6, 47, 15, 14, 59, 64, 31, 39, 38, 24, 32, 5, 64, 50, 64, 50, 32, 21, 17, 32, 18, 46, 32, 20, 31, 38, 47, 55, 60, 40, 6, 47, 38, 20, 41} ;<br />
	Node *head = NULL ;<br />
	int i  ;<br />
	for(i = 0 ; i &lt; 100 ; i++)<br />
		head = insert(head , data[i]) ;</p>
<p>	display(head) ;<br />
	head = merge_sort(head) ;<br />
	printf(&quot;\n\n\n\n&quot;) ;<br />
	display(head) ;<br />
	DeleteIter(head) ;<br />
return 0 ;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:08:25 -->

<!-- Compression = gzip -->