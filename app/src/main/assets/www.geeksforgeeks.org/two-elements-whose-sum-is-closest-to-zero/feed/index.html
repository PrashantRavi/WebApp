<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Two elements whose sum is closest to zero</title>
	<atom:link href="http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Shashank</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-38223</link>
		<dc:creator><![CDATA[Shashank]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 16:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-38223</guid>
		<description><![CDATA[what is if we sort on the basis of abs value of numbers. thn take sum of a[i]+a[i+1] and take a variable min.. nd if sum &#060; min store it and store two number Time complexity O(nlogn)... easy implementation..]]></description>
		<content:encoded><![CDATA[<p>what is if we sort on the basis of abs value of numbers. thn take sum of a[i]+a[i+1] and take a variable min.. nd if sum &lt; min store it and store two number Time complexity O(nlogn)&#8230; easy implementation..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-38093</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 11:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-38093</guid>
		<description><![CDATA[But, if we use merge sort, then it is correct. Even if we use quicksort, and consider the average case, then it is correct again.]]></description>
		<content:encoded><![CDATA[<p>But, if we use merge sort, then it is correct. Even if we use quicksort, and consider the average case, then it is correct again.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: lokeshkumar</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-36954</link>
		<dc:creator><![CDATA[lokeshkumar]]></dc:creator>
		<pubDate>Wed, 28 May 2014 13:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-36954</guid>
		<description><![CDATA[I have a another algorithm thats working for many test cases i checked . Its as follows:

1. Sort array in increasing order.
2. Have two pointers say i , j .. i starting from largest negative number(smallest in magnitude) and j starts from lowest positive number , so i and j both starts from somewhere in middle .
3. Compute sum(i,j) and do j++ till sum is decreasing ,then fix j and do i-- and again compute sum(i,j) and repeat the above step .
4. Maintain absolute min till now and update it when need.

Answer will be = Min (above ans,sum of lowest two negative nos, sum of lowest two positive nos).

Time complexity= O(nlogn) + O(n)

Please check if you find any ambiguity in this. It works for my cases.]]></description>
		<content:encoded><![CDATA[<p>I have a another algorithm thats working for many test cases i checked . Its as follows:</p>
<p>1. Sort array in increasing order.<br />
2. Have two pointers say i , j .. i starting from largest negative number(smallest in magnitude) and j starts from lowest positive number , so i and j both starts from somewhere in middle .<br />
3. Compute sum(i,j) and do j++ till sum is decreasing ,then fix j and do i&#8211; and again compute sum(i,j) and repeat the above step .<br />
4. Maintain absolute min till now and update it when need.</p>
<p>Answer will be = Min (above ans,sum of lowest two negative nos, sum of lowest two positive nos).</p>
<p>Time complexity= O(nlogn) + O(n)</p>
<p>Please check if you find any ambiguity in this. It works for my cases.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: adude</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-29404</link>
		<dc:creator><![CDATA[adude]]></dc:creator>
		<pubDate>Tue, 29 Oct 2013 05:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-29404</guid>
		<description><![CDATA[Quicksort has a worst case of O(n^2), which I feel is worth noting. Your time complexity is wrong.]]></description>
		<content:encoded><![CDATA[<p>Quicksort has a worst case of O(n^2), which I feel is worth noting. Your time complexity is wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ashu</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-24732</link>
		<dc:creator><![CDATA[ashu]]></dc:creator>
		<pubDate>Fri, 09 Aug 2013 08:52:19 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-24732</guid>
		<description><![CDATA[This can be further optimized to O(nlogn + logn).
Do a binary search for 0 in the sorted array.


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>This can be further optimized to O(nlogn + logn).<br />
Do a binary search for 0 in the sorted array.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: neham</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-16708</link>
		<dc:creator><![CDATA[neham]]></dc:creator>
		<pubDate>Tue, 26 Mar 2013 02:27:38 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-16708</guid>
		<description><![CDATA[what if there are ties between the pairs i.e. two pairs with same lowest sum say 1
for example (10,8,3,5,-9,-7,6)

here there are three pairs ((10,-9) = 1),((8,-9) = -1), ((8,-7) = 1) whose abs(sum) is 1 

Acc. to above algo it print (10,-9) pair as it comes first in sorted array.

what should be the right output in this case?


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>what if there are ties between the pairs i.e. two pairs with same lowest sum say 1<br />
for example (10,8,3,5,-9,-7,6)</p>
<p>here there are three pairs ((10,-9) = 1),((8,-9) = -1), ((8,-7) = 1) whose abs(sum) is 1 </p>
<p>Acc. to above algo it print (10,-9) pair as it comes first in sorted array.</p>
<p>what should be the right output in this case?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rodrex Lee</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-25831</link>
		<dc:creator><![CDATA[Rodrex Lee]]></dc:creator>
		<pubDate>Tue, 26 Mar 2013 01:11:06 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-25831</guid>
		<description><![CDATA[what if there are ties between the pairs i.e. two pairs with same lowest sum say 1.
for example (10,8,3,5,-9,-7,6).

here there are three pairs ((10,-9) = 1),((8,-9) = -1), ((8,-7) = 1) whose abs(sum) is 1. 

Acc. to above algo it print (10,-9) pair as it comes first in sorted array.

what should be the right output in this case?]]></description>
		<content:encoded><![CDATA[<p>what if there are ties between the pairs i.e. two pairs with same lowest sum say 1.<br />
for example (10,8,3,5,-9,-7,6).</p>
<p>here there are three pairs ((10,-9) = 1),((8,-9) = -1), ((8,-7) = 1) whose abs(sum) is 1. </p>
<p>Acc. to above algo it print (10,-9) pair as it comes first in sorted array.</p>
<p>what should be the right output in this case?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ajiteshpathak</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-16500</link>
		<dc:creator><![CDATA[ajiteshpathak]]></dc:creator>
		<pubDate>Tue, 19 Mar 2013 16:43:47 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-16500</guid>
		<description><![CDATA[Here is another try for solution. Thought is to calculate the sum for each combination till the counter reaches the last element

int SumCloseToZero(int *arr, int n)
{
	int x, y;	// Variables to store the indexes of the two numbers
	int i = 0, j = 1;

	int min_sum = INT_MAX;
	int min_curr;

	while (i &lt; n - 1)
	{
		min_curr = arr[i] + arr[j];
		
		if (abs(min_curr) &lt; min_sum)
		{
			min_sum = abs(min_curr);
			x = i;
			y = j;
		}
		
		j++;

		if (j == n)
		{
			i++;
			j = i + 1;
		}
	}
	printf(&quot; Values are (%d, %d)&quot;, arr[x], arr[y]);
	return min_sum;
}]]></description>
		<content:encoded><![CDATA[<p>Here is another try for solution. Thought is to calculate the sum for each combination till the counter reaches the last element</p>
<p>int SumCloseToZero(int *arr, int n)<br />
{<br />
	int x, y;	// Variables to store the indexes of the two numbers<br />
	int i = 0, j = 1;</p>
<p>	int min_sum = INT_MAX;<br />
	int min_curr;</p>
<p>	while (i < n - 1)
	{
		min_curr = arr[i] + arr[j];
		
		if (abs(min_curr) < min_sum)
		{
			min_sum = abs(min_curr);
			x = i;
			y = j;
		}
		
		j++;

		if (j == n)
		{
			i++;
			j = i + 1;
		}
	}
	printf(" Values are (%d, %d)", arr[x], arr[y]);
	return min_sum;
}
</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ronny</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-10513</link>
		<dc:creator><![CDATA[ronny]]></dc:creator>
		<pubDate>Thu, 30 Aug 2012 14:27:07 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-10513</guid>
		<description><![CDATA[You are right @ amitp49..the above code by @ asd would not work for many test cases..great job]]></description>
		<content:encoded><![CDATA[<p>You are right @ amitp49..the above code by @ asd would not work for many test cases..great job</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: amitp49</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-9292</link>
		<dc:creator><![CDATA[amitp49]]></dc:creator>
		<pubDate>Mon, 25 Jun 2012 05:25:16 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-9292</guid>
		<description><![CDATA[Will it work on {-300,-2,-1,5,6,300} ?
i guess ans should be -300 &#038; 300 , but ur algo would give -2,-1 as ans combination..]]></description>
		<content:encoded><![CDATA[<p>Will it work on {-300,-2,-1,5,6,300} ?<br />
i guess ans should be -300 &amp; 300 , but ur algo would give -2,-1 as ans combination..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: asd</title>
		<link>http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/#comment-4994</link>
		<dc:creator><![CDATA[asd]]></dc:creator>
		<pubDate>Tue, 23 Aug 2011 06:39:40 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4034#comment-4994</guid>
		<description><![CDATA[sorry the previous algo needs a bit of changes...

Here is the updated one.
----------------------
If there are minimum of 2 numbers in the array {

a1, a2 = (1) Find the positive first and second minimum from the array.
b1, b2 = (2) Find the negative first max and second max from the array.

Do all four combinations of additions and then output that value whose absolute value is minimum.

}
else
Print the no. present]]></description>
		<content:encoded><![CDATA[<p>sorry the previous algo needs a bit of changes&#8230;</p>
<p>Here is the updated one.<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
If there are minimum of 2 numbers in the array {</p>
<p>a1, a2 = (1) Find the positive first and second minimum from the array.<br />
b1, b2 = (2) Find the negative first max and second max from the array.</p>
<p>Do all four combinations of additions and then output that value whose absolute value is minimum.</p>
<p>}<br />
else<br />
Print the no. present</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:24:30 -->

<!-- Compression = gzip -->