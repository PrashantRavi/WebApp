<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Closest Pair of Points &#124;  O(nlogn) Implementation</title>
	<atom:link href="http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: arjomanD</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-35910</link>
		<dc:creator><![CDATA[arjomanD]]></dc:creator>
		<pubDate>Mon, 12 May 2014 03:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-35910</guid>
		<description><![CDATA[Too much Implementation !!
c++
======================================
http://paste.ubuntu.com/7450541/]]></description>
		<content:encoded><![CDATA[<p>Too much Implementation !!<br />
c++<br />
======================================<br />
<a href="http://paste.ubuntu.com/7450541/" rel="nofollow">http://paste.ubuntu.com/7450541/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ColacX</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-35019</link>
		<dc:creator><![CDATA[ColacX]]></dc:creator>
		<pubDate>Wed, 23 Apr 2014 09:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-35019</guid>
		<description><![CDATA[Point Px[n];

is this valid C++ code? doesn&#039;t compile for me.
where is the memory located, on the stack or heap?]]></description>
		<content:encoded><![CDATA[<p>Point Px[n];</p>
<p>is this valid C++ code? doesn&#8217;t compile for me.<br />
where is the memory located, on the stack or heap?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-34897</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sun, 20 Apr 2014 02:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-34897</guid>
		<description><![CDATA[I don&#039;t think so. I am implementing this code right now and when I follow your suggestion, I get an out_of_range error. When I follow G4G&#039;s code, I do not.]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t think so. I am implementing this code right now and when I follow your suggestion, I get an out_of_range error. When I follow G4G&#8217;s code, I do not.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sekhar</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-34282</link>
		<dc:creator><![CDATA[Sekhar]]></dc:creator>
		<pubDate>Fri, 04 Apr 2014 05:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-34282</guid>
		<description><![CDATA[Does this algorithmn take care of mid &#038;&#038; px+mid points for min distance calculation ? ex i have 6 pair of points, does this take care of 3rd and 4th pair in calculation for min distance]]></description>
		<content:encoded><![CDATA[<p>Does this algorithmn take care of mid &amp;&amp; px+mid points for min distance calculation ? ex i have 6 pair of points, does this take care of 3rd and 4th pair in calculation for min distance</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Serif</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-33676</link>
		<dc:creator><![CDATA[Serif]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 23:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-33676</guid>
		<description><![CDATA[A simple n log n trailing edge algorithm:

]]></description>
		<content:encoded><![CDATA[<p>A simple n log n trailing edge algorithm:</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rohan</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30659</link>
		<dc:creator><![CDATA[rohan]]></dc:creator>
		<pubDate>Wed, 11 Dec 2013 20:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30659</guid>
		<description><![CDATA[GeeksforGeeks

you are using one variable extra in both pyl n pyr as below

 Point Pyl[mid+1];   // y sorted points on left of vertical line

if mid==3 for 6 elements then we need array of 3 elements (mid elements instead of mid+1)

    Point Pyr[n-mid-1];  // y sorted points on right of vertical line//same reason

kindly update it as following as it creates a lot of confussion

 Point Pyl[mid];   // y sorted points on left of vertical line

    Point Pyr[n-mid];  // y sorted points on right of vertical line]]></description>
		<content:encoded><![CDATA[<p>GeeksforGeeks</p>
<p>you are using one variable extra in both pyl n pyr as below</p>
<p> Point Pyl[mid+1];   // y sorted points on left of vertical line</p>
<p>if mid==3 for 6 elements then we need array of 3 elements (mid elements instead of mid+1)</p>
<p>    Point Pyr[n-mid-1];  // y sorted points on right of vertical line//same reason</p>
<p>kindly update it as following as it creates a lot of confussion</p>
<p> Point Pyl[mid];   // y sorted points on left of vertical line</p>
<p>    Point Pyr[n-mid];  // y sorted points on right of vertical line</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ofer</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30289</link>
		<dc:creator><![CDATA[Ofer]]></dc:creator>
		<pubDate>Sun, 01 Dec 2013 13:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30289</guid>
		<description><![CDATA[An O(n) algorithm using some assumptions:

If you know the maximum distance you&#039;re looking for, i.e points with distance greater than say &#039;r&#039; don&#039;t matter, and you can properly discretize your input into integer coordinates, and assuming the number of points closer than r is O(logn), and assuming the radius r is constant, then you can design an algorithm with O(n) runtime.

Here&#039;s an outline of the algorithm:

- For each point, you add the point and its neighbor points within the radius to a hashmap. If there&#039;s already a different point in the hashmap in that spot, then we know the two points are neighbors, i.e within radius r. We add their distance to a min heap.

- We take the minimum of the min heap as the minimum distance.

Since the heap has only O(logn) points, and so O(log^2(n)) pairs, adding all pairs of points to the heap is O(log^2(n)*log(logn)) throughout the algorithm.

As we went over the points once, the runtime is amortized O(n). If we want it O(n) worstcase, we can use a huge array instead of the hashmap.]]></description>
		<content:encoded><![CDATA[<p>An O(n) algorithm using some assumptions:</p>
<p>If you know the maximum distance you&#8217;re looking for, i.e points with distance greater than say &#8216;r&#8217; don&#8217;t matter, and you can properly discretize your input into integer coordinates, and assuming the number of points closer than r is O(logn), and assuming the radius r is constant, then you can design an algorithm with O(n) runtime.</p>
<p>Here&#8217;s an outline of the algorithm:</p>
<p>&#8211; For each point, you add the point and its neighbor points within the radius to a hashmap. If there&#8217;s already a different point in the hashmap in that spot, then we know the two points are neighbors, i.e within radius r. We add their distance to a min heap.</p>
<p>&#8211; We take the minimum of the min heap as the minimum distance.</p>
<p>Since the heap has only O(logn) points, and so O(log^2(n)) pairs, adding all pairs of points to the heap is O(log^2(n)*log(logn)) throughout the algorithm.</p>
<p>As we went over the points once, the runtime is amortized O(n). If we want it O(n) worstcase, we can use a huge array instead of the hashmap.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30273</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 21:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30273</guid>
		<description><![CDATA[viki, thanks for pointing this out.  We have updated the code.]]></description>
		<content:encoded><![CDATA[<p>viki, thanks for pointing this out.  We have updated the code.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: viki</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30262</link>
		<dc:creator><![CDATA[viki]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 14:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30262</guid>
		<description><![CDATA[This line will cause Pyl to go out of bound-

Pyl[i] = Py[i];]]></description>
		<content:encoded><![CDATA[<p>This line will cause Pyl to go out of bound-</p>
<p>Pyl[i] = Py[i];</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30246</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 08:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30246</guid>
		<description><![CDATA[I&#039;ve made this program in C
&lt;code&gt;
#include

#include

void abs(int*);//Finds absolute Value

int diff(int,int);//Finds difference

void enter_ar(int *);//To enter Array

struct inf{

	  int a,b,c;

	  }z[50],f;

struct inf sm(struct inf*,int);//To find smallest in &quot;struct inf&quot; type array

void main()

{

	int *a,i,j,k=0;

	clrscr();

	enter_ar(a);

	for(i=0;i&#060;n;i++)//Loop to trasfer differecnes of array &#034;a&#034; to array of structure &#034;z&#034;

	{

		for(j=i+1;j&#060;n;j++)

		{

			(z[k].a)=diff(a[i],a[j]);

			(z[k].b)=i;

			(z[k].c)=j;

			k++;

		}

	}

	f=sm(z,k);//Smallest in array z[i].a

	printf(&#034;Posiotions are:  %d %dnValues are:  %d %d &#034;,f.b,f.c,a[f.b],a[f.c]);

	getch();

}

void abs(int* a)

{

	if((*a)&#060;0)

	{

		*a=(-1)*(*a);

	}

	else return;

}

int diff(int a, int b)

{

	int c;

	c=(a-b);

	abs(&#038;c);

	return c;

}

struct inf sm(struct inf a[],int k)

{

	int s=a[0].a,i,pos;

	for(i=0;ia[i].a)

		{

			s=a[i].a;

			pos=i;

		}

	}

	return a[pos];

}

void enter_ar(int a[])

{

	int n,i;

	printf(&quot;Enter Size:&quot;);

	scanf(&quot;%d&quot;,&#038;n);

	printf(&quot;nEnter array:&quot;);

	for(i=0;i&#060;n;i++)

	{

		scanf(&#034;%d&#034;,a+i);

	}

}]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve made this program in C<br />
<code><br />
#include</p>
<p>#include</p>
<p>void abs(int*);//Finds absolute Value</p>
<p>int diff(int,int);//Finds difference</p>
<p>void enter_ar(int *);//To enter Array</p>
<p>struct inf{</p>
<p>	  int a,b,c;</p>
<p>	  }z[50],f;</p>
<p>struct inf sm(struct inf*,int);//To find smallest in "struct inf" type array</p>
<p>void main()</p>
<p>{</p>
<p>	int *a,i,j,k=0;</p>
<p>	clrscr();</p>
<p>	enter_ar(a);</p>
<p>	for(i=0;i&lt;n;i++)//Loop to trasfer differecnes of array &quot;a&quot; to array of structure &quot;z&quot;</p>
<p>	{</p>
<p>		for(j=i+1;j&lt;n;j++)</p>
<p>		{</p>
<p>			(z[k].a)=diff(a[i],a[j]);</p>
<p>			(z[k].b)=i;</p>
<p>			(z[k].c)=j;</p>
<p>			k++;</p>
<p>		}</p>
<p>	}</p>
<p>	f=sm(z,k);//Smallest in array z[i].a</p>
<p>	printf(&quot;Posiotions are:  %d %dnValues are:  %d %d &quot;,f.b,f.c,a[f.b],a[f.c]);</p>
<p>	getch();</p>
<p>}</p>
<p>void abs(int* a)</p>
<p>{</p>
<p>	if((*a)&lt;0)</p>
<p>	{</p>
<p>		*a=(-1)*(*a);</p>
<p>	}</p>
<p>	else return;</p>
<p>}</p>
<p>int diff(int a, int b)</p>
<p>{</p>
<p>	int c;</p>
<p>	c=(a-b);</p>
<p>	abs(&amp;c);</p>
<p>	return c;</p>
<p>}</p>
<p>struct inf sm(struct inf a[],int k)</p>
<p>{</p>
<p>	int s=a[0].a,i,pos;</p>
<p>	for(i=0;ia[i].a)</p>
<p>		{</p>
<p>			s=a[i].a;</p>
<p>			pos=i;</p>
<p>		}</p>
<p>	}</p>
<p>	return a[pos];</p>
<p>}</p>
<p>void enter_ar(int a[])</p>
<p>{</p>
<p>	int n,i;</p>
<p>	printf("Enter Size:");</p>
<p>	scanf("%d",&amp;n);</p>
<p>	printf("nEnter array:");</p>
<p>	for(i=0;i&lt;n;i++)</p>
<p>	{</p>
<p>		scanf(&quot;%d&quot;,a+i);</p>
<p>	}</p>
<p>}</code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/#comment-30245</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 08:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=124186#comment-30245</guid>
		<description><![CDATA[I&#039;ve tried to make this program in C, its output is correct
&lt;code&gt;
#include
#include


void abs(int*);//Finds absolute Value
int diff(int,int);//Finds difference
void enter_ar(int *);//To enter Array

struct inf{
   int a,b,c;
   }z[50],f;

struct inf sm(struct inf*,int);//To find smallest in &quot;struct inf&quot; type array

void main()
{
int *a,i,j,k=0;
clrscr();
enter_ar(a);
for(i=0;i&#060;n;i++)//Loop to trasfer differecnes of array &#034;a&#034; to array of structure &#034;z&#034;
{
for(j=i+1;j&#060;n;j++)
{
(z[k].a)=diff(a[i],a[j]);
(z[k].b)=i;
(z[k].c)=j;
k++;
}
}
f=sm(z,k);//Smallest in array z[i].a
printf(&#034;Posiotions are:  %d %dnValues are:  %d %d &#034;,f.b,f.c,a[f.b],a[f.c]);
getch();
}

void abs(int* a)
{
if((*a)&#060;0)
{
*a=(-1)*(*a);
}
else return;
}

int diff(int a, int b)
{
int c;
c=(a-b);
abs(&#038;c);
return c;
}

struct inf sm(struct inf a[],int k)
{
int s=a[0].a,i,pos;
for(i=0;ia[i].a)
{
s=a[i].a;
pos=i;
}
}
return a[pos];
}

void enter_ar(int a[])
{
int n,i;
printf(&quot;Enter Size:&quot;);
scanf(&quot;%d&quot;,&#038;n);
printf(&quot;nEnter array:&quot;);
for(i=0;i&#060;n;i++)
{
scanf(&#034;%d&#034;,a+i);
}
}

&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve tried to make this program in C, its output is correct<br />
<code><br />
#include<br />
#include</p>
<p>void abs(int*);//Finds absolute Value<br />
int diff(int,int);//Finds difference<br />
void enter_ar(int *);//To enter Array</p>
<p>struct inf{<br />
   int a,b,c;<br />
   }z[50],f;</p>
<p>struct inf sm(struct inf*,int);//To find smallest in "struct inf" type array</p>
<p>void main()<br />
{<br />
int *a,i,j,k=0;<br />
clrscr();<br />
enter_ar(a);<br />
for(i=0;i&lt;n;i++)//Loop to trasfer differecnes of array &quot;a&quot; to array of structure &quot;z&quot;<br />
{<br />
for(j=i+1;j&lt;n;j++)<br />
{<br />
(z[k].a)=diff(a[i],a[j]);<br />
(z[k].b)=i;<br />
(z[k].c)=j;<br />
k++;<br />
}<br />
}<br />
f=sm(z,k);//Smallest in array z[i].a<br />
printf(&quot;Posiotions are:  %d %dnValues are:  %d %d &quot;,f.b,f.c,a[f.b],a[f.c]);<br />
getch();<br />
}</p>
<p>void abs(int* a)<br />
{<br />
if((*a)&lt;0)<br />
{<br />
*a=(-1)*(*a);<br />
}<br />
else return;<br />
}</p>
<p>int diff(int a, int b)<br />
{<br />
int c;<br />
c=(a-b);<br />
abs(&amp;c);<br />
return c;<br />
}</p>
<p>struct inf sm(struct inf a[],int k)<br />
{<br />
int s=a[0].a,i,pos;<br />
for(i=0;ia[i].a)<br />
{<br />
s=a[i].a;<br />
pos=i;<br />
}<br />
}<br />
return a[pos];<br />
}</p>
<p>void enter_ar(int a[])<br />
{<br />
int n,i;<br />
printf("Enter Size:");<br />
scanf("%d",&amp;n);<br />
printf("nEnter array:");<br />
for(i=0;i&lt;n;i++)<br />
{<br />
scanf(&quot;%d&quot;,a+i);<br />
}<br />
}</p>
<p></code></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:12:32 -->

<!-- Compression = gzip -->