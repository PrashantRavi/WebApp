<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Count number of binary strings without consecutive 1&#8217;s</title>
	<atom:link href="http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Abhishek</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-40171</link>
		<dc:creator><![CDATA[Abhishek]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 14:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-40171</guid>
		<description><![CDATA[Thanks Rahul for the explanation.
I would like to add that it is not a direct fibonacci series.The recurrence relation should be:
result[n]= (2*result[n-1]) + result[n-2] with base case as
 result[0]=1 and result[1]=2


I checked it with n=4,the output should be 8
0000,0100,0001,1000,0010,0101,1010,0101
]]></description>
		<content:encoded><![CDATA[<p>Thanks Rahul for the explanation.<br />
I would like to add that it is not a direct fibonacci series.The recurrence relation should be:<br />
result[n]= (2*result[n-1]) + result[n-2] with base case as<br />
 result[0]=1 and result[1]=2</p>
<p>I checked it with n=4,the output should be 8<br />
0000,0100,0001,1000,0010,0101,1010,0101</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GS</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39962</link>
		<dc:creator><![CDATA[GS]]></dc:creator>
		<pubDate>Fri, 27 Jun 2014 11:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39962</guid>
		<description><![CDATA[its Fibonacci right ? a[i] = a[i-1]+a[i-2] with start a[1]=2;a[2] = 3]]></description>
		<content:encoded><![CDATA[<p>its Fibonacci right ? a[i] = a[i-1]+a[i-2] with start a[1]=2;a[2] = 3</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek Chauhan</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39963</link>
		<dc:creator><![CDATA[Abhishek Chauhan]]></dc:creator>
		<pubDate>Fri, 27 Jun 2014 11:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39963</guid>
		<description><![CDATA[The problem just reduces to nth fibonacci sequence .]]></description>
		<content:encoded><![CDATA[<p>The problem just reduces to nth fibonacci sequence .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mrigank Dembla</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39890</link>
		<dc:creator><![CDATA[Mrigank Dembla]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 15:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39890</guid>
		<description><![CDATA[a[i] = a[i-1] + b[i-1] and b[i]=a[i-1] so it is safe to say b[i-1]=a[i-2] so instead of taking 2 arrays a and b, we can directly take it in one array like
A[0]=1 , A[1]=2;              // as n=0 means 0 so 1 and n=1 means 0 and 1
for(i=2;i&#060;=n;i++)
    A[i]=A[i-1]+ A[i-2];
return A[n];
It will also give correct answer.]]></description>
		<content:encoded><![CDATA[<p>a[i] = a[i-1] + b[i-1] and b[i]=a[i-1] so it is safe to say b[i-1]=a[i-2] so instead of taking 2 arrays a and b, we can directly take it in one array like<br />
A[0]=1 , A[1]=2;              // as n=0 means 0 so 1 and n=1 means 0 and 1<br />
for(i=2;i&lt;=n;i++)<br />
    A[i]=A[i-1]+ A[i-2];<br />
return A[n];<br />
It will also give correct answer.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tweety</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39473</link>
		<dc:creator><![CDATA[tweety]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 16:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39473</guid>
		<description><![CDATA[no its not.... it is  true for 2 and 3]]></description>
		<content:encoded><![CDATA[<p>no its not&#8230;. it is  true for 2 and 3</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vikas6816</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39453</link>
		<dc:creator><![CDATA[vikas6816]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 12:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39453</guid>
		<description><![CDATA[i think it must be   2^n - n*(n-1)/2  always]]></description>
		<content:encoded><![CDATA[<p>i think it must be   2^n &#8211; n*(n-1)/2  always</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sabariram</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39266</link>
		<dc:creator><![CDATA[Sabariram]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 15:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39266</guid>
		<description><![CDATA[Check the following code space complexity O(1) and time complexity O(n)

http://ideone.com/EAIIHJ]]></description>
		<content:encoded><![CDATA[<p>Check the following code space complexity O(1) and time complexity O(n)</p>
<p><a href="http://ideone.com/EAIIHJ" rel="nofollow">http://ideone.com/EAIIHJ</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aditya Joshi</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39259</link>
		<dc:creator><![CDATA[Aditya Joshi]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 14:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39259</guid>
		<description><![CDATA[It is linear asymptomatically in both the iterative and recursive procedures but in practical systems the iterative procedure is faster.]]></description>
		<content:encoded><![CDATA[<p>It is linear asymptomatically in both the iterative and recursive procedures but in practical systems the iterative procedure is faster.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aditya Joshi</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39258</link>
		<dc:creator><![CDATA[Aditya Joshi]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 14:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39258</guid>
		<description><![CDATA[Here&#039;s a solution in Python. http://ideone.com/zTVEXG
Consider n = 4, we have four blanks _ _ _ _ 
If we put a 0 in the first blank, we could put either a 1 or a 0 in the next blank. Therefore, we just reduced our problem to f(n-1)


Now, if we put a 1 in the first blank, the second blank HAS to be 0 because there can be no consecutive 1&#039;s. Therefore, we reduce our problem to f(n-2). 


The total number of strings for f(n) then are f(n) = f(n - 1) + f(n - 2) with base cases f(1) = 2 and f(2) = 3]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s a solution in Python. <a href="http://ideone.com/zTVEXG" rel="nofollow">http://ideone.com/zTVEXG</a><br />
Consider n = 4, we have four blanks _ _ _ _<br />
If we put a 0 in the first blank, we could put either a 1 or a 0 in the next blank. Therefore, we just reduced our problem to f(n-1)</p>
<p>Now, if we put a 1 in the first blank, the second blank HAS to be 0 because there can be no consecutive 1&#8217;s. Therefore, we reduce our problem to f(n-2). </p>
<p>The total number of strings for f(n) then are f(n) = f(n &#8211; 1) + f(n &#8211; 2) with base cases f(1) = 2 and f(2) = 3</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: young</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39244</link>
		<dc:creator><![CDATA[young]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 11:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39244</guid>
		<description><![CDATA[i dont get the logic how index decide whether the 1&#039;s are consecutive or not... plz somebody expalin]]></description>
		<content:encoded><![CDATA[<p>i dont get the logic how index decide whether the 1&#8217;s are consecutive or not&#8230; plz somebody expalin</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wenchao</title>
		<link>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/#comment-39228</link>
		<dc:creator><![CDATA[wenchao]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 09:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=129801#comment-39228</guid>
		<description><![CDATA[Another solution: suppose we Have  a string cosists of only 0s, we want to insert some 1s into the gaps between the 0s.  For example we want it insert three 1s into &quot;0000&quot;, it could be 1010100, or 1001001.There are limited number of available slots for us to insert 1s. 

For example, in &quot;0000&quot;, we have 5 slots. For N number of 0s, we have N+1 slots. So the problem goes down to how do we chose these slots. 

Assume there are X number of 1s to insert, there are C(X, N+1) possibilities.

PSEUDOCODE
count = 0
N = n //size of string 
X = 0 //number of 1s to insert

//number of 1s need to be less than the number of available slots
while ( X&#060;= (N+1-x) ){
      count+= C(x,N+1)
      x++
}
print(count)]]></description>
		<content:encoded><![CDATA[<p>Another solution: suppose we Have  a string cosists of only 0s, we want to insert some 1s into the gaps between the 0s.  For example we want it insert three 1s into &#8220;0000&#8221;, it could be 1010100, or 1001001.There are limited number of available slots for us to insert 1s. </p>
<p>For example, in &#8220;0000&#8221;, we have 5 slots. For N number of 0s, we have N+1 slots. So the problem goes down to how do we chose these slots. </p>
<p>Assume there are X number of 1s to insert, there are C(X, N+1) possibilities.</p>
<p>PSEUDOCODE<br />
count = 0<br />
N = n //size of string<br />
X = 0 //number of 1s to insert</p>
<p>//number of 1s need to be less than the number of available slots<br />
while ( X&lt;= (N+1-x) ){<br />
      count+= C(x,N+1)<br />
      x++<br />
}<br />
print(count)</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:57 -->

<!-- Compression = gzip -->