<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find depth of the deepest odd level leaf node</title>
	<atom:link href="http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-39484</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 18:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-39484</guid>
		<description><![CDATA[This won&#039;t work when there are only first 2 levels. The output would be &#039;0&#039; but the expected output is &#039;1&#039;!]]></description>
		<content:encoded><![CDATA[<p>This won&#8217;t work when there are only first 2 levels. The output would be &#8216;0&#8217; but the expected output is &#8216;1&#8217;!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mohaan Raja</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-38591</link>
		<dc:creator><![CDATA[Mohaan Raja]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 17:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-38591</guid>
		<description><![CDATA[Thanks samthebest, for correcting me...]]></description>
		<content:encoded><![CDATA[<p>Thanks samthebest, for correcting me&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: instance</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-38523</link>
		<dc:creator><![CDATA[instance]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 07:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-38523</guid>
		<description><![CDATA[void oddLeaf(class tree* root, int d, int&#038; maxDepth) //oddLeaf(root, 1, 1);
{
    if(!root)
        return;
    if(!(root-&#062;left) &#038;&#038; !(root-&#062;right))
    {
        if(maxDepth == 1)
            maxDepth = d;
        else if((d &#062; maxDepth) &#038;&#038; (d%2))
            maxDepth = d;
        cout&#060;&#060;&#034;   &#034;&#060;data&#060;&#060;&#034;   &#034;&#060;&#060;d&#060;&#060;&#034;   &#034;&#060;left, d+1, maxDepth);
    oddLeaf(root-&#062;right, d+1, maxDepth);
}]]></description>
		<content:encoded><![CDATA[<p>void oddLeaf(class tree* root, int d, int&amp; maxDepth) //oddLeaf(root, 1, 1);<br />
{<br />
    if(!root)<br />
        return;<br />
    if(!(root-&gt;left) &amp;&amp; !(root-&gt;right))<br />
    {<br />
        if(maxDepth == 1)<br />
            maxDepth = d;<br />
        else if((d &gt; maxDepth) &amp;&amp; (d%2))<br />
            maxDepth = d;<br />
        cout&lt;&lt;&quot;   &quot;&lt;data&lt;&lt;&quot;   &quot;&lt;&lt;d&lt;&lt;&quot;   &quot;&lt;left, d+1, maxDepth);<br />
    oddLeaf(root-&gt;right, d+1, maxDepth);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-38440</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 15:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-38440</guid>
		<description><![CDATA[int deepestOddNode(btnode *t,int level)
{
    if(t!=NULL)
    {    if(level%2!=0 &#038;&#038; isleafNode(t))
            return level;
            
            return max(deepestOddNode(t-&#062;lchild,level+1),deepestOddNode(t-&#062;rchild,level+1));
    }
    else
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>int deepestOddNode(btnode *t,int level)<br />
{<br />
    if(t!=NULL)<br />
    {    if(level%2!=0 &amp;&amp; isleafNode(t))<br />
            return level;</p>
<p>            return max(deepestOddNode(t-&gt;lchild,level+1),deepestOddNode(t-&gt;rchild,level+1));<br />
    }<br />
    else<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-38439</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 15:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-38439</guid>
		<description><![CDATA[what about the case when the height is even and there is no odd level leaf node..??
thn it should return 0
calculating height will give ryt answer only when ur tree ends as a leaf node at a odd level!]]></description>
		<content:encoded><![CDATA[<p>what about the case when the height is even and there is no odd level leaf node..??<br />
thn it should return 0<br />
calculating height will give ryt answer only when ur tree ends as a leaf node at a odd level!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mohaan Raja</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-34330</link>
		<dc:creator><![CDATA[Mohaan Raja]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 12:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-34330</guid>
		<description><![CDATA[Why can&#039;t we just find the height of the tree and return the height if it is odd or return the height-1 if it is even.
#include 
#include 
 
// A utility function to find maximum of two integers
int max(int x, int y) { return (x &#062; y)? x : y; }
 
// A Binary Tree node
struct Node
{
    int data;
    struct Node *left, *right;
};
 
// A utility function to allocate a new tree node
struct Node* newNode(int data)
{
    struct Node* node = (struct Node*) malloc(sizeof(struct Node));
    node-&#062;data = data;
    node-&#062;left = node-&#062;right = NULL;
    return node;
}
 

int getHeight(struct Node* node)
{
   if (node==NULL)
       return 0;
   else
   {
       /* compute the depth of each subtree */
       int lDepth = getHeight(node-&#062;left);
       int rDepth = getHeight(node-&#062;right);
 
       /* use the larger one */
       if (lDepth &#062; rDepth)
         /* use the larger one */
       if (lDepth &#062; rDepth)
           return(lDepth+1);
       else return(rDepth+1);
   }
} 
/* Main function which calculates the depth of deepest odd level leaf.
  This function mainly uses depthOfOddLeafUtil() */
int depthOfOddLeaf(struct Node *root)
{
    int height= getHeight(root);
    return (    return(lDepth+1);
       else return(rDepth+1);
   }
} 
/* Main function which calculates the depth of deepest odd level leaf.
  This function mainly uses depthOfOddLeafUtil() */
int depthOfOddLeaf(struct Node *root)
{
    int height= getHeight(root);
    return ((height&#038;1)?height:height-1);
}
 
// Driver program to test above functions
int main()
{
    struct Node* root = newNode(1);
    root-&#062;left = newNode(2);
    root-&#062;right = newNode(3);
    root-&#062;left-&#062;left = newNode(4);
    root-&#062;right-&#062;left = newNode(5);
    root-&#062;right-&#062;right = newNode(6);
    root-&#062;right-&#062;left-&#062;right = newNode(7);
    root-&#062;right-&#062;right-&#062;right = newNode(8);
    root-&#062;right-&#062;left-&#062;right-&#062;left = newNode(9);
    root-&#062;right-&#062;right-&#062;right-&#062;right = newNode(10);
    root-&#062;right-&#062;right-&#062;right-&#062;right-&#062;left = newNode(11);
 
    printf(&quot;%d is the required depthn&quot;, depthOfOddLeaf(root));
    getchar();
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>Why can&#8217;t we just find the height of the tree and return the height if it is odd or return the height-1 if it is even.<br />
#include<br />
#include </p>
<p>// A utility function to find maximum of two integers<br />
int max(int x, int y) { return (x &gt; y)? x : y; }</p>
<p>// A Binary Tree node<br />
struct Node<br />
{<br />
    int data;<br />
    struct Node *left, *right;<br />
};</p>
<p>// A utility function to allocate a new tree node<br />
struct Node* newNode(int data)<br />
{<br />
    struct Node* node = (struct Node*) malloc(sizeof(struct Node));<br />
    node-&gt;data = data;<br />
    node-&gt;left = node-&gt;right = NULL;<br />
    return node;<br />
}</p>
<p>int getHeight(struct Node* node)<br />
{<br />
   if (node==NULL)<br />
       return 0;<br />
   else<br />
   {<br />
       /* compute the depth of each subtree */<br />
       int lDepth = getHeight(node-&gt;left);<br />
       int rDepth = getHeight(node-&gt;right);</p>
<p>       /* use the larger one */<br />
       if (lDepth &gt; rDepth)<br />
         /* use the larger one */<br />
       if (lDepth &gt; rDepth)<br />
           return(lDepth+1);<br />
       else return(rDepth+1);<br />
   }<br />
}<br />
/* Main function which calculates the depth of deepest odd level leaf.<br />
  This function mainly uses depthOfOddLeafUtil() */<br />
int depthOfOddLeaf(struct Node *root)<br />
{<br />
    int height= getHeight(root);<br />
    return (    return(lDepth+1);<br />
       else return(rDepth+1);<br />
   }<br />
}<br />
/* Main function which calculates the depth of deepest odd level leaf.<br />
  This function mainly uses depthOfOddLeafUtil() */<br />
int depthOfOddLeaf(struct Node *root)<br />
{<br />
    int height= getHeight(root);<br />
    return ((height&amp;1)?height:height-1);<br />
}</p>
<p>// Driver program to test above functions<br />
int main()<br />
{<br />
    struct Node* root = newNode(1);<br />
    root-&gt;left = newNode(2);<br />
    root-&gt;right = newNode(3);<br />
    root-&gt;left-&gt;left = newNode(4);<br />
    root-&gt;right-&gt;left = newNode(5);<br />
    root-&gt;right-&gt;right = newNode(6);<br />
    root-&gt;right-&gt;left-&gt;right = newNode(7);<br />
    root-&gt;right-&gt;right-&gt;right = newNode(8);<br />
    root-&gt;right-&gt;left-&gt;right-&gt;left = newNode(9);<br />
    root-&gt;right-&gt;right-&gt;right-&gt;right = newNode(10);<br />
    root-&gt;right-&gt;right-&gt;right-&gt;right-&gt;left = newNode(11);</p>
<p>    printf(&#8220;%d is the required depthn&#8221;, depthOfOddLeaf(root));<br />
    getchar();<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Uma Trika</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-30334</link>
		<dc:creator><![CDATA[Uma Trika]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 16:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-30334</guid>
		<description><![CDATA[void depthUtil(struct Node *root, int h, int *max)

{

        if(root == NULL)

        return;

        if((h&#062;*max) &#038;&#038; (h&#038;1) &#038;&#038; !root-&#062;left &#038;&#038; !root-&#062;right)

        {

                *max = h;

                printf(&quot;Node: %d is at %dn&quot;, root-&#062;data,*max);

        }

        depthUtil(root-&#062;left, h+1, max);

        depthUtil(root-&#062;right, h+1, max);

}]]></description>
		<content:encoded><![CDATA[<p>void depthUtil(struct Node *root, int h, int *max)</p>
<p>{</p>
<p>        if(root == NULL)</p>
<p>        return;</p>
<p>        if((h&gt;*max) &amp;&amp; (h&amp;1) &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</p>
<p>        {</p>
<p>                *max = h;</p>
<p>                printf(&#8220;Node: %d is at %dn&#8221;, root-&gt;data,*max);</p>
<p>        }</p>
<p>        depthUtil(root-&gt;left, h+1, max);</p>
<p>        depthUtil(root-&gt;right, h+1, max);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivekz</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-30239</link>
		<dc:creator><![CDATA[Vivekz]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 02:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-30239</guid>
		<description><![CDATA[Consider a binary tree as
                                         1
                                      /      
                                    2         5
                                   /          /
                                 3          6
                                            /
                                          8
                                        /
                                     9.


Wouldnt the above code return  3 for node 3 rather than 5 for node 9?
edit : the formatting is bad but 6,8 and 9 are children of 5]]></description>
		<content:encoded><![CDATA[<p>Consider a binary tree as<br />
                                         1<br />
                                      /<br />
                                    2         5<br />
                                   /          /<br />
                                 3          6<br />
                                            /<br />
                                          8<br />
                                        /<br />
                                     9.</p>
<p>Wouldnt the above code return  3 for node 3 rather than 5 for node 9?<br />
edit : the formatting is bad but 6,8 and 9 are children of 5</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kartik</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-30238</link>
		<dc:creator><![CDATA[Kartik]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 02:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-30238</guid>
		<description><![CDATA[Could your provide an example tree for which the above approach won&#039;t work?]]></description>
		<content:encoded><![CDATA[<p>Could your provide an example tree for which the above approach won&#8217;t work?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivekz</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-30236</link>
		<dc:creator><![CDATA[Vivekz]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 21:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-30236</guid>
		<description><![CDATA[@GeeksforGeeks:  I thinj there is a bug in your solution. Your solution returns the first leaf found at an odd level as the deepest one, but there might be more leafs deeper in the tree at an odd level. Kindly correct if my inference is wrong]]></description>
		<content:encoded><![CDATA[<p>@GeeksforGeeks:  I thinj there is a bug in your solution. Your solution returns the first leaf found at an odd level as the deepest one, but there might be more leafs deeper in the tree at an odd level. Kindly correct if my inference is wrong</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dazer</title>
		<link>http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/#comment-30043</link>
		<dc:creator><![CDATA[dazer]]></dc:creator>
		<pubDate>Fri, 22 Nov 2013 02:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122306#comment-30043</guid>
		<description><![CDATA[void findoddnode(node *root,int count,int *c )

{

	if(root== NULL) return;

	if(*c left == NULL &#038;&#038; root-&#062;right == NULL){

		      *c = count;  //to keep track of level .. 

	    }

	}

     findoddnode(root-&#062;left,count+1,c) ;

	 findoddnode(root-&#062;right,count+1,c);

 

}]]></description>
		<content:encoded><![CDATA[<p>void findoddnode(node *root,int count,int *c )</p>
<p>{</p>
<p>	if(root== NULL) return;</p>
<p>	if(*c left == NULL &amp;&amp; root-&gt;right == NULL){</p>
<p>		      *c = count;  //to keep track of level .. </p>
<p>	    }</p>
<p>	}</p>
<p>     findoddnode(root-&gt;left,count+1,c) ;</p>
<p>	 findoddnode(root-&gt;right,count+1,c);</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:44 -->

<!-- Compression = gzip -->