<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Minimum number of jumps to reach end</title>
	<atom:link href="http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Rajesh Yadav</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-39676</link>
		<dc:creator><![CDATA[Rajesh Yadav]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 17:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-39676</guid>
		<description><![CDATA[http://ideone.com/hciveK]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/hciveK" rel="nofollow">http://ideone.com/hciveK</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rajesh Yadav</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-39675</link>
		<dc:creator><![CDATA[Rajesh Yadav]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 17:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-39675</guid>
		<description><![CDATA[#include

int minJumps(int arr[], int n)

{

    int i,j,min=n,b,flag,k;

    int count=0,index;

    b=n;

    for(i=0;i&#060;n;){

    	if(arr[i]==0){

    		printf(&#034;cant proceed ::&#034;);

    		return -1;

    		

    	}

    	flag=0;

    	k=arr[i];

    	if(i==0){

    		count++;

    		b=b-arr[0];

    		i=i+1;

    	}

    	

    	for(j=i+1;jarr[j]){

    			if(min&#062;b-arr[j]){

    				min=b-arr[j];

    				index=j;

    			}

    		}else{

    			

    				flag=1;

    			}

    		

    	}

    	count++;

    	i=i+j;

    	if(flag==1){

    		break;

    	}

    

    }

    return count;

    

}

 

// Driver program to test above function

int main()

{

    int arr[]= {1, 3, 5, 1, 1, 2, 6, 7, 6, 8, 9};

    int size=sizeof(arr)/sizeof(int);

    printf(&quot;Minimum number of jumps to reach end is %d &quot;, minJumps(arr,size));

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>#include</p>
<p>int minJumps(int arr[], int n)</p>
<p>{</p>
<p>    int i,j,min=n,b,flag,k;</p>
<p>    int count=0,index;</p>
<p>    b=n;</p>
<p>    for(i=0;i&lt;n;){</p>
<p>    	if(arr[i]==0){</p>
<p>    		printf(&quot;cant proceed ::&quot;);</p>
<p>    		return -1;</p>
<p>    	}</p>
<p>    	flag=0;</p>
<p>    	k=arr[i];</p>
<p>    	if(i==0){</p>
<p>    		count++;</p>
<p>    		b=b-arr[0];</p>
<p>    		i=i+1;</p>
<p>    	}</p>
<p>    	for(j=i+1;jarr[j]){</p>
<p>    			if(min&gt;b-arr[j]){</p>
<p>    				min=b-arr[j];</p>
<p>    				index=j;</p>
<p>    			}</p>
<p>    		}else{</p>
<p>    				flag=1;</p>
<p>    			}</p>
<p>    	}</p>
<p>    	count++;</p>
<p>    	i=i+j;</p>
<p>    	if(flag==1){</p>
<p>    		break;</p>
<p>    	}</p>
<p>    }</p>
<p>    return count;</p>
<p>}</p>
<p>// Driver program to test above function</p>
<p>int main()</p>
<p>{</p>
<p>    int arr[]= {1, 3, 5, 1, 1, 2, 6, 7, 6, 8, 9};</p>
<p>    int size=sizeof(arr)/sizeof(int);</p>
<p>    printf(&#8220;Minimum number of jumps to reach end is %d &#8220;, minJumps(arr,size));</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ekta Goel</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-39374</link>
		<dc:creator><![CDATA[Ekta Goel]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 18:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-39374</guid>
		<description><![CDATA[Because the complexity of BFS in adjacency list representation is O(V+E), i suppose its much better for small sized arrays.]]></description>
		<content:encoded><![CDATA[<p>Because the complexity of BFS in adjacency list representation is O(V+E), i suppose its much better for small sized arrays.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ekta Goel</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-39373</link>
		<dc:creator><![CDATA[Ekta Goel]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 18:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-39373</guid>
		<description><![CDATA[Although the dp solution is efficient, but the question can also be solved this way: taking every position as a node of a graph and the possible positions where we can jump in array representing edges of that graph, we just need to find the minimum distance from 0th node to the (n-1)th node which can be easily distance using BFS or dijkstra&#039;s..


Please correct me if I am wrong!!]]></description>
		<content:encoded><![CDATA[<p>Although the dp solution is efficient, but the question can also be solved this way: taking every position as a node of a graph and the possible positions where we can jump in array representing edges of that graph, we just need to find the minimum distance from 0th node to the (n-1)th node which can be easily distance using BFS or dijkstra&#8217;s..</p>
<p>Please correct me if I am wrong!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prianca__</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-37690</link>
		<dc:creator><![CDATA[prianca__]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 17:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-37690</guid>
		<description><![CDATA[#include 

#include 

using namespace std;

int minjump(int a[], int start, int n)

{

    if (n == 1)

        return 0;

    if (a[start] == 0)

        return  -1;

    int jump = 0;

    int x;

    for (int i = 0; i &#060; n;) {

    //printf(&#034;dsjdh&#034;);

        jump++;

        int max;

        if (i == 0) max = a[i];

        cout &#060;&#060; i &#060;&#060; &#034;    &#034; &#060;&#060; max &#060;= n)

            break;

        else {

            max = 0;

            int s = a[i];

            cout &#060;&#060; i+1 &#060;&#060; &#034; :: &#034; &#060;&#060; i+s &#060;&#060; endl;

            for (int j = i+1; j &#060;= i+s; j++) {

                if (max &#060; a[j]) {

                    max = a[j];

                    x = j;

                }

            }

            i = x;

        }

    }

    cout &#060;&#060; jump &#060;&#060; endl;

    return jump;

}

int main()

{

  int arr[] = {1, 3, 6, 3, 2, 3, 6, 8, 9, 5};

  //int arr[]= {1, 3, 6, 1, 0, 9};

  int n = sizeof(arr)/sizeof(arr[0]);

  printf(&#034;Minimum number of jumps to reach end is %d &#034;, minjump(arr, 0, n-1));

  return 0;

}





please correct me if the approach or anything else is wrong]]></description>
		<content:encoded><![CDATA[<p>#include </p>
<p>#include </p>
<p>using namespace std;</p>
<p>int minjump(int a[], int start, int n)</p>
<p>{</p>
<p>    if (n == 1)</p>
<p>        return 0;</p>
<p>    if (a[start] == 0)</p>
<p>        return  -1;</p>
<p>    int jump = 0;</p>
<p>    int x;</p>
<p>    for (int i = 0; i &lt; n;) {</p>
<p>    //printf(&quot;dsjdh&quot;);</p>
<p>        jump++;</p>
<p>        int max;</p>
<p>        if (i == 0) max = a[i];</p>
<p>        cout &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; max &lt;= n)</p>
<p>            break;</p>
<p>        else {</p>
<p>            max = 0;</p>
<p>            int s = a[i];</p>
<p>            cout &lt;&lt; i+1 &lt;&lt; &quot; :: &quot; &lt;&lt; i+s &lt;&lt; endl;</p>
<p>            for (int j = i+1; j &lt;= i+s; j++) {</p>
<p>                if (max &lt; a[j]) {</p>
<p>                    max = a[j];</p>
<p>                    x = j;</p>
<p>                }</p>
<p>            }</p>
<p>            i = x;</p>
<p>        }</p>
<p>    }</p>
<p>    cout &lt;&lt; jump &lt;&lt; endl;</p>
<p>    return jump;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  int arr[] = {1, 3, 6, 3, 2, 3, 6, 8, 9, 5};</p>
<p>  //int arr[]= {1, 3, 6, 1, 0, 9};</p>
<p>  int n = sizeof(arr)/sizeof(arr[0]);</p>
<p>  printf(&quot;Minimum number of jumps to reach end is %d &quot;, minjump(arr, 0, n-1));</p>
<p>  return 0;</p>
<p>}</p>
<p>please correct me if the approach or anything else is wrong</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-37003</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Thu, 29 May 2014 10:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-37003</guid>
		<description><![CDATA[Given your array a and the index of your current position i, repeat the following until you reach the last element.

Consider all candidate &quot;jump-to elements&quot; in a[i+1] to a[a[i] + i].  For each such element at index e, calculate v = a[e] + e.  If one of the elements is the last element, jump to the last element.  Otherwise, jump to the element with the maximal v.

More simply put, of the elements within reach, look for the one that will get you furthest on the next jump.  We know this selection, x, is the right one because compared to every other element y you can jump to, the elements reachable from y are a subset of the elements reachable from x (except for elements from a backward jump, which are obviously bad choices).

This algorithm runs in O(n) because each element need be considered 
only once (elements that would be considered a second time can be 
skipped)

]]></description>
		<content:encoded><![CDATA[<p>Given your array a and the index of your current position i, repeat the following until you reach the last element.</p>
<p>Consider all candidate &#8220;jump-to elements&#8221; in a[i+1] to a[a[i] + i].  For each such element at index e, calculate v = a[e] + e.  If one of the elements is the last element, jump to the last element.  Otherwise, jump to the element with the maximal v.</p>
<p>More simply put, of the elements within reach, look for the one that will get you furthest on the next jump.  We know this selection, x, is the right one because compared to every other element y you can jump to, the elements reachable from y are a subset of the elements reachable from x (except for elements from a backward jump, which are obviously bad choices).</p>
<p>This algorithm runs in O(n) because each element need be considered<br />
only once (elements that would be considered a second time can be<br />
skipped)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pradeep Raja</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-36584</link>
		<dc:creator><![CDATA[Pradeep Raja]]></dc:creator>
		<pubDate>Sat, 24 May 2014 17:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-36584</guid>
		<description><![CDATA[Hi,

I used other approach to solve this. Don&#039;t know about the correctness of the solution. It obtained right solution for all test cases I checked. In case if I am wrong kindly mention it. So that I can rectify.

#include
using namespace std;
int main()
{
    int a[]={2, 5, 10, 1, 1, 3, 0, 0, 2, 5, 1, 1, 1, 2, 0, 1, 1};
    int n = sizeof(a)/sizeof(a[0]);
    int jumps[n];
    int reached=0;
    for(int i=0;i&#060;n;i++)
        jumps[i]=0;
    for(int i=0;i&#060;n-1;i++)
    {
       int limit=a[i];
       int j=1;
       if(reached==i&#038;&#038;a[i]==0)
           break;
       while(j&#060;=limit&#038;&#038;(j+ireached)
            {
                jumps[j+i]=jumps[i]+1;
                reached=j+i;
            }
            j++;
        }
        if(reached&#062;=n-1)
            break;
    }
    cout&#060;&#060;jumps[n-1];
}]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I used other approach to solve this. Don&#8217;t know about the correctness of the solution. It obtained right solution for all test cases I checked. In case if I am wrong kindly mention it. So that I can rectify.</p>
<p>#include<br />
using namespace std;<br />
int main()<br />
{<br />
    int a[]={2, 5, 10, 1, 1, 3, 0, 0, 2, 5, 1, 1, 1, 2, 0, 1, 1};<br />
    int n = sizeof(a)/sizeof(a[0]);<br />
    int jumps[n];<br />
    int reached=0;<br />
    for(int i=0;i&lt;n;i++)<br />
        jumps[i]=0;<br />
    for(int i=0;i&lt;n-1;i++)<br />
    {<br />
       int limit=a[i];<br />
       int j=1;<br />
       if(reached==i&amp;&amp;a[i]==0)<br />
           break;<br />
       while(j&lt;=limit&amp;&amp;(j+ireached)<br />
            {<br />
                jumps[j+i]=jumps[i]+1;<br />
                reached=j+i;<br />
            }<br />
            j++;<br />
        }<br />
        if(reached&gt;=n-1)<br />
            break;<br />
    }<br />
    cout&lt;&lt;jumps[n-1];<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Chirag Gupta</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-35195</link>
		<dc:creator><![CDATA[Chirag Gupta]]></dc:creator>
		<pubDate>Sun, 27 Apr 2014 13:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-35195</guid>
		<description><![CDATA[in the second method, why the second condtion jump[j]!=INT_MAX    used, what is the need of this condition ?]]></description>
		<content:encoded><![CDATA[<p>in the second method, why the second condtion jump[j]!=INT_MAX    used, what is the need of this condition ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-35102</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Fri, 25 Apr 2014 09:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-35102</guid>
		<description><![CDATA[Hi,

I have o(n) solution. Can someone please tell me problem with the algorithm or in which case it will not work?

// Returns minimum number of jumps to reach arr[n-1] from arr[0]

int minJumps(int arr[], int n)

{

    int *jumps = (int*)malloc(sizeof(int)*n);  // jumps[n-1] will hold the result

    int i=1, j=0;

 

    jumps[0] = 0;

 

 	for(i=1;i&#060;n;)

 	{

 		if(arr[j]+j &#060; i)

 		{

 			j++;

 		}

 		else

 		{

 			jumps[i] = jumps[j]+1;

 			i++;

 		}

 	}

 

 	printf(&#034;jumps: &#034;);

 	for(i=0;i&#060;n;i++)

 	{

 		printf(&#034;%d, &#034;,jumps[i]);

 	}

 

    return jumps[n-1];

}]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I have o(n) solution. Can someone please tell me problem with the algorithm or in which case it will not work?</p>
<p>// Returns minimum number of jumps to reach arr[n-1] from arr[0]</p>
<p>int minJumps(int arr[], int n)</p>
<p>{</p>
<p>    int *jumps = (int*)malloc(sizeof(int)*n);  // jumps[n-1] will hold the result</p>
<p>    int i=1, j=0;</p>
<p>    jumps[0] = 0;</p>
<p> 	for(i=1;i&lt;n;)</p>
<p> 	{</p>
<p> 		if(arr[j]+j &lt; i)</p>
<p> 		{</p>
<p> 			j++;</p>
<p> 		}</p>
<p> 		else</p>
<p> 		{</p>
<p> 			jumps[i] = jumps[j]+1;</p>
<p> 			i++;</p>
<p> 		}</p>
<p> 	}</p>
<p> 	printf(&quot;jumps: &quot;);</p>
<p> 	for(i=0;i&lt;n;i++)</p>
<p> 	{</p>
<p> 		printf(&quot;%d, &quot;,jumps[i]);</p>
<p> 	}</p>
<p>    return jumps[n-1];</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Faiz</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-34637</link>
		<dc:creator><![CDATA[Faiz]]></dc:creator>
		<pubDate>Sun, 13 Apr 2014 06:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-34637</guid>
		<description><![CDATA[is this a possible solution?
Starting from i = 0;
Find farthest max number in range (i+1, i+array[i])
set i = index of max value;
repeat until i + max &#062;= n;


with farthest max i mean this
{1,5,6,3,2,6,4}
here the max is 6 but there are two 6. So return the index 5 since that 6 is the farthest.]]></description>
		<content:encoded><![CDATA[<p>is this a possible solution?<br />
Starting from i = 0;<br />
Find farthest max number in range (i+1, i+array[i])<br />
set i = index of max value;<br />
repeat until i + max &gt;= n;</p>
<p>with farthest max i mean this<br />
{1,5,6,3,2,6,4}<br />
here the max is 6 but there are two 6. So return the index 5 since that 6 is the farthest.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Wellwisher</title>
		<link>http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/#comment-34175</link>
		<dc:creator><![CDATA[Wellwisher]]></dc:creator>
		<pubDate>Tue, 01 Apr 2014 22:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=13209#comment-34175</guid>
		<description><![CDATA[Ready solution in C#


http://onestopinterviewprep.blogspot.com/2014/03/traverse-array-in-shortest-number-of.html]]></description>
		<content:encoded><![CDATA[<p>Ready solution in C#</p>
<p><a href="http://onestopinterviewprep.blogspot.com/2014/03/traverse-array-in-shortest-number-of.html" rel="nofollow">http://onestopinterviewprep.blogspot.com/2014/03/traverse-array-in-shortest-number-of.html</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:27 -->

<!-- Compression = gzip -->