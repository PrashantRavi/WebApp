<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Split a Circular Linked List into two halves</title>
	<atom:link href="http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-40122</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 08:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-40122</guid>
		<description><![CDATA[@geeksforgeeks:disqus I think there is a mistake in if condition u have to use while I think  if(fast_ptr-&#062;next-&#062;next == head)
    fast_ptr = fast_ptr-&#062;next;]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus I think there is a mistake in if condition u have to use while I think  if(fast_ptr-&gt;next-&gt;next == head)<br />
    fast_ptr = fast_ptr-&gt;next;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-36275</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Mon, 19 May 2014 13:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-36275</guid>
		<description><![CDATA[Why make push as O(n) ? Isn&#039;t it better to maintain reference to tail? That way push can be O(1). That is:
&lt;code&gt;void push(node **tailRef, int data)
{
	node *newnode = malloc(sizeof(node));
	newnode-&#062;data = data;
	if(*tailRef != NULL)
	{
		newnode-&#062;next = (*tailRef)-&#062;next;
		(*tailRef)-&#062;next = newnode;
	}
	else
	{
		newnode-&#062;next = NULL;
		*tailRef = newnode;
	}
}
&lt;/code&gt;
Another possibility is to maintain a head pointer itself, insert **after** the head node and swap the data between the current head node &#038; the new node and make that as the new headNode.]]></description>
		<content:encoded><![CDATA[<p>Why make push as O(n) ? Isn&#8217;t it better to maintain reference to tail? That way push can be O(1). That is:<br />
<code>void push(node **tailRef, int data)<br />
{<br />
	node *newnode = malloc(sizeof(node));<br />
	newnode-&gt;data = data;<br />
	if(*tailRef != NULL)<br />
	{<br />
		newnode-&gt;next = (*tailRef)-&gt;next;<br />
		(*tailRef)-&gt;next = newnode;<br />
	}<br />
	else<br />
	{<br />
		newnode-&gt;next = NULL;<br />
		*tailRef = newnode;<br />
	}<br />
}<br />
</code><br />
Another possibility is to maintain a head pointer itself, insert **after** the head node and swap the data between the current head node &amp; the new node and make that as the new headNode.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saurabh</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-34343</link>
		<dc:creator><![CDATA[saurabh]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 20:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-34343</guid>
		<description><![CDATA[Its correct.. got the logic.. you can delete the post.]]></description>
		<content:encoded><![CDATA[<p>Its correct.. got the logic.. you can delete the post.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saurabh</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-34342</link>
		<dc:creator><![CDATA[saurabh]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 19:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-34342</guid>
		<description><![CDATA[I think the condition while(fast_ptr-&#062;next != head &#038;&#038;
         fast_ptr-&#062;next-&#062;next != head)  is wrong there should be OR condition.. Let me know if I am wrong]]></description>
		<content:encoded><![CDATA[<p>I think the condition while(fast_ptr-&gt;next != head &amp;&amp;<br />
         fast_ptr-&gt;next-&gt;next != head)  is wrong there should be OR condition.. Let me know if I am wrong</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: suyash</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-30913</link>
		<dc:creator><![CDATA[suyash]]></dc:creator>
		<pubDate>Sat, 21 Dec 2013 15:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-30913</guid>
		<description><![CDATA[when there is only one node , you cann&#039;t split list into 2 hence there will be only one resulting list so no need to set head2...]]></description>
		<content:encoded><![CDATA[<p>when there is only one node , you cann&#8217;t split list into 2 hence there will be only one resulting list so no need to set head2&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nitin Pallindrome</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-28006</link>
		<dc:creator><![CDATA[Nitin Pallindrome]]></dc:creator>
		<pubDate>Sun, 22 Sep 2013 14:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-28006</guid>
		<description><![CDATA[hmmm...]]></description>
		<content:encoded><![CDATA[<p>hmmm&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Karshit</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-22297</link>
		<dc:creator><![CDATA[Karshit]]></dc:creator>
		<pubDate>Wed, 17 Jul 2013 18:52:50 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-22297</guid>
		<description><![CDATA[My Code.. hope you find it useful..


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;iostream&#062;

using namespace std;

struct node {
    int data;
    node *next;
};

node *create(int n)
{
    if (n == 0)
        return NULL;

    node *head = new node();
    cin &#062;&#062; (head -&#062; data);

    head -&#062; next = head;
    node *p = head;

    for (int i = 1; i &#060; n; i++) {
        p -&#062; next = new node();

        p = p -&#062; next;

        cin &#062;&#062; (p -&#062; data);
        p -&#062; next = head;
    }

    return head;
}

void print(node *head)
{
    if (head == NULL)
        return;

    node *p = head -&#062; next;

    cout &#060;&#060; head -&#062; data &#060;&#060; &#034; &#034;;
    while (p != head) {
        cout &#060;&#060; p -&#062; data &#060;&#060; &#034; &#034;;
        p = p -&#062; next;
    }
}

pair &#060;node *, node*&#062; split(node *head)
{
    pair &#060;node *, node *&#062; p;

    if (head -&#062; next == head) {
        cout &#060;&#060; &#034;Only one element in link list..printing one element\n&#034;;
        p = make_pair(head, head);
        return p;
    }

    node *slow = head, *fast = head;
    node *head1 = NULL;

    while (fast -&#062; next != head) {
        slow = slow -&#062; next;
        fast = fast -&#062; next -&#062; next;

        if (fast == head)
            break;
    }

    head1 = slow;

    node *pp = head;

    while (pp -&#062; next != head1) {
        pp = pp -&#062; next;
    }

    pp -&#062; next = head;

    while (slow -&#062; next != head) {
        slow = slow -&#062; next;
    }

    slow -&#062; next = head1;
    p = make_pair(head, head1);

    return p;
}

int main()
{
    int n;
    node *head = NULL;

    cin &#062;&#062; n;

    head = create(n);

    cout &#060;&#060; &#034;Original : &#034;;
    print(head);
    cout &#060;&#060; &#034;\n\n&#034;;

    pair &#060;node *, node *&#062; p;

    p = split(head);

    cout &#060;&#060; &#034;Split : \n&#034;;

    print(p.first);
    cout &#060;&#060; &#034;\n&#034;;
    print(p.second);

    return 0;
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>My Code.. hope you find it useful..</p>
<pre> <code language="C">
#include &lt;iostream&gt;

using namespace std;

struct node {
    int data;
    node *next;
};

node *create(int n)
{
    if (n == 0)
        return NULL;

    node *head = new node();
    cin &gt;&gt; (head -&gt; data);

    head -&gt; next = head;
    node *p = head;

    for (int i = 1; i &lt; n; i++) {
        p -&gt; next = new node();

        p = p -&gt; next;

        cin &gt;&gt; (p -&gt; data);
        p -&gt; next = head;
    }

    return head;
}

void print(node *head)
{
    if (head == NULL)
        return;

    node *p = head -&gt; next;

    cout &lt;&lt; head -&gt; data &lt;&lt; &quot; &quot;;
    while (p != head) {
        cout &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;;
        p = p -&gt; next;
    }
}

pair &lt;node *, node*&gt; split(node *head)
{
    pair &lt;node *, node *&gt; p;

    if (head -&gt; next == head) {
        cout &lt;&lt; &quot;Only one element in link list..printing one element\n&quot;;
        p = make_pair(head, head);
        return p;
    }

    node *slow = head, *fast = head;
    node *head1 = NULL;

    while (fast -&gt; next != head) {
        slow = slow -&gt; next;
        fast = fast -&gt; next -&gt; next;

        if (fast == head)
            break;
    }

    head1 = slow;

    node *pp = head;

    while (pp -&gt; next != head1) {
        pp = pp -&gt; next;
    }

    pp -&gt; next = head;

    while (slow -&gt; next != head) {
        slow = slow -&gt; next;
    }

    slow -&gt; next = head1;
    p = make_pair(head, head1);

    return p;
}

int main()
{
    int n;
    node *head = NULL;

    cin &gt;&gt; n;

    head = create(n);

    cout &lt;&lt; &quot;Original : &quot;;
    print(head);
    cout &lt;&lt; &quot;\n\n&quot;;

    pair &lt;node *, node *&gt; p;

    p = split(head);

    cout &lt;&lt; &quot;Split : \n&quot;;

    print(p.first);
    cout &lt;&lt; &quot;\n&quot;;
    print(p.second);

    return 0;
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jitendra.BITS</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-21556</link>
		<dc:creator><![CDATA[Jitendra.BITS]]></dc:creator>
		<pubDate>Sat, 06 Jul 2013 16:18:32 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-21556</guid>
		<description><![CDATA[What&#039;s the use of this line?
Is it to check that the list has just one node or not??

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
if(head-&#062;next != head)
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>What&#8217;s the use of this line?<br />
Is it to check that the list has just one node or not??</p>
<pre> <code language="C">
if(head-&gt;next != head)
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: neham</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-17078</link>
		<dc:creator><![CDATA[neham]]></dc:creator>
		<pubDate>Wed, 03 Apr 2013 21:18:38 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-17078</guid>
		<description><![CDATA[Here is another way of splitting the circular linked list having O(n) complexity. It counts the number of nodes and then split it.

    stnd* ptr = root;
    float count = 1;
    int half;

    while( ptr-&#062;next != root) {
        ++count;
        ptr = ptr-&#062;next;
    }
    
    ptr = root;
    half = ceil(count / 2);
    cout &#060;&#060;endl &#060;&#060;count &#060;&#060;&#034;\t&#034; &#060;&#060;half &#060; 1 ) {
        --half;
        ptr = ptr-&#062;next;
    }

    *head1 = root;
    *head2 = ptr-&#062;next;
    ptr-&#062;next = root;
    ptr = *head2;

    while( ptr-&#062;next != root) { 
        ptr = ptr-&#062;next;
    }
    ptr-&#062;next = *head2;]]></description>
		<content:encoded><![CDATA[<p>Here is another way of splitting the circular linked list having O(n) complexity. It counts the number of nodes and then split it.</p>
<p>    stnd* ptr = root;<br />
    float count = 1;<br />
    int half;</p>
<p>    while( ptr-&gt;next != root) {<br />
        ++count;<br />
        ptr = ptr-&gt;next;<br />
    }</p>
<p>    ptr = root;<br />
    half = ceil(count / 2);<br />
    cout &lt;&lt;endl &lt;&lt;count &lt;&lt;&quot;\t&quot; &lt;&lt;half &lt; 1 ) {<br />
        &#8211;half;<br />
        ptr = ptr-&gt;next;<br />
    }</p>
<p>    *head1 = root;<br />
    *head2 = ptr-&gt;next;<br />
    ptr-&gt;next = root;<br />
    ptr = *head2;</p>
<p>    while( ptr-&gt;next != root) {<br />
        ptr = ptr-&gt;next;<br />
    }<br />
    ptr-&gt;next = *head2;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tuhin@jucse</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-7077</link>
		<dc:creator><![CDATA[tuhin@jucse]]></dc:creator>
		<pubDate>Fri, 13 Jan 2012 05:30:56 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-7077</guid>
		<description><![CDATA[tortoise and hare algorithm is  amazing\m/]]></description>
		<content:encoded><![CDATA[<p>tortoise and hare algorithm is  amazing\m/</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: checkitout</title>
		<link>http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/#comment-4707</link>
		<dc:creator><![CDATA[checkitout]]></dc:creator>
		<pubDate>Sat, 23 Jul 2011 19:52:46 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6056#comment-4707</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;
#include&#060;stdlib.h&#062;

int nodes=0;
struct node
{
    int data;
    struct node *next;
    struct node *prev;
    

};
void insnode(int dt,struct node **hn,struct node **en)
{
     nodes++;
     struct node *newnode=(struct node *)malloc(sizeof(struct node));
     newnode-&#062;data=dt;
     newnode-&#062;prev=(*en);
     newnode-&#062;next=(*hn);
     if((*en)!=NULL)
     (*en)-&#062;next=newnode;
     else
     (*hn)=newnode;
     (*en)=newnode;
     
     
 }
 void printlist(struct node *print)
 {
      struct node *start=print;
      do
      {
                              printf(&#034;%d&#034;,print-&#062;data);
                              print=print-&#062;next;
                              
                              }while(print!=start);
                              printf(&#034;\n&#034;);
  }
  void contwo(struct node **hn,struct node **en,struct node **hn1,struct node **en1)
  {
       int number=1;
       struct node *trv=(*hn);
       while(number!=nodes/2)
       {
                             trv=trv-&#062;next;
                             number++;
                             }
                             (*hn1)=trv-&#062;next;
                             (*en1)=(*en);
                             (*en)=trv;
                             (*en)-&#062;next=(*hn);
                             (*en1)-&#062;next=(*hn1);
                             
       
   }
 int main()
 {
      struct node *list=NULL;
      struct node *end=NULL;
      insnode(3,&#038;list,&#038;end);
       insnode(5,&#038;list,&#038;end);
        insnode(5,&#038;list,&#038;end);
         insnode(6,&#038;list,&#038;end);
          insnode(7,&#038;list,&#038;end);
           insnode(8,&#038;list,&#038;end);
            insnode(9,&#038;list,&#038;end);
             insnode(1,&#038;list,&#038;end);
             printlist(list);
             struct node *list1=NULL;
      struct node *end1=NULL;
             contwo(&#038;list,&#038;end,&#038;list1,&#038;end1);
             printlist(list);
             printlist(list1);
             getchar();
             
      
  }
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int nodes=0;
struct node
{
    int data;
    struct node *next;
    struct node *prev;
    

};
void insnode(int dt,struct node **hn,struct node **en)
{
     nodes++;
     struct node *newnode=(struct node *)malloc(sizeof(struct node));
     newnode-&gt;data=dt;
     newnode-&gt;prev=(*en);
     newnode-&gt;next=(*hn);
     if((*en)!=NULL)
     (*en)-&gt;next=newnode;
     else
     (*hn)=newnode;
     (*en)=newnode;
     
     
 }
 void printlist(struct node *print)
 {
      struct node *start=print;
      do
      {
                              printf(&quot;%d&quot;,print-&gt;data);
                              print=print-&gt;next;
                              
                              }while(print!=start);
                              printf(&quot;\n&quot;);
  }
  void contwo(struct node **hn,struct node **en,struct node **hn1,struct node **en1)
  {
       int number=1;
       struct node *trv=(*hn);
       while(number!=nodes/2)
       {
                             trv=trv-&gt;next;
                             number++;
                             }
                             (*hn1)=trv-&gt;next;
                             (*en1)=(*en);
                             (*en)=trv;
                             (*en)-&gt;next=(*hn);
                             (*en1)-&gt;next=(*hn1);
                             
       
   }
 int main()
 {
      struct node *list=NULL;
      struct node *end=NULL;
      insnode(3,&amp;list,&amp;end);
       insnode(5,&amp;list,&amp;end);
        insnode(5,&amp;list,&amp;end);
         insnode(6,&amp;list,&amp;end);
          insnode(7,&amp;list,&amp;end);
           insnode(8,&amp;list,&amp;end);
            insnode(9,&amp;list,&amp;end);
             insnode(1,&amp;list,&amp;end);
             printlist(list);
             struct node *list1=NULL;
      struct node *end1=NULL;
             contwo(&amp;list,&amp;end,&amp;list1,&amp;end1);
             printlist(list);
             printlist(list1);
             getchar();
             
      
  }
</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:00:42 -->

<!-- Compression = gzip -->