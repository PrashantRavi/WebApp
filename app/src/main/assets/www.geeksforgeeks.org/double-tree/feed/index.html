<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Double Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/double-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/double-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Vãîbhåv Joshî</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-40135</link>
		<dc:creator><![CDATA[Vãîbhåv Joshî]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 11:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-40135</guid>
		<description><![CDATA[Java Code for Double Tree


public void doubleTree(){
doubleTree(root);
}

     public void doubleTree(BSTNode root){

     BSTNode temp = new BSTNode();
     if(root==null)
         return;

     doubleTree(root.getLeft());
     doubleTree(root.getRight());

    temp = root.getLeft();
    root.setLeft(new BSTNode(root.getData()));
    root.getLeft().setLeft(temp);
}]]></description>
		<content:encoded><![CDATA[<p>Java Code for Double Tree</p>
<p>public void doubleTree(){<br />
doubleTree(root);<br />
}</p>
<p>     public void doubleTree(BSTNode root){</p>
<p>     BSTNode temp = new BSTNode();<br />
     if(root==null)<br />
         return;</p>
<p>     doubleTree(root.getLeft());<br />
     doubleTree(root.getRight());</p>
<p>    temp = root.getLeft();<br />
    root.setLeft(new BSTNode(root.getData()));<br />
    root.getLeft().setLeft(temp);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ankit</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-39992</link>
		<dc:creator><![CDATA[Ankit]]></dc:creator>
		<pubDate>Fri, 27 Jun 2014 19:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-39992</guid>
		<description><![CDATA[Hello All , 
Here is the inorder version (in C/C++) 
void DoubleTree( Node *n ) {
    if ( n==NULL ) {
         return; 
    }
    else {
        Node *temp = new Node( n-&#062;data);
        DoubleTree(n-&#062;left);
        temp-&#062;left=n-&#062;left;
        n-&#062;left=temp;
        DoubleTree(n-&#062;right);  
    }
}]]></description>
		<content:encoded><![CDATA[<p>Hello All ,<br />
Here is the inorder version (in C/C++)<br />
void DoubleTree( Node *n ) {<br />
    if ( n==NULL ) {<br />
         return;<br />
    }<br />
    else {<br />
        Node *temp = new Node( n-&gt;data);<br />
        DoubleTree(n-&gt;left);<br />
        temp-&gt;left=n-&gt;left;<br />
        n-&gt;left=temp;<br />
        DoubleTree(n-&gt;right);<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aashi</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-39288</link>
		<dc:creator><![CDATA[Aashi]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 20:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-39288</guid>
		<description><![CDATA[i think you can do inorder at place of postorder,,but preorder is not possible for sure]]></description>
		<content:encoded><![CDATA[<p>i think you can do inorder at place of postorder,,but preorder is not possible for sure</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: codex</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-38789</link>
		<dc:creator><![CDATA[codex]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 07:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-38789</guid>
		<description><![CDATA[i can not get the importance of oldLeft in doubleTree function pl help.......]]></description>
		<content:encoded><![CDATA[<p>i can not get the importance of oldLeft in doubleTree function pl help&#8230;&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-37332</link>
		<dc:creator><![CDATA[Amit]]></dc:creator>
		<pubDate>Sun, 01 Jun 2014 05:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-37332</guid>
		<description><![CDATA[Wanted to know a few things
Any specific reason we chose postorder here? will other forms of traversal work just fine here?]]></description>
		<content:encoded><![CDATA[<p>Wanted to know a few things<br />
Any specific reason we chose postorder here? will other forms of traversal work just fine here?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: code_jazz</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-31988</link>
		<dc:creator><![CDATA[code_jazz]]></dc:creator>
		<pubDate>Thu, 30 Jan 2014 08:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-31988</guid>
		<description><![CDATA[well u can skip that duplicate node by recursively making calls kike root-&#062;left-&#062;left if converting the tree in a preorder fashion]]></description>
		<content:encoded><![CDATA[<p>well u can skip that duplicate node by recursively making calls kike root-&gt;left-&gt;left if converting the tree in a preorder fashion</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mukunthan</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-27595</link>
		<dc:creator><![CDATA[Mukunthan]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 06:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-27595</guid>
		<description><![CDATA[Correct me if I am wrong.. Here
Postorder works fine if we can add a duplicate node even to left or right
Inorder works if a duplicate is added to left
Preorder never works

This is because in &quot;Preorder&quot; and &quot;Right duplicate of Inorder&quot; we create a node and then process the duplicate node which will result in an infinite loop..]]></description>
		<content:encoded><![CDATA[<p>Correct me if I am wrong.. Here<br />
Postorder works fine if we can add a duplicate node even to left or right<br />
Inorder works if a duplicate is added to left<br />
Preorder never works</p>
<p>This is because in &#8220;Preorder&#8221; and &#8220;Right duplicate of Inorder&#8221; we create a node and then process the duplicate node which will result in an infinite loop..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pranjalgupta</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-21303</link>
		<dc:creator><![CDATA[pranjalgupta]]></dc:creator>
		<pubDate>Thu, 04 Jul 2013 13:49:34 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-21303</guid>
		<description><![CDATA[We can also create a double tree by preorder traversal technique.
void preorder(tree* root)
{
    if(root==NULL)
    return;
    tree* temp=root-&gt;left;
    root-&gt;left=newnode(root-&gt;data);
    root-&gt;left-&gt;left=temp;
    free(temp);
    preorder(root-&gt;left-&gt;left);
    preorder(root-&gt;right);

}

Also, this is possible by inorder traversal if we modify the tree&#039;s node to have an additional pointer to its parent too.]]></description>
		<content:encoded><![CDATA[<p>We can also create a double tree by preorder traversal technique.<br />
void preorder(tree* root)<br />
{<br />
    if(root==NULL)<br />
    return;<br />
    tree* temp=root->left;<br />
    root->left=newnode(root->data);<br />
    root->left->left=temp;<br />
    free(temp);<br />
    preorder(root->left->left);<br />
    preorder(root->right);</p>
<p>}</p>
<p>Also, this is possible by inorder traversal if we modify the tree&#8217;s node to have an additional pointer to its parent too.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nitesh</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-20906</link>
		<dc:creator><![CDATA[Nitesh]]></dc:creator>
		<pubDate>Sat, 29 Jun 2013 18:44:09 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-20906</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/*Double Tree*/
node* DoubleTree(node *root)
{
      if(root == NULL)
        return NULL;
      
      node *lNode = root-&#062;left;
      node *rNode = root-&#062;right;
      
      root-&#062;left = newNode(root-&#062;data);
      root-&#062;left-&#062;left = lNode;
      if(lNode != NULL)
        DoubleTree(lNode);
      if(rNode != NULL)
        DoubleTree(rNode);
      
      return root;     
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/*Double Tree*/
node* DoubleTree(node *root)
{
      if(root == NULL)
        return NULL;
      
      node *lNode = root-&gt;left;
      node *rNode = root-&gt;right;
      
      root-&gt;left = newNode(root-&gt;data);
      root-&gt;left-&gt;left = lNode;
      if(lNode != NULL)
        DoubleTree(lNode);
      if(rNode != NULL)
        DoubleTree(rNode);
      
      return root;     
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-18113</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Sat, 11 May 2013 10:49:33 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-18113</guid>
		<description><![CDATA[C++ code:


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;iostream&#062;
#include &#060;stdlib.h&#062;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&#062;data=data;
    }
    int get_data() {
      return this-&#062;data;
    }
    void set_left(tree_node * left) {
      this-&#062;left=left;
    }
    tree_node * get_left() {
      return this-&#062;left;
    }
    void set_right(tree_node * right) {
      this-&#062;right=right;
    }
    tree_node * get_right() {
      return this-&#062;right;
    }
    tree_node ** get_left_ref() {
      return &#038;(this-&#062;left);
    }
    tree_node ** get_right_ref() {
      return &#038;(this-&#062;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
    int _diameter(tree_node * root);
    int _is_height_balanced(tree_node * root);
    int _leaf_path_sum(tree_node * root, int num);
    void _double_tree(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&#062;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
    int diameter();
    int is_height_balanced();
    int leaf_path_sum(int num);
    void double_tree();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&#062;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&#062;set_data(value);
    while(current!=NULL) {
      if(value&#060;=current-&#062;get_data()) {
        parent=current;
        current=current-&#062;get_left();
      } else {
        parent=current;
        current=current-&#062;get_right();
      }
    }
    if(value&#060;=parent-&#062;get_data() &#038;&#038; parent-&#062;get_left()==NULL) {
      parent-&#062;set_left(new_node);
    } else if(value&#062;parent-&#062;get_data() &#038;&#038; parent-&#062;get_right()==NULL) {
      parent-&#062;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&#038;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&#062;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&#060;=(*root_ref)-&#062;get_data()) {
      _recursive_insert((*root_ref)-&#062;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&#062;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
  if(root-&#062;get_left()!=NULL)
    _print_preorder(root-&#062;get_left());
  if(root-&#062;get_right()!=NULL)
    _print_preorder(root-&#062;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&#062;get_left()!=NULL)
    _print_inorder(root-&#062;get_left());
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
  if(root-&#062;get_right()!=NULL)
    _print_inorder(root-&#062;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&#062;get_left()!=NULL)
    _print_postorder(root-&#062;get_left());
  if(root-&#062;get_right()!=NULL)
    _print_postorder(root-&#062;get_right());
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&#062;get_left())+_find_size(root-&#062;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&#062;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &#038;&#038; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &#038;&#038; tn2!=NULL) &#124;&#124; (tn1!=NULL &#038;&#038; tn2==NULL) &#124;&#124; (tn1-&#062;get_data()!=tn2-&#062;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&#062;get_left(), tn2-&#062;get_left()) &#038;&#038; _are_identical(tn1-&#062;get_right(), tn2-&#062;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&#062;get_left()), _find_height(root-&#062;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&#038;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&#062;get_left()!=NULL) {
      _delete_tree((*root)-&#062;get_left_ref());
    }
    if((*root)-&#062;get_right()!=NULL) {
      _delete_tree((*root)-&#062;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&#062;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&#062;get_left();
      _delete_tree(&#038;left_ref);
    }
    if((*root)-&#062;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&#062;get_right();
      _delete_tree(&#038;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&#062;get_left();
  root-&#062;set_left(root-&#062;get_right());
  root-&#062;set_right(temp);
  _mirror(root-&#062;get_left());
  _mirror(root-&#062;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&#062;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&#062;get_data();
    _print_paths(root-&#062;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&#062;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&#060;=len; i++) {
    cout&#060;&#060;*(array+i)&#060;&#060;&#034; &#034;;
  }
  cout&#060;&#060;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL &#124;&#124; root-&#062;get_data()==value) {
    return root;
  } else if(value&#060;=root-&#062;get_data()) {
    return _find_node(root-&#062;get_left(), value);
  } else {
    return _find_node(root-&#062;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&#062;get_data()==a &#038;&#038; (root-&#062;get_left()-&#062;get_data()==b &#124;&#124; root-&#062;get_right()-&#062;get_data()==b))
             &#124;&#124; (root-&#062;get_data()==b &#038;&#038; (root-&#062;get_left()-&#062;get_data()==a &#124;&#124; root-&#062;get_right()-&#062;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&#062;get_left(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), b)!=NULL)
        &#124;&#124; (_find_node(root-&#062;get_left(), b)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&#062;get_left(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&#062;get_left(), a, b);
  } else if(_find_node(root-&#062;get_right(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&#062;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL &#124;&#124; root-&#062;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&#062;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&#062;get_left())+_count_leaf_nodes(root-&#062;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&#062;get_left())) {
      return 0;
    }
    if(previous!=NULL &#038;&#038; (previous-&#062;get_data())&#062;(root-&#062;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&#062;get_right())) {
      return 0;
    }    
  }
}

int tree::children_sum() {
  return _children_sum(root);
}

int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&#062;get_left()) &#038;&#038; _children_sum(root-&#062;get_right())){
    int left_data;
    int right_data;
    if(root-&#062;get_left()!=NULL) {
      left_data=root-&#062;get_left()-&#062;get_data();
    } else {
      left_data=0;
    }
    if(root-&#062;get_right()!=NULL) {
      right_data=root-&#062;get_right()-&#062;get_data();
    } else {
      right_data=0;
    }

    if(left_data+right_data==root-&#062;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}

void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL &#124;&#124; (root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&#062;get_left());
    _ensure_children_sum(root-&#062;get_right());
    int left_data;
    int right_data;
    if(root-&#062;get_left()!=NULL) {
      left_data=root-&#062;get_left()-&#062;get_data();
    } else {
      left_data=0;
    }
    if(root-&#062;get_right()!=NULL) {
      right_data=root-&#062;get_right()-&#062;get_data();
    } else {
      right_data=0;
    }
    root-&#062;set_data(left_data+right_data);
  }
}

int tree::diameter() {
  return _diameter(root);
}

int tree::_diameter(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return max(_find_height(root-&#062;get_left())+_find_height(root-&#062;get_right())+1, max(_diameter(root-&#062;get_left()), _diameter(root-&#062;get_left())));
  }
}

int tree::is_height_balanced() {
  return _is_height_balanced(root);
}

int tree::_is_height_balanced(tree_node * root) {
  if(root==NULL) {
    return 1;
  } else {
    int left_height=_find_height(root-&#062;get_left());
    int right_height=_find_height(root-&#062;get_right());
    if(abs(left_height-right_height)&#060;=1 &#038;&#038; _is_height_balanced(root-&#062;get_left()) &#038;&#038; _is_height_balanced(root-&#062;get_left())) {
      return 1;
    } else {
      return 0;
    }
  }
}

int tree::leaf_path_sum(int sum) {
  return _leaf_path_sum(root, sum);
}

int tree::_leaf_path_sum(tree_node * root, int sum) {
  if(root==NULL) {
    return 0;
  } else if(root-&#062;get_data()==sum &#038;&#038; root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL) {
    return 1;
  } else {
    return _leaf_path_sum(root-&#062;get_left(), sum-root-&#062;get_data()) &#124;&#124; _leaf_path_sum(root-&#062;get_right(), sum-root-&#062;get_data());
  }
}

void tree::double_tree() {
  _double_tree(root);
}

void tree::_double_tree(tree_node * root) {
  if(root==NULL) {
    return;
  } else {
    tree_node * new_node=new tree_node;
    new_node-&#062;set_data(root-&#062;get_data());
    tree_node * root_left=root-&#062;get_left();
    root-&#062;set_left(new_node);
    new_node-&#062;set_left(root_left);
    _double_tree(root_left);
    _double_tree(root-&#062;get_right());
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);

  t1.print_inorder();

  t1.double_tree();

  t1.print_inorder();  

  return 0;
}
&lt;/code&gt; &lt;/pre&gt;

1 3 4 5 6 7 10 45 50 55 
1 1 3 3 4 4 5 5 6 6 7 7 10 10 45 45 50 50 55 55]]></description>
		<content:encoded><![CDATA[<p>C++ code:</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
    void _print_level_order(tree_node * root);
    int _count_leaf_nodes(tree_node * root);
    int _is_bst(tree_node * root);
    int _children_sum(tree_node * root);
    void _ensure_children_sum(tree_node * root);
    int _diameter(tree_node * root);
    int _is_height_balanced(tree_node * root);
    int _leaf_path_sum(tree_node * root, int num);
    void _double_tree(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
    void print_level_order();
    int count_leaf_nodes();
    int is_bst();
    int children_sum();
    void ensure_children_sum();
    int diameter();
    int is_height_balanced();
    int leaf_path_sum(int num);
    void double_tree();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    return _find_node(root-&gt;get_left(), value);
  } else {
    return _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int tree::count_leaf_nodes() {
  return _count_leaf_nodes(root);
}

int tree::_count_leaf_nodes(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _count_leaf_nodes(root-&gt;get_left())+_count_leaf_nodes(root-&gt;get_right());
  }
}


int tree::is_bst() {
  return _is_bst(root);
}

int tree::_is_bst(tree_node * root) {
  static tree_node * previous=NULL;
  if(root==NULL) {
    return 1;
  } else {
    if(!_is_bst(root-&gt;get_left())) {
      return 0;
    }
    if(previous!=NULL &amp;&amp; (previous-&gt;get_data())&gt;(root-&gt;get_data())) {
      return 0;
    }
    previous=root;
    if(!_is_bst(root-&gt;get_right())) {
      return 0;
    }    
  }
}

int tree::children_sum() {
  return _children_sum(root);
}

int tree::_children_sum(tree_node * root) {
  if(root==NULL) {
    return 1;
  }
  if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  }
  else if(_children_sum(root-&gt;get_left()) &amp;&amp; _children_sum(root-&gt;get_right())){
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }

    if(left_data+right_data==root-&gt;get_data()) {
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

void tree::ensure_children_sum() {
  _ensure_children_sum(root);
}

void tree::_ensure_children_sum(tree_node * root) {
  if(root==NULL || (root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL)) {
    return;
  } else {
    _ensure_children_sum(root-&gt;get_left());
    _ensure_children_sum(root-&gt;get_right());
    int left_data;
    int right_data;
    if(root-&gt;get_left()!=NULL) {
      left_data=root-&gt;get_left()-&gt;get_data();
    } else {
      left_data=0;
    }
    if(root-&gt;get_right()!=NULL) {
      right_data=root-&gt;get_right()-&gt;get_data();
    } else {
      right_data=0;
    }
    root-&gt;set_data(left_data+right_data);
  }
}

int tree::diameter() {
  return _diameter(root);
}

int tree::_diameter(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return max(_find_height(root-&gt;get_left())+_find_height(root-&gt;get_right())+1, max(_diameter(root-&gt;get_left()), _diameter(root-&gt;get_left())));
  }
}

int tree::is_height_balanced() {
  return _is_height_balanced(root);
}

int tree::_is_height_balanced(tree_node * root) {
  if(root==NULL) {
    return 1;
  } else {
    int left_height=_find_height(root-&gt;get_left());
    int right_height=_find_height(root-&gt;get_right());
    if(abs(left_height-right_height)&lt;=1 &amp;&amp; _is_height_balanced(root-&gt;get_left()) &amp;&amp; _is_height_balanced(root-&gt;get_left())) {
      return 1;
    } else {
      return 0;
    }
  }
}

int tree::leaf_path_sum(int sum) {
  return _leaf_path_sum(root, sum);
}

int tree::_leaf_path_sum(tree_node * root, int sum) {
  if(root==NULL) {
    return 0;
  } else if(root-&gt;get_data()==sum &amp;&amp; root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    return 1;
  } else {
    return _leaf_path_sum(root-&gt;get_left(), sum-root-&gt;get_data()) || _leaf_path_sum(root-&gt;get_right(), sum-root-&gt;get_data());
  }
}

void tree::double_tree() {
  _double_tree(root);
}

void tree::_double_tree(tree_node * root) {
  if(root==NULL) {
    return;
  } else {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(root-&gt;get_data());
    tree_node * root_left=root-&gt;get_left();
    root-&gt;set_left(new_node);
    new_node-&gt;set_left(root_left);
    _double_tree(root_left);
    _double_tree(root-&gt;get_right());
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);
  t1.recursive_insert(1);
  t1.recursive_insert(45);
  t1.recursive_insert(55);
  t1.recursive_insert(4);

  t1.print_inorder();

  t1.double_tree();

  t1.print_inorder();  

  return 0;
}
</code> </pre>
<p>1 3 4 5 6 7 10 45 50 55<br />
1 1 3 3 4 4 5 5 6 6 7 7 10 10 45 45 50 50 55 55</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Soumya Sengupta</title>
		<link>http://www.geeksforgeeks.org/double-tree/#comment-17458</link>
		<dc:creator><![CDATA[Soumya Sengupta]]></dc:creator>
		<pubDate>Thu, 18 Apr 2013 14:37:09 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7071#comment-17458</guid>
		<description><![CDATA[A top-down approch.....






void doubleTree(struct node* node) 
{
  struct node* oldLeft;
 
  if (node==NULL) return;
 
  /* do the subtrees */
  doubleTree(node-&#062;left);
  doubleTree(node-&#062;right);
 
  /* duplicate this node to its left */
  oldLeft = node-&#062;left;
  node-&#062;left = newNode(node-&#062;data);
  node-&#062;left-&#062;left = oldLeft;
}

int main()
{

  /* Constructed binary tree is
				1
			 /   \
		  2      3
		/  \
	 4     5
  */
  struct node *root = newNode(1);

  root-&#062;left        = newNode(2);
  root-&#062;right        = newNode(3);

  root-&#062;left-&#062;left  = newNode(4);
  root-&#062;left-&#062;right = newNode(5);

  printf(&quot;Inorder traversal of the original tree is \n&quot;);
  printInorder(root);

  doubleTree(root);
  doubleTree(root-&#062;right);

  printf(&quot;\n Inorder traversal of the double tree is \n&quot;);
  printInorder(root);

  getchar();
  return 0;
}]]></description>
		<content:encoded><![CDATA[<p>A top-down approch&#8230;..</p>
<p>void doubleTree(struct node* node)<br />
{<br />
  struct node* oldLeft;</p>
<p>  if (node==NULL) return;</p>
<p>  /* do the subtrees */<br />
  doubleTree(node-&gt;left);<br />
  doubleTree(node-&gt;right);</p>
<p>  /* duplicate this node to its left */<br />
  oldLeft = node-&gt;left;<br />
  node-&gt;left = newNode(node-&gt;data);<br />
  node-&gt;left-&gt;left = oldLeft;<br />
}</p>
<p>int main()<br />
{</p>
<p>  /* Constructed binary tree is<br />
				1<br />
			 /   \<br />
		  2      3<br />
		/  \<br />
	 4     5<br />
  */<br />
  struct node *root = newNode(1);</p>
<p>  root-&gt;left        = newNode(2);<br />
  root-&gt;right        = newNode(3);</p>
<p>  root-&gt;left-&gt;left  = newNode(4);<br />
  root-&gt;left-&gt;right = newNode(5);</p>
<p>  printf(&#8220;Inorder traversal of the original tree is \n&#8221;);<br />
  printInorder(root);</p>
<p>  doubleTree(root);<br />
  doubleTree(root-&gt;right);</p>
<p>  printf(&#8220;\n Inorder traversal of the double tree is \n&#8221;);<br />
  printInorder(root);</p>
<p>  getchar();<br />
  return 0;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.053 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:36 -->

<!-- Compression = gzip -->