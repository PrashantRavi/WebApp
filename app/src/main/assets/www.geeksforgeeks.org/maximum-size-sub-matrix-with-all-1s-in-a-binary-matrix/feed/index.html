<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Maximum size square sub-matrix with all 1s</title>
	<atom:link href="http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Paparao Veeragandham</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-39363</link>
		<dc:creator><![CDATA[Paparao Veeragandham]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 16:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-39363</guid>
		<description><![CDATA[int MaxSizeRect(int data[row][col] , int row , int col)
{
//out Max size in Rectangle 2D Matrix.
//temp1 for row wise bigger. temp2 col wise bigger for Matrix.
int temp1[row][col] , temp2[row][col];
int max = INT_MIN;

for ( i = 0; i &#060; row; i++)
{
    temp1[i][0] = data[i][0];
    temp2[i][0] = data[i][0];
}
for( i = 0 ; i&#060; col; i++)
{
    temp1[i][0] = data[i][0];
    temp2[i][0] = data[i][0];
}

for( i = 1; i&#060; row; i++)
for( j = 1; j&#060; col; j++)
{
     if(data[i][j])
      {
          temp1[i][j] = temp1[i-1][j];
          temp2[i][j] = temp2[i][j-1];
      }
     else
       { temp1[i][j] = temp2[i][j] = 0; }
   max = Maximum(max, temp1[i][j], temp2[i][j]);
}
return max;
}]]></description>
		<content:encoded><![CDATA[<p>int MaxSizeRect(int data[row][col] , int row , int col)<br />
{<br />
//out Max size in Rectangle 2D Matrix.<br />
//temp1 for row wise bigger. temp2 col wise bigger for Matrix.<br />
int temp1[row][col] , temp2[row][col];<br />
int max = INT_MIN;</p>
<p>for ( i = 0; i &lt; row; i++)<br />
{<br />
    temp1[i][0] = data[i][0];<br />
    temp2[i][0] = data[i][0];<br />
}<br />
for( i = 0 ; i&lt; col; i++)<br />
{<br />
    temp1[i][0] = data[i][0];<br />
    temp2[i][0] = data[i][0];<br />
}</p>
<p>for( i = 1; i&lt; row; i++)<br />
for( j = 1; j&lt; col; j++)<br />
{<br />
     if(data[i][j])<br />
      {<br />
          temp1[i][j] = temp1[i-1][j];<br />
          temp2[i][j] = temp2[i][j-1];<br />
      }<br />
     else<br />
       { temp1[i][j] = temp2[i][j] = 0; }<br />
   max = Maximum(max, temp1[i][j], temp2[i][j]);<br />
}<br />
return max;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vpr</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-38555</link>
		<dc:creator><![CDATA[vpr]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 12:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-38555</guid>
		<description><![CDATA[below there&#039;s comment by gksgeek (posted 3 yrs ago)
in that conversation, Max tried to explain the concept... see if that helps.]]></description>
		<content:encoded><![CDATA[<p>below there&#8217;s comment by gksgeek (posted 3 yrs ago)<br />
in that conversation, Max tried to explain the concept&#8230; see if that helps.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vpr</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-38543</link>
		<dc:creator><![CDATA[vpr]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 11:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-38543</guid>
		<description><![CDATA[Thanks for the explanation :)]]></description>
		<content:encoded><![CDATA[<p>Thanks for the explanation ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Bottom Boy</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-37981</link>
		<dc:creator><![CDATA[Bottom Boy]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 08:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-37981</guid>
		<description><![CDATA[First you need to divided the problems in sub problems.
Then combine the solution.
Using this approach the complexity of this problem will be more.]]></description>
		<content:encoded><![CDATA[<p>First you need to divided the problems in sub problems.<br />
Then combine the solution.<br />
Using this approach the complexity of this problem will be more.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: epslon</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-37463</link>
		<dc:creator><![CDATA[epslon]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 22:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-37463</guid>
		<description><![CDATA[Can anyone explain how to approach such questions?]]></description>
		<content:encoded><![CDATA[<p>Can anyone explain how to approach such questions?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-37027</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Thu, 29 May 2014 17:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-37027</guid>
		<description><![CDATA[If M[i][j] is &#039;1&#039; then it will contribute to the all 1s square sub-matrix ending at either M[i][j-1] or M[i-1][j] or M[i-1][j-1]. If we visualize the conditions then, we will see: 
S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1]]></description>
		<content:encoded><![CDATA[<p>If M[i][j] is &#8216;1&#8217; then it will contribute to the all 1s square sub-matrix ending at either M[i][j-1] or M[i-1][j] or M[i-1][j-1]. If we visualize the conditions then, we will see:<br />
S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-37026</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Thu, 29 May 2014 16:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-37026</guid>
		<description><![CDATA[how ?]]></description>
		<content:encoded><![CDATA[<p>how ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wrestler</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-35931</link>
		<dc:creator><![CDATA[wrestler]]></dc:creator>
		<pubDate>Mon, 12 May 2014 15:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-35931</guid>
		<description><![CDATA[Index of max is not needed, simply print the square with all 1 of size max.]]></description>
		<content:encoded><![CDATA[<p>Index of max is not needed, simply print the square with all 1 of size max.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Meenal Mishra</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-35787</link>
		<dc:creator><![CDATA[Meenal Mishra]]></dc:creator>
		<pubDate>Thu, 08 May 2014 11:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-35787</guid>
		<description><![CDATA[Guys check this should be helpful 
http://www.queryhome.com/26246/maximum-size-square-sub-matrix-with-all-1-s-recusively]]></description>
		<content:encoded><![CDATA[<p>Guys check this should be helpful<br />
<a href="http://www.queryhome.com/26246/maximum-size-square-sub-matrix-with-all-1-s-recusively" rel="nofollow">http://www.queryhome.com/26246/maximum-size-square-sub-matrix-with-all-1-s-recusively</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Bottom Boy</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-35783</link>
		<dc:creator><![CDATA[Bottom Boy]]></dc:creator>
		<pubDate>Thu, 08 May 2014 10:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-35783</guid>
		<description><![CDATA[typedef struct mat
{
    int n, r, c;
}matParm;

matParm sub_mat;    // Global Variable 
/* Call from main function */

    if( row &#062; col)
        for (i = 0; i  row)
        for (i = 0; i &#060;  col - row ; i++)
            find_sqr_mat (matrix, 0, i, row);
    else
        find_sqr_mat (matrix, 0, 0, col);
/* Print the out put matrix */

printf(&#034;n Largest Sub Square Matrixn&#034;);
printf(&#034;Row = %d  Col = %d  N = %dn&#034;,sub_mat.r, sub_mat.c, sub_mat.n);
for (i = sub_mat.r; i &#060; sub_mat.r + sub_mat.n; i++)
{
    printf(&#034;nn&#034;);
    for (j = sub_mat.c; j n = N;
        tempparm-&#062;r = row;
        tempparm-&#062;c = col;
    }
    else
    {
        tempparm-&#062;n = 0;
        tempparm-&#062;r = 0;
        tempparm-&#062;c = 0;
    }
  }
  else
  {
    tempparm1 = find_sqr_mat(M, row, col, N-1);
    tempparm2 = find_sqr_mat(M, row+1, col, N-1);
    tempparm3 = find_sqr_mat(M, row, col+1, N-1);
    tempparm4 = find_sqr_mat(M, row+1, col+1, N-1);
    if((tempparm1 &#038;&#038; tempparm2 &#038;&#038; tempparm3 &#038;&#038; tempparm4) &#038;&#038;
       (tempparm1-&#062;n == tempparm2-&#062;n) &#038;&#038;
       (tempparm2-&#062;n == tempparm3-&#062;n) &#038;&#038;
       (tempparm3-&#062;n == tempparm4-&#062;n) &#038;&#038;
       (tempparm4-&#062;n == N-1))
    {
        tempparm-&#062;n = N;
        tempparm-&#062;r = row;
        tempparm-&#062;c = col;

        if (sub_mat.n &#060; N)
        {
            sub_mat.n = N;
            sub_mat.r = row;
            sub_mat.c = col;
        }
        free(tempparm1);
        free(tempparm2);
        free(tempparm3);
        free(tempparm4);

        return tempparm;
    }
    else
    {
        return NULL;
    }
    free(tempparm1);
    free(tempparm2);
    free(tempparm3);
    free(tempparm4);
  }
  return tempparm;
}]]></description>
		<content:encoded><![CDATA[<p>typedef struct mat<br />
{<br />
    int n, r, c;<br />
}matParm;</p>
<p>matParm sub_mat;    // Global Variable<br />
/* Call from main function */</p>
<p>    if( row &gt; col)<br />
        for (i = 0; i  row)<br />
        for (i = 0; i &lt;  col &#8211; row ; i++)<br />
            find_sqr_mat (matrix, 0, i, row);<br />
    else<br />
        find_sqr_mat (matrix, 0, 0, col);<br />
/* Print the out put matrix */</p>
<p>printf(&quot;n Largest Sub Square Matrixn&quot;);<br />
printf(&quot;Row = %d  Col = %d  N = %dn&quot;,sub_mat.r, sub_mat.c, sub_mat.n);<br />
for (i = sub_mat.r; i &lt; sub_mat.r + sub_mat.n; i++)<br />
{<br />
    printf(&quot;nn&quot;);<br />
    for (j = sub_mat.c; j n = N;<br />
        tempparm-&gt;r = row;<br />
        tempparm-&gt;c = col;<br />
    }<br />
    else<br />
    {<br />
        tempparm-&gt;n = 0;<br />
        tempparm-&gt;r = 0;<br />
        tempparm-&gt;c = 0;<br />
    }<br />
  }<br />
  else<br />
  {<br />
    tempparm1 = find_sqr_mat(M, row, col, N-1);<br />
    tempparm2 = find_sqr_mat(M, row+1, col, N-1);<br />
    tempparm3 = find_sqr_mat(M, row, col+1, N-1);<br />
    tempparm4 = find_sqr_mat(M, row+1, col+1, N-1);<br />
    if((tempparm1 &amp;&amp; tempparm2 &amp;&amp; tempparm3 &amp;&amp; tempparm4) &amp;&amp;<br />
       (tempparm1-&gt;n == tempparm2-&gt;n) &amp;&amp;<br />
       (tempparm2-&gt;n == tempparm3-&gt;n) &amp;&amp;<br />
       (tempparm3-&gt;n == tempparm4-&gt;n) &amp;&amp;<br />
       (tempparm4-&gt;n == N-1))<br />
    {<br />
        tempparm-&gt;n = N;<br />
        tempparm-&gt;r = row;<br />
        tempparm-&gt;c = col;</p>
<p>        if (sub_mat.n &lt; N)<br />
        {<br />
            sub_mat.n = N;<br />
            sub_mat.r = row;<br />
            sub_mat.c = col;<br />
        }<br />
        free(tempparm1);<br />
        free(tempparm2);<br />
        free(tempparm3);<br />
        free(tempparm4);</p>
<p>        return tempparm;<br />
    }<br />
    else<br />
    {<br />
        return NULL;<br />
    }<br />
    free(tempparm1);<br />
    free(tempparm2);<br />
    free(tempparm3);<br />
    free(tempparm4);<br />
  }<br />
  return tempparm;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Max</title>
		<link>http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/#comment-34445</link>
		<dc:creator><![CDATA[Max]]></dc:creator>
		<pubDate>Tue, 08 Apr 2014 01:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6257#comment-34445</guid>
		<description><![CDATA[Original:

1111
1110
1110
0111


Sum:


1110
1220
2230
0121


Explanation:


I am indexing from 0 for the sake of this explanation, with the left as the x-axis zero and the top as the y-axis zero. 


Consider Sum[1][1]. We know that this space itself must be a sub-square of at least size one if Original[1][1] has a 1 there. Likewise, in Original[0][0], Original[0][1], and Original[1][0], we also know there to exist sub-squares of at least size one. When considering Sum[1][1], we are trying to determine the largest sub-square which exists there. We know that its neighbor upward, its neighbor to the left, and its up-left neighbor each contain a sub-square of size one. Since there is also a sub-square of size one at Sum[1][1], we know that there is a sub-square of size four across those four spaces.


The same logic applies to [2][2]. We know there is a sub-square of size 2 above it ([1][0], [2][0], [1][1], [2][1]), to the left ([0][1], [0][2], [1][1], [1][2]), and to the upper-left ([0][0], [0][1], [1][0], [1][1]), as well as a sub-square of size one at [2][2], meaning that the largest sub-square to the upper-left starting at [2][2] is of size 3.


For the space [3][2], it is clear why we use min. We see that [3][2] is occupied by a 1. The space above it shows us there is a sub-square of size 3. However, Sum[3][2] only contains the value 2. This is because the value to the left of Sum[3][2] indicates a sub-square of size 1. Given this information, we know that the maximum sub-square located at [3][2] is size 2, since one of its neighbors is only of size 1 which would prohibit a square larger than 2.


I do hope this makes sense. We only need to expand the square one row/column at a time, so proving the existence of sub-squares within the region already traveled allows us to do the smallest amount of work while obtaining a correct answer.]]></description>
		<content:encoded><![CDATA[<p>Original:</p>
<p>1111<br />
1110<br />
1110<br />
0111</p>
<p>Sum:</p>
<p>1110<br />
1220<br />
2230<br />
0121</p>
<p>Explanation:</p>
<p>I am indexing from 0 for the sake of this explanation, with the left as the x-axis zero and the top as the y-axis zero. </p>
<p>Consider Sum[1][1]. We know that this space itself must be a sub-square of at least size one if Original[1][1] has a 1 there. Likewise, in Original[0][0], Original[0][1], and Original[1][0], we also know there to exist sub-squares of at least size one. When considering Sum[1][1], we are trying to determine the largest sub-square which exists there. We know that its neighbor upward, its neighbor to the left, and its up-left neighbor each contain a sub-square of size one. Since there is also a sub-square of size one at Sum[1][1], we know that there is a sub-square of size four across those four spaces.</p>
<p>The same logic applies to [2][2]. We know there is a sub-square of size 2 above it ([1][0], [2][0], [1][1], [2][1]), to the left ([0][1], [0][2], [1][1], [1][2]), and to the upper-left ([0][0], [0][1], [1][0], [1][1]), as well as a sub-square of size one at [2][2], meaning that the largest sub-square to the upper-left starting at [2][2] is of size 3.</p>
<p>For the space [3][2], it is clear why we use min. We see that [3][2] is occupied by a 1. The space above it shows us there is a sub-square of size 3. However, Sum[3][2] only contains the value 2. This is because the value to the left of Sum[3][2] indicates a sub-square of size 1. Given this information, we know that the maximum sub-square located at [3][2] is size 2, since one of its neighbors is only of size 1 which would prohibit a square larger than 2.</p>
<p>I do hope this makes sense. We only need to expand the square one row/column at a time, so proving the existence of sub-squares within the region already traveled allows us to do the smallest amount of work while obtaining a correct answer.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:31 -->

<!-- Compression = gzip -->