<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Sort a linked list of 0s, 1s and 2s</title>
	<atom:link href="http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Saurabh</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-40166</link>
		<dc:creator><![CDATA[Saurabh]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 14:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-40166</guid>
		<description><![CDATA[We can use the idea of Dutch National Flag Algorithm.]]></description>
		<content:encoded><![CDATA[<p>We can use the idea of Dutch National Flag Algorithm.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANUJ GARG</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-39357</link>
		<dc:creator><![CDATA[ANUJ GARG]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 14:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-39357</guid>
		<description><![CDATA[time complexity O(2n) n for counting 0,1,2 and n for inserting 0,1,2.]]></description>
		<content:encoded><![CDATA[<p>time complexity O(2n) n for counting 0,1,2 and n for inserting 0,1,2.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: guest</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-38055</link>
		<dc:creator><![CDATA[guest]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 05:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-38055</guid>
		<description><![CDATA[How can u decrement the end pointer? Its a singly linked list]]></description>
		<content:encoded><![CDATA[<p>How can u decrement the end pointer? Its a singly linked list</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arvind kumar</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-37917</link>
		<dc:creator><![CDATA[Arvind kumar]]></dc:creator>
		<pubDate>Sun, 08 Jun 2014 12:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-37917</guid>
		<description><![CDATA[node *sortList( node *head )

{

    node *ptr0,*ptr1,*ptr2;

    ptr0=ptr1=ptr2=NULL;

    node *ptrh0,*ptrh1,*ptrh2;

    ptrh0=ptrh1=ptrh2=NULL;

    if(head==NULL)

        return  NULL;

    while(head !=NULL)

    {

        if(head-&#062;data==0)

        {

            if(ptrh0==NULL)

                ptrh0=ptr0=head;

            else

            {

                ptr0-&#062;next=head;

                ptr0=head;

            }

        }

        if(head-&#062;data==1)

        {

            if(ptrh1==NULL)

                ptrh1=ptr1=head;

            else

            {

                ptr1-&#062;next=head;

                ptr1=head;

            }

        }

        if(head-&#062;data==2)

        {

            if(ptrh2==NULL)

                ptrh2=ptr2=head;

            else

            {

                ptr2-&#062;next=head;

                ptr2=head;

            }

        }

        head =head-&#062;next;

    }

    ptr0-&#062;next=ptrh1;

    ptr1-&#062;next=ptrh2;

    ptr2-&#062;next=NULL;

   return ptrh0;

}]]></description>
		<content:encoded><![CDATA[<p>node *sortList( node *head )</p>
<p>{</p>
<p>    node *ptr0,*ptr1,*ptr2;</p>
<p>    ptr0=ptr1=ptr2=NULL;</p>
<p>    node *ptrh0,*ptrh1,*ptrh2;</p>
<p>    ptrh0=ptrh1=ptrh2=NULL;</p>
<p>    if(head==NULL)</p>
<p>        return  NULL;</p>
<p>    while(head !=NULL)</p>
<p>    {</p>
<p>        if(head-&gt;data==0)</p>
<p>        {</p>
<p>            if(ptrh0==NULL)</p>
<p>                ptrh0=ptr0=head;</p>
<p>            else</p>
<p>            {</p>
<p>                ptr0-&gt;next=head;</p>
<p>                ptr0=head;</p>
<p>            }</p>
<p>        }</p>
<p>        if(head-&gt;data==1)</p>
<p>        {</p>
<p>            if(ptrh1==NULL)</p>
<p>                ptrh1=ptr1=head;</p>
<p>            else</p>
<p>            {</p>
<p>                ptr1-&gt;next=head;</p>
<p>                ptr1=head;</p>
<p>            }</p>
<p>        }</p>
<p>        if(head-&gt;data==2)</p>
<p>        {</p>
<p>            if(ptrh2==NULL)</p>
<p>                ptrh2=ptr2=head;</p>
<p>            else</p>
<p>            {</p>
<p>                ptr2-&gt;next=head;</p>
<p>                ptr2=head;</p>
<p>            }</p>
<p>        }</p>
<p>        head =head-&gt;next;</p>
<p>    }</p>
<p>    ptr0-&gt;next=ptrh1;</p>
<p>    ptr1-&gt;next=ptrh2;</p>
<p>    ptr2-&gt;next=NULL;</p>
<p>   return ptrh0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-37617</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 16:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-37617</guid>
		<description><![CDATA[yup]]></description>
		<content:encoded><![CDATA[<p>yup</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-37530</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 17:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-37530</guid>
		<description><![CDATA[what if we are not supposed to use extra space or not allowed  to modify the data in the nodes ..? then we have to move 2&#039;s nodes to the end and 0&#039;s nodes to the front ...ryt??]]></description>
		<content:encoded><![CDATA[<p>what if we are not supposed to use extra space or not allowed  to modify the data in the nodes ..? then we have to move 2&#8217;s nodes to the end and 0&#8217;s nodes to the front &#8230;ryt??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: theCuriosityEnthusiast</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-37063</link>
		<dc:creator><![CDATA[theCuriosityEnthusiast]]></dc:creator>
		<pubDate>Fri, 30 May 2014 11:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-37063</guid>
		<description><![CDATA[Here&#039;s a slightly modified approach:
1. Use 2 pointers to indicate start of list of 1&#039;s and 2&#039;s and 2 markers for it.
2. Start traversing, here we check the value of the next field in pointers.
3. If value is 0, put it at the start, if value is 1 set the above pointer and mark it as set and move ahead, if value is 2, set the the above pointer for 2 before the node containing 2. This is primarily used for the case when the first 1 is encountered after a long sequence of 2&#039;s.
3. b. When the first 1 is found, is pointer for 2 is not set, then just set the pointer for 1, else put this 1 before the first 2 using the preset pointer for 2.
4. Proceed similar to (3): if 0 is found, put it at the start, if 1 is found put it after the set pointer and if 2 is found move ahead.
5. Traverse till NULL.
Care should be taken to handle the head node appropriately.
This method doesn&#039;t use stack so no extra space, it uses less pointers, slight optimization and traverses only once.
If I&#039;m missing something let me know.]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s a slightly modified approach:<br />
1. Use 2 pointers to indicate start of list of 1&#8217;s and 2&#8217;s and 2 markers for it.<br />
2. Start traversing, here we check the value of the next field in pointers.<br />
3. If value is 0, put it at the start, if value is 1 set the above pointer and mark it as set and move ahead, if value is 2, set the the above pointer for 2 before the node containing 2. This is primarily used for the case when the first 1 is encountered after a long sequence of 2&#8217;s.<br />
3. b. When the first 1 is found, is pointer for 2 is not set, then just set the pointer for 1, else put this 1 before the first 2 using the preset pointer for 2.<br />
4. Proceed similar to (3): if 0 is found, put it at the start, if 1 is found put it after the set pointer and if 2 is found move ahead.<br />
5. Traverse till NULL.<br />
Care should be taken to handle the head node appropriately.<br />
This method doesn&#8217;t use stack so no extra space, it uses less pointers, slight optimization and traverses only once.<br />
If I&#8217;m missing something let me know.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: zoom</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-31243</link>
		<dc:creator><![CDATA[zoom]]></dc:creator>
		<pubDate>Sat, 04 Jan 2014 11:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-31243</guid>
		<description><![CDATA[simpler solution is to keep three pointers.. 
zeros, ones and twos.
keep removing nodes and adding them to the appropriate linked lists..
and just combine them at the end.. you are done :)]]></description>
		<content:encoded><![CDATA[<p>simpler solution is to keep three pointers..<br />
zeros, ones and twos.<br />
keep removing nodes and adding them to the appropriate linked lists..<br />
and just combine them at the end.. you are done ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eshwar</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-29132</link>
		<dc:creator><![CDATA[Eshwar]]></dc:creator>
		<pubDate>Sun, 20 Oct 2013 18:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-29132</guid>
		<description><![CDATA[Hi All 

Please check the following solution. Also this logic will traverse only once 

		struct node* sort(struct node *head)

		{

			struct node *zero_list,*one_list,*two_list;

			zero_list=one_list=two_list=NULL;

			while(head != NULL)

			{

				if(head-&#062;data == 0){

					if(zero_list == NULL)

						zero_list = head;

					else

						zero_list-&#062;next = head;

				}

				else if(head-&#062;data == 1){

					if(one_list == NULL)

						one_list = head;

					else

						one_list-&#062;next = head;

				}

				else if (head-&#062;data == 2){

					if(two_list == NULL)

						two_list = head;

					else

						two_list-&#062;next = head;

				}

				head = head-&#062;next;

			}

			zero_list-&#062;next = one_list;

			one_list-&#062;next = two_list;

			two_list-&#062;next = NULL;

			head = zero_list;

			return head;

		}]]></description>
		<content:encoded><![CDATA[<p>Hi All </p>
<p>Please check the following solution. Also this logic will traverse only once </p>
<p>		struct node* sort(struct node *head)</p>
<p>		{</p>
<p>			struct node *zero_list,*one_list,*two_list;</p>
<p>			zero_list=one_list=two_list=NULL;</p>
<p>			while(head != NULL)</p>
<p>			{</p>
<p>				if(head-&gt;data == 0){</p>
<p>					if(zero_list == NULL)</p>
<p>						zero_list = head;</p>
<p>					else</p>
<p>						zero_list-&gt;next = head;</p>
<p>				}</p>
<p>				else if(head-&gt;data == 1){</p>
<p>					if(one_list == NULL)</p>
<p>						one_list = head;</p>
<p>					else</p>
<p>						one_list-&gt;next = head;</p>
<p>				}</p>
<p>				else if (head-&gt;data == 2){</p>
<p>					if(two_list == NULL)</p>
<p>						two_list = head;</p>
<p>					else</p>
<p>						two_list-&gt;next = head;</p>
<p>				}</p>
<p>				head = head-&gt;next;</p>
<p>			}</p>
<p>			zero_list-&gt;next = one_list;</p>
<p>			one_list-&gt;next = two_list;</p>
<p>			two_list-&gt;next = NULL;</p>
<p>			head = zero_list;</p>
<p>			return head;</p>
<p>		}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: progs</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-28225</link>
		<dc:creator><![CDATA[progs]]></dc:creator>
		<pubDate>Sun, 29 Sep 2013 09:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-28225</guid>
		<description><![CDATA[hey guys we can use bucket sort 
Create 3 bucket as 0,1,2
than just travers Linked List  and put it into bucket then connect Buckets :)]]></description>
		<content:encoded><![CDATA[<p>hey guys we can use bucket sort<br />
Create 3 bucket as 0,1,2<br />
than just travers Linked List  and put it into bucket then connect Buckets ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Harshit Gupta</title>
		<link>http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/#comment-27405</link>
		<dc:creator><![CDATA[Harshit Gupta]]></dc:creator>
		<pubDate>Fri, 06 Sep 2013 22:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28359#comment-27405</guid>
		<description><![CDATA[if we are not allowed to change data of nodes then we have to manipulate linklist.


Other algo-
1. traverse link list.
2.if 0 is found push it in start of link list.
3.if 1 is found skip it.
4.if 2 is found push it on another head pointer and also delete it from original list.we cant push it to last bcoz it will create a infinite loop.
5. when temp reaches to null . then temp-&#062;next=head2;

[sourcecode language=&quot;C#&quot;][/sourcecode]
/*
#include
#include
#include

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

void push (struct node** head, int data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&#062;data  = data;

    /* link the old list off the new node */
    new_node-&#062;next = *head;

    /* move the head to point to the new node */
    *head    = new_node;
}


void printList(struct node *node)
{
    while (node != NULL)
    {
        printf(&quot;%d  &quot;, node-&#062;data);
        node = node-&#062;next;
    }
    printf(&quot;n&quot;);
}


struct node * sortlist(struct node * head,struct node * head2)
{



    struct node *cur = head;
    struct node *temp = NULL;
    struct node *prev = NULL;



    //skipping sorted part
    while(cur-&#062;data==0 &#038;&#038; cur-&#062;next != NULL)
    {
        prev=cur;
        cur=cur-&#062;next;
    }


    while(cur != NULL)
    {




            temp=cur-&#062;next;


            if(cur-&#062;data == 0)
            {
                if(prev == NULL)
                {
                prev=cur; cur=temp;
                }
                else
                {
                prev-&#062;next=temp;
                cur-&#062;next=head;
                head=cur;
                cur=temp;
                }

            }

            else if(cur-&#062;data == 2)
            {
                if(prev == NULL)
                {head=temp;}
                else
                {prev-&#062;next=temp;}


                if(head2==NULL)
                {head2=cur;
                cur-&#062;next=NULL;}
                else
                {cur-&#062;next=head2;
                head2=cur;}

                cur=temp;

            }
            else
            {
                prev=cur;
                cur=temp;
            }


    }

    if(prev == NULL )
    {head=head2;}
    else
    prev-&#062;next=head2;
    printf(&quot;head  n&quot;);
    printList(head);
    printf(&quot;head 2 n&quot;);
    printList(head2);
    return head;

}

int main(void)
{
    struct node *head = NULL;
   // struct node *head0 = NULL;
    struct node *head2 = NULL;
    push(&#038;head, 0);
    push(&#038;head, 2);
    push(&#038;head, 0);
    push(&#038;head, 2);
    push(&#038;head, 0);
    push(&#038;head, 2);
  //  push(&#038;head, 2);
   // push(&#038;head, 2);
   // push(&#038;head, 1);

    printf(&quot;Linked List Before Sortingn&quot;);
    printList(head);

    head=sortlist(head,head2);
    printList(head);

    getch();
    return 0;
}
*/]]></description>
		<content:encoded><![CDATA[<p>if we are not allowed to change data of nodes then we have to manipulate linklist.</p>
<p>Other algo-<br />
1. traverse link list.<br />
2.if 0 is found push it in start of link list.<br />
3.if 1 is found skip it.<br />
4.if 2 is found push it on another head pointer and also delete it from original list.we cant push it to last bcoz it will create a infinite loop.<br />
5. when temp reaches to null . then temp-&gt;next=head2;</p>
<p>/*<br />
#include<br />
#include<br />
#include</p>
<p>/* Link list node */<br />
struct node<br />
{<br />
    int data;<br />
    struct node* next;<br />
};</p>
<p>void push (struct node** head, int data)<br />
{<br />
    /* allocate node */<br />
    struct node* new_node =<br />
        (struct node*) malloc(sizeof(struct node));</p>
<p>    /* put in the data  */<br />
    new_node-&gt;data  = data;</p>
<p>    /* link the old list off the new node */<br />
    new_node-&gt;next = *head;</p>
<p>    /* move the head to point to the new node */<br />
    *head    = new_node;<br />
}</p>
<p>void printList(struct node *node)<br />
{<br />
    while (node != NULL)<br />
    {<br />
        printf(&#8220;%d  &#8220;, node-&gt;data);<br />
        node = node-&gt;next;<br />
    }<br />
    printf(&#8220;n&#8221;);<br />
}</p>
<p>struct node * sortlist(struct node * head,struct node * head2)<br />
{</p>
<p>    struct node *cur = head;<br />
    struct node *temp = NULL;<br />
    struct node *prev = NULL;</p>
<p>    //skipping sorted part<br />
    while(cur-&gt;data==0 &amp;&amp; cur-&gt;next != NULL)<br />
    {<br />
        prev=cur;<br />
        cur=cur-&gt;next;<br />
    }</p>
<p>    while(cur != NULL)<br />
    {</p>
<p>            temp=cur-&gt;next;</p>
<p>            if(cur-&gt;data == 0)<br />
            {<br />
                if(prev == NULL)<br />
                {<br />
                prev=cur; cur=temp;<br />
                }<br />
                else<br />
                {<br />
                prev-&gt;next=temp;<br />
                cur-&gt;next=head;<br />
                head=cur;<br />
                cur=temp;<br />
                }</p>
<p>            }</p>
<p>            else if(cur-&gt;data == 2)<br />
            {<br />
                if(prev == NULL)<br />
                {head=temp;}<br />
                else<br />
                {prev-&gt;next=temp;}</p>
<p>                if(head2==NULL)<br />
                {head2=cur;<br />
                cur-&gt;next=NULL;}<br />
                else<br />
                {cur-&gt;next=head2;<br />
                head2=cur;}</p>
<p>                cur=temp;</p>
<p>            }<br />
            else<br />
            {<br />
                prev=cur;<br />
                cur=temp;<br />
            }</p>
<p>    }</p>
<p>    if(prev == NULL )<br />
    {head=head2;}<br />
    else<br />
    prev-&gt;next=head2;<br />
    printf(&#8220;head  n&#8221;);<br />
    printList(head);<br />
    printf(&#8220;head 2 n&#8221;);<br />
    printList(head2);<br />
    return head;</p>
<p>}</p>
<p>int main(void)<br />
{<br />
    struct node *head = NULL;<br />
   // struct node *head0 = NULL;<br />
    struct node *head2 = NULL;<br />
    push(&amp;head, 0);<br />
    push(&amp;head, 2);<br />
    push(&amp;head, 0);<br />
    push(&amp;head, 2);<br />
    push(&amp;head, 0);<br />
    push(&amp;head, 2);<br />
  //  push(&amp;head, 2);<br />
   // push(&amp;head, 2);<br />
   // push(&amp;head, 1);</p>
<p>    printf(&#8220;Linked List Before Sortingn&#8221;);<br />
    printList(head);</p>
<p>    head=sortlist(head,head2);<br />
    printList(head);</p>
<p>    getch();<br />
    return 0;<br />
}<br />
*/</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:30:18 -->

<!-- Compression = gzip -->