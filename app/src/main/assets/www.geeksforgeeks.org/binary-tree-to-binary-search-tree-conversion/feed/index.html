<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Binary Tree to Binary Search Tree Conversion</title>
	<atom:link href="http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ganesh</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-38125</link>
		<dc:creator><![CDATA[ganesh]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 16:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-38125</guid>
		<description><![CDATA[In c we cant create dynamic array using new operator right???]]></description>
		<content:encoded><![CDATA[<p>In c we cant create dynamic array using new operator right???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: RACHIT SAXENA</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-38057</link>
		<dc:creator><![CDATA[RACHIT SAXENA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 06:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-38057</guid>
		<description><![CDATA[what about O(log n) space compexity solution
???]]></description>
		<content:encoded><![CDATA[<p>what about O(log n) space compexity solution<br />
???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Deepanshu Arora</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-37871</link>
		<dc:creator><![CDATA[Deepanshu Arora]]></dc:creator>
		<pubDate>Sat, 07 Jun 2014 20:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-37871</guid>
		<description><![CDATA[It will be really helpful if you would add a documentation to your solution]]></description>
		<content:encoded><![CDATA[<p>It will be really helpful if you would add a documentation to your solution</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vikas Rajoria</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-37141</link>
		<dc:creator><![CDATA[Vikas Rajoria]]></dc:creator>
		<pubDate>Sat, 31 May 2014 17:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-37141</guid>
		<description><![CDATA[How is quick sort having n^2 complexity, by all practical needs it yields nlogn . n^2 is worst case for quick sort, we hardly run into such cases.]]></description>
		<content:encoded><![CDATA[<p>How is quick sort having n^2 complexity, by all practical needs it yields nlogn . n^2 is worst case for quick sort, we hardly run into such cases.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Harry</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-34444</link>
		<dc:creator><![CDATA[Harry]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 22:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-34444</guid>
		<description><![CDATA[It used by the c function &quot;qsort&quot;, refer to http://www.cplusplus.com/reference/cstdlib/qsort/]]></description>
		<content:encoded><![CDATA[<p>It used by the c function &#8220;qsort&#8221;, refer to <a href="http://www.cplusplus.com/reference/cstdlib/qsort/" rel="nofollow">http://www.cplusplus.com/reference/cstdlib/qsort/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sudarshan Kj</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-33035</link>
		<dc:creator><![CDATA[Sudarshan Kj]]></dc:creator>
		<pubDate>Thu, 27 Feb 2014 07:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-33035</guid>
		<description><![CDATA[what is the use of compare fuction there?
anyone pls tell me]]></description>
		<content:encoded><![CDATA[<p>what is the use of compare fuction there?<br />
anyone pls tell me</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-29160</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Mon, 21 Oct 2013 07:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-29160</guid>
		<description><![CDATA[O(n^2) with space O(1)

&lt;code&gt;

/* A program to convert Binary Tree to Binary Search Tree */

#include

#include

 

/* A binary tree node structure */

struct node

{

    int data;

    struct node *left;

    struct node *right;

};

void swap(struct node *root1, struct node *root2)

{

	int c;

	c=root1-&#062;data;

	root1-&#062;data=root2-&#062;data;

	root2-&#062;data=c;

}

/*int isBst(struct node *root)

{

	if(root-&#062;left &#038;&#038; root-&#062;right)

	return isBst(root-&#062;left)data &#038;&#038; root-&#062;dataright);

	if(!root-&#062;left &#038;&#038; !root-&#062;right)

	return root-&#062;data;

	if(!root-&#062;left)

	return root-&#062;data&#062;=isBst(root-&#062;right);

	if(!root-&#062;right)

	return isBst(root-&#062;left)data;

}

*/

void converttoBSTutil(struct node *root)

{

	if(root)

	{

		converttoBSTutil(root-&#062;left);

		converttoBSTutil(root-&#062;right);

		if(root-&#062;left)

		{

			if(root-&#062;data left-&#062;data)

			{

				swap(root, root-&#062;left);

		    }

		  

		}

		

		if(root-&#062;right)

		{

			if(root-&#062;data &#062; root-&#062;right-&#062;data)

			{

				swap(root, root-&#062;right);

			}

		}

	}

}

void converttoBST(struct node *root,struct node *root2)

{

  if(root)

  {

  	converttoBST(root-&#062;left,root2);

  	converttoBSTutil(root2);

  	converttoBST(root-&#062;right,root);

  	

  }

}

struct node* newNode (int data)

{

    struct node *temp = (struct node *)malloc(sizeof(struct node));

    temp-&#062;data = data;

    temp-&#062;left = NULL;

    temp-&#062;right = NULL;

    return temp;

}

 

void printInorder (struct node* node)

{

    if (node == NULL)

        return;

 

    /* first recur on left child */

    printInorder (node-&#062;left);

 

    /* then print the data of node */

    printf(&quot;%d &quot;, node-&#062;data);

 

    /* now recur on right child */

    printInorder (node-&#062;right);

}

 

/* Driver function to test above functions */

int main()

{

    struct node *root = NULL;

 

    /* Constructing tree given in the above figure

          10

         /  

        30   15

       /      

      20       5   */

    root = newNode(10);

    root-&#062;left = newNode(30);

    root-&#062;right = newNode(15);

    root-&#062;left-&#062;left = newNode(20);

    root-&#062;right-&#062;right = newNode(5);

 

    // convert Binary Tree to BST

    converttoBST(root,root);

 

    printf(&quot;Following is Inorder Traversal of the converted BST: n&quot;);

    printInorder (root);

 

    return 0;

}

&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>O(n^2) with space O(1)</p>
<p><code></p>
<p>/* A program to convert Binary Tree to Binary Search Tree */</p>
<p>#include</p>
<p>#include</p>
<p>/* A binary tree node structure */</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node *left;</p>
<p>    struct node *right;</p>
<p>};</p>
<p>void swap(struct node *root1, struct node *root2)</p>
<p>{</p>
<p>	int c;</p>
<p>	c=root1-&gt;data;</p>
<p>	root1-&gt;data=root2-&gt;data;</p>
<p>	root2-&gt;data=c;</p>
<p>}</p>
<p>/*int isBst(struct node *root)</p>
<p>{</p>
<p>	if(root-&gt;left &amp;&amp; root-&gt;right)</p>
<p>	return isBst(root-&gt;left)data &amp;&amp; root-&gt;dataright);</p>
<p>	if(!root-&gt;left &amp;&amp; !root-&gt;right)</p>
<p>	return root-&gt;data;</p>
<p>	if(!root-&gt;left)</p>
<p>	return root-&gt;data&gt;=isBst(root-&gt;right);</p>
<p>	if(!root-&gt;right)</p>
<p>	return isBst(root-&gt;left)data;</p>
<p>}</p>
<p>*/</p>
<p>void converttoBSTutil(struct node *root)</p>
<p>{</p>
<p>	if(root)</p>
<p>	{</p>
<p>		converttoBSTutil(root-&gt;left);</p>
<p>		converttoBSTutil(root-&gt;right);</p>
<p>		if(root-&gt;left)</p>
<p>		{</p>
<p>			if(root-&gt;data left-&gt;data)</p>
<p>			{</p>
<p>				swap(root, root-&gt;left);</p>
<p>		    }</p>
<p>		}</p>
<p>		if(root-&gt;right)</p>
<p>		{</p>
<p>			if(root-&gt;data &gt; root-&gt;right-&gt;data)</p>
<p>			{</p>
<p>				swap(root, root-&gt;right);</p>
<p>			}</p>
<p>		}</p>
<p>	}</p>
<p>}</p>
<p>void converttoBST(struct node *root,struct node *root2)</p>
<p>{</p>
<p>  if(root)</p>
<p>  {</p>
<p>  	converttoBST(root-&gt;left,root2);</p>
<p>  	converttoBSTutil(root2);</p>
<p>  	converttoBST(root-&gt;right,root);</p>
<p>  }</p>
<p>}</p>
<p>struct node* newNode (int data)</p>
<p>{</p>
<p>    struct node *temp = (struct node *)malloc(sizeof(struct node));</p>
<p>    temp-&gt;data = data;</p>
<p>    temp-&gt;left = NULL;</p>
<p>    temp-&gt;right = NULL;</p>
<p>    return temp;</p>
<p>}</p>
<p>void printInorder (struct node* node)</p>
<p>{</p>
<p>    if (node == NULL)</p>
<p>        return;</p>
<p>    /* first recur on left child */</p>
<p>    printInorder (node-&gt;left);</p>
<p>    /* then print the data of node */</p>
<p>    printf("%d ", node-&gt;data);</p>
<p>    /* now recur on right child */</p>
<p>    printInorder (node-&gt;right);</p>
<p>}</p>
<p>/* Driver function to test above functions */</p>
<p>int main()</p>
<p>{</p>
<p>    struct node *root = NULL;</p>
<p>    /* Constructing tree given in the above figure</p>
<p>          10</p>
<p>         /  </p>
<p>        30   15</p>
<p>       /      </p>
<p>      20       5   */</p>
<p>    root = newNode(10);</p>
<p>    root-&gt;left = newNode(30);</p>
<p>    root-&gt;right = newNode(15);</p>
<p>    root-&gt;left-&gt;left = newNode(20);</p>
<p>    root-&gt;right-&gt;right = newNode(5);</p>
<p>    // convert Binary Tree to BST</p>
<p>    converttoBST(root,root);</p>
<p>    printf("Following is Inorder Traversal of the converted BST: n");</p>
<p>    printInorder (root);</p>
<p>    return 0;</p>
<p>}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vinodhini</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-27960</link>
		<dc:creator><![CDATA[Vinodhini]]></dc:creator>
		<pubDate>Sat, 21 Sep 2013 08:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-27960</guid>
		<description><![CDATA[could you guys post the O(height of tree) solution?]]></description>
		<content:encoded><![CDATA[<p>could you guys post the O(height of tree) solution?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Bgl</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-25093</link>
		<dc:creator><![CDATA[Amit Bgl]]></dc:creator>
		<pubDate>Sat, 17 Aug 2013 03:33:33 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-25093</guid>
		<description><![CDATA[wow code :D]]></description>
		<content:encoded><![CDATA[<p>wow code 😀</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-18391</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Mon, 20 May 2013 08:03:06 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-18391</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent 😀</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prakash_ntk</title>
		<link>http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/#comment-15126</link>
		<dc:creator><![CDATA[prakash_ntk]]></dc:creator>
		<pubDate>Sat, 09 Feb 2013 10:35:58 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=20174#comment-15126</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;

//Here is a solution for converting a Binary tree to BST without //using extra space.time complexity=o(n^2)


Convert_BST(node root, int cur_max)
{
	If(NULL==root)
		return ;
	Convert_BST(root-&#062;right, cur_max);
	node * max_node=find_next _max(root,cur_max);
	int temp=root-&#062;data;
	root-&#062;data=max_node-&#062;data;
	max_node-&#062;data=temp;
	cur_max= max_node-&#062;data;
	Convert_BST(root-&#062;left, cur_max);
}

node find_next_max(node root,int pre_max)
{
	static int max=0;//keep track ofcurrent max value
	static node *max_node;//keep track of cur maximum valued node.
	
	if(NULL==root)
		return 0;
	
	
	
	find_next_max(root-&#062;left,cur_max);
	find_next_max(root-&#062;right,cur_max);
	
	//if current node value is higher than max and less than previous max value, update
 	//the max_node pointer and max value
	if(root-&#062;data&#062;max &#038;&#038; root-&#062;data&#060;pre_max)
	{
		max_node=root;	
		max=root-&#062;data;
	}
	return max_node;
	

}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">

//Here is a solution for converting a Binary tree to BST without //using extra space.time complexity=o(n^2)


Convert_BST(node root, int cur_max)
{
	If(NULL==root)
		return ;
	Convert_BST(root-&gt;right, cur_max);
	node * max_node=find_next _max(root,cur_max);
	int temp=root-&gt;data;
	root-&gt;data=max_node-&gt;data;
	max_node-&gt;data=temp;
	cur_max= max_node-&gt;data;
	Convert_BST(root-&gt;left, cur_max);
}

node find_next_max(node root,int pre_max)
{
	static int max=0;//keep track ofcurrent max value
	static node *max_node;//keep track of cur maximum valued node.
	
	if(NULL==root)
		return 0;
	
	
	
	find_next_max(root-&gt;left,cur_max);
	find_next_max(root-&gt;right,cur_max);
	
	//if current node value is higher than max and less than previous max value, update
 	//the max_node pointer and max value
	if(root-&gt;data&gt;max &amp;&amp; root-&gt;data&lt;pre_max)
	{
		max_node=root;	
		max=root-&gt;data;
	}
	return max_node;
	

}
</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:06:50 -->

<!-- Compression = gzip -->