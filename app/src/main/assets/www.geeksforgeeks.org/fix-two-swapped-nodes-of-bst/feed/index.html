<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Two nodes of a BST are swapped, correct the BST</title>
	<atom:link href="http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AMIT JAMBOTKAR</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-39849</link>
		<dc:creator><![CDATA[AMIT JAMBOTKAR]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 07:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-39849</guid>
		<description><![CDATA[We can do this in easy way...

   Node firstValue=null, SecondValue=null ;

    void isBSTMethod2(Node root,int min,int max){

        if(root==null)

            return ;

        if(root.value.intValue()max){

            if(firstValue==null)

                firstValue=root;

            else

            SecondValue=root ;

        }

        if(firstValue!=null &#038;&#038; SecondValue!=null){

            //Swap the elements here

            E temp=firstValue.value;

            firstValue.value=SecondValue.value;

            SecondValue.value=temp;

            return;

        }

        isBSTMethod2(root.leftRef,min,root.value.intValue()-1) ;

        isBSTMethod2(root.rightRef,root.value.intValue()+1,max);

    }]]></description>
		<content:encoded><![CDATA[<p>We can do this in easy way&#8230;</p>
<p>   Node firstValue=null, SecondValue=null ;</p>
<p>    void isBSTMethod2(Node root,int min,int max){</p>
<p>        if(root==null)</p>
<p>            return ;</p>
<p>        if(root.value.intValue()max){</p>
<p>            if(firstValue==null)</p>
<p>                firstValue=root;</p>
<p>            else</p>
<p>            SecondValue=root ;</p>
<p>        }</p>
<p>        if(firstValue!=null &amp;&amp; SecondValue!=null){</p>
<p>            //Swap the elements here</p>
<p>            E temp=firstValue.value;</p>
<p>            firstValue.value=SecondValue.value;</p>
<p>            SecondValue.value=temp;</p>
<p>            return;</p>
<p>        }</p>
<p>        isBSTMethod2(root.leftRef,min,root.value.intValue()-1) ;</p>
<p>        isBSTMethod2(root.rightRef,root.value.intValue()+1,max);</p>
<p>    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-38598</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 18:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-38598</guid>
		<description><![CDATA[Can it be done this way also:


the problem is equivalent to swapping the two nodes, deleting the first node and reinserting it maintaining the heap property. This will take time in order of O(logn) . Will this approach work?]]></description>
		<content:encoded><![CDATA[<p>Can it be done this way also:</p>
<p>the problem is equivalent to swapping the two nodes, deleting the first node and reinserting it maintaining the heap property. This will take time in order of O(logn) . Will this approach work?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-35228</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 10:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-35228</guid>
		<description><![CDATA[@Geeksforgeeks:


Another simpler solution:

1.) use isBST routine to check whether the given tree is BST.

2.) if so, do not fix tree. 

3.) if not BST, initialise 2 pointers first and last to nodes to be fixed.

4.) fix BST and print.

C program for the above algorithm is as below:

// A program to check if a given binary tree is complete or not

#include 

#include 

#include 

#include 

struct node * first=NULL;

struct node * last=NULL;

 

/* A binary tree node has data, pointer to left child

   and a pointer to right child */

struct node

{

    int data;

    struct node* left;

    struct node* right;

};

void inorder(struct node *root)

{

	if(root == NULL)

		return;

		

	inorder(root-&#062;left);

	printf(&quot;%d, &quot;,root-&#062;data);

	inorder(root-&#062;right);

}

bool isBST(struct node *root, int min, int max)

{	

		

		if(root == NULL)

            return true;

       if (root-&#062;datadata&#062;max) 

       {

       		if(min!=INT_MIN &#038;&#038; root-&#062;datadata&#062;max)

       		{	

       			if(first == NULL)

        		{

        			first = root;

        			return false;

        		}

        		if(last == NULL)

        		{

        			last = root;

        			return false;

        		}

       		}

       		return false;

       	}

             

        bool l = isBST(root-&#062;left, min, root-&#062;data);

        bool r = isBST(root-&#062;right, root-&#062;data+1, max);

    	return l&#038;&#038;r;

	

}

 

void fixBST(struct node *root)

{

	 isBST(root,INT_MIN,INT_MAX)	;

	

	if(first!=NULL &#038;&#038; last!=NULL)

	{

		// swap

		int t = first-&#062;data;

		first-&#062;data = last-&#062;data;

		last-&#062;data = t;

	}

}

 

/* Helper function that allocates a new node with the

   given data and NULL left and right pointers. */

struct node* newNode(int data)

{

  struct node* node = (struct node*)

                       malloc(sizeof(struct node));

  node-&#062;data = data;

  node-&#062;left = NULL;

  node-&#062;right = NULL;

 

  return(node);

}

 

/* Driver program to test above functions*/

int main()

{

   /* Let us construct the following Binary Tree which

      is not a complete Binary Tree

            1

          /   

         2     3

        /      

       4   5     6

    */

 

  struct node *root  = newNode(10);

 root-&#062;left         = newNode(5);

  root-&#062;right        = newNode(8);

   root-&#062;left-&#062;left   = newNode(2);

   root-&#062;left-&#062;right  = newNode(20);

   // root-&#062;right-&#062;left = newNode(7);

  //    root-&#062;right-&#062;right = newNode(6);

 

 inorder(root);

 printf(&quot;n&quot;);

  fixBST(root);

  inorder(root);

  return 0;

}]]></description>
		<content:encoded><![CDATA[<p>@Geeksforgeeks:</p>
<p>Another simpler solution:</p>
<p>1.) use isBST routine to check whether the given tree is BST.</p>
<p>2.) if so, do not fix tree. </p>
<p>3.) if not BST, initialise 2 pointers first and last to nodes to be fixed.</p>
<p>4.) fix BST and print.</p>
<p>C program for the above algorithm is as below:</p>
<p>// A program to check if a given binary tree is complete or not</p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>struct node * first=NULL;</p>
<p>struct node * last=NULL;</p>
<p>/* A binary tree node has data, pointer to left child</p>
<p>   and a pointer to right child */</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node* left;</p>
<p>    struct node* right;</p>
<p>};</p>
<p>void inorder(struct node *root)</p>
<p>{</p>
<p>	if(root == NULL)</p>
<p>		return;</p>
<p>	inorder(root-&gt;left);</p>
<p>	printf(&#8220;%d, &#8220;,root-&gt;data);</p>
<p>	inorder(root-&gt;right);</p>
<p>}</p>
<p>bool isBST(struct node *root, int min, int max)</p>
<p>{	</p>
<p>		if(root == NULL)</p>
<p>            return true;</p>
<p>       if (root-&gt;datadata&gt;max) </p>
<p>       {</p>
<p>       		if(min!=INT_MIN &amp;&amp; root-&gt;datadata&gt;max)</p>
<p>       		{	</p>
<p>       			if(first == NULL)</p>
<p>        		{</p>
<p>        			first = root;</p>
<p>        			return false;</p>
<p>        		}</p>
<p>        		if(last == NULL)</p>
<p>        		{</p>
<p>        			last = root;</p>
<p>        			return false;</p>
<p>        		}</p>
<p>       		}</p>
<p>       		return false;</p>
<p>       	}</p>
<p>        bool l = isBST(root-&gt;left, min, root-&gt;data);</p>
<p>        bool r = isBST(root-&gt;right, root-&gt;data+1, max);</p>
<p>    	return l&amp;&amp;r;</p>
<p>}</p>
<p>void fixBST(struct node *root)</p>
<p>{</p>
<p>	 isBST(root,INT_MIN,INT_MAX)	;</p>
<p>	if(first!=NULL &amp;&amp; last!=NULL)</p>
<p>	{</p>
<p>		// swap</p>
<p>		int t = first-&gt;data;</p>
<p>		first-&gt;data = last-&gt;data;</p>
<p>		last-&gt;data = t;</p>
<p>	}</p>
<p>}</p>
<p>/* Helper function that allocates a new node with the</p>
<p>   given data and NULL left and right pointers. */</p>
<p>struct node* newNode(int data)</p>
<p>{</p>
<p>  struct node* node = (struct node*)</p>
<p>                       malloc(sizeof(struct node));</p>
<p>  node-&gt;data = data;</p>
<p>  node-&gt;left = NULL;</p>
<p>  node-&gt;right = NULL;</p>
<p>  return(node);</p>
<p>}</p>
<p>/* Driver program to test above functions*/</p>
<p>int main()</p>
<p>{</p>
<p>   /* Let us construct the following Binary Tree which</p>
<p>      is not a complete Binary Tree</p>
<p>            1</p>
<p>          /   </p>
<p>         2     3</p>
<p>        /      </p>
<p>       4   5     6</p>
<p>    */</p>
<p>  struct node *root  = newNode(10);</p>
<p> root-&gt;left         = newNode(5);</p>
<p>  root-&gt;right        = newNode(8);</p>
<p>   root-&gt;left-&gt;left   = newNode(2);</p>
<p>   root-&gt;left-&gt;right  = newNode(20);</p>
<p>   // root-&gt;right-&gt;left = newNode(7);</p>
<p>  //    root-&gt;right-&gt;right = newNode(6);</p>
<p> inorder(root);</p>
<p> printf(&#8220;n&#8221;);</p>
<p>  fixBST(root);</p>
<p>  inorder(root);</p>
<p>  return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-34500</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 11:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-34500</guid>
		<description><![CDATA[http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/

Refer to above question you will get the answer to your question...]]></description>
		<content:encoded><![CDATA[<p><a href="http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/" rel="nofollow">http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/</a></p>
<p>Refer to above question you will get the answer to your question&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abubakar</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-33370</link>
		<dc:creator><![CDATA[abubakar]]></dc:creator>
		<pubDate>Tue, 11 Mar 2014 07:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-33370</guid>
		<description><![CDATA[Input is wrong]]></description>
		<content:encoded><![CDATA[<p>Input is wrong</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abubakar</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-33369</link>
		<dc:creator><![CDATA[abubakar]]></dc:creator>
		<pubDate>Tue, 11 Mar 2014 06:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-33369</guid>
		<description><![CDATA[struct node *root = newNode(15);
    root-&#062;left        = newNode(6);
    root-&#062;right       = newNode(20);
    root-&#062;left-&#062;left  = newNode(10);
    root-&#062;left-&#062;right = newNode(7);
    root-&#062;left-&#062;left-&#062;left = newNode(1);
    root-&#062;left-&#062;left-&#062;right = newNode(3);
it does not work for this input]]></description>
		<content:encoded><![CDATA[<p>struct node *root = newNode(15);<br />
    root-&gt;left        = newNode(6);<br />
    root-&gt;right       = newNode(20);<br />
    root-&gt;left-&gt;left  = newNode(10);<br />
    root-&gt;left-&gt;right = newNode(7);<br />
    root-&gt;left-&gt;left-&gt;left = newNode(1);<br />
    root-&gt;left-&gt;left-&gt;right = newNode(3);<br />
it does not work for this input</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: M C S KRISHNA</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-30820</link>
		<dc:creator><![CDATA[M C S KRISHNA]]></dc:creator>
		<pubDate>Wed, 18 Dec 2013 11:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-30820</guid>
		<description><![CDATA[O(n) solution:

void CorrectBSTMine (struct node * root)
{
     static struct node *temp1 = NULL;
     static struct node *temp2 = NULL;
     int temp;

     if (root != NULL &#038;&#038; (temp1 == NULL &#124;&#124; temp2 == NULL) ) {
          if (root-&#062;left != NULL &#038;&#038; root-&#062;left-&#062;data &#062; root-&#062;data) {

     if (temp1 == NULL) {
     temp1 = root-&#062;left;
}
else {
     temp2 = root-&#062;left;
}
}

        if (root-&#062;right != NULL &#038;&#038; root-&#062;right-&#062;data data) {
if (temp1 == NULL) {
temp1 = root-&#062;right;
}
else {
temp2 = root-&#062;right;
}
}
CorrectBSTMine(root-&#062;left);
CorrectBSTMine(root-&#062;right);
}

if (temp1 != NULL &#124;&#124; temp2 != NULL) {
temp = temp1-&#062;data;
temp1-&#062;data = temp2-&#062;data;
temp2-&#062;data = temp;
}
}]]></description>
		<content:encoded><![CDATA[<p>O(n) solution:</p>
<p>void CorrectBSTMine (struct node * root)<br />
{<br />
     static struct node *temp1 = NULL;<br />
     static struct node *temp2 = NULL;<br />
     int temp;</p>
<p>     if (root != NULL &amp;&amp; (temp1 == NULL || temp2 == NULL) ) {<br />
          if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;data &gt; root-&gt;data) {</p>
<p>     if (temp1 == NULL) {<br />
     temp1 = root-&gt;left;<br />
}<br />
else {<br />
     temp2 = root-&gt;left;<br />
}<br />
}</p>
<p>        if (root-&gt;right != NULL &amp;&amp; root-&gt;right-&gt;data data) {<br />
if (temp1 == NULL) {<br />
temp1 = root-&gt;right;<br />
}<br />
else {<br />
temp2 = root-&gt;right;<br />
}<br />
}<br />
CorrectBSTMine(root-&gt;left);<br />
CorrectBSTMine(root-&gt;right);<br />
}</p>
<p>if (temp1 != NULL || temp2 != NULL) {<br />
temp = temp1-&gt;data;<br />
temp1-&gt;data = temp2-&gt;data;<br />
temp2-&gt;data = temp;<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rahul tibrewal</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-29607</link>
		<dc:creator><![CDATA[rahul tibrewal]]></dc:creator>
		<pubDate>Wed, 06 Nov 2013 16:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-29607</guid>
		<description><![CDATA[what if the first element of the inorder traversal, or the leftmost element has to be swapped, you have assumed that it is correct, am i wrong?]]></description>
		<content:encoded><![CDATA[<p>what if the first element of the inorder traversal, or the leftmost element has to be swapped, you have assumed that it is correct, am i wrong?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: mrn</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-27580</link>
		<dc:creator><![CDATA[mrn]]></dc:creator>
		<pubDate>Thu, 12 Sep 2013 16:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-27580</guid>
		<description><![CDATA[void correctSwappedTree(Node *root,Node *&#038;first,Node *&#038;second,Node *&#038;prev){

		if(root==NULL)

			return;

		correctSwappedTree(root-&#062;l,first,second,prev);

		if(prev!=NULL &#038;&#038; root-&#062;v v)

		{

			if(!first)

				{first=prev;second=root;}

			else

				second=root;

		}

		prev=root;		

		correctSwappedTree(root-&#062;r,first,second,prev);

}]]></description>
		<content:encoded><![CDATA[<p>void correctSwappedTree(Node *root,Node *&amp;first,Node *&amp;second,Node *&amp;prev){</p>
<p>		if(root==NULL)</p>
<p>			return;</p>
<p>		correctSwappedTree(root-&gt;l,first,second,prev);</p>
<p>		if(prev!=NULL &amp;&amp; root-&gt;v v)</p>
<p>		{</p>
<p>			if(!first)</p>
<p>				{first=prev;second=root;}</p>
<p>			else</p>
<p>				second=root;</p>
<p>		}</p>
<p>		prev=root;		</p>
<p>		correctSwappedTree(root-&gt;r,first,second,prev);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ubiquitous</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-24742</link>
		<dc:creator><![CDATA[ubiquitous]]></dc:creator>
		<pubDate>Fri, 09 Aug 2013 11:41:28 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-24742</guid>
		<description><![CDATA[create a binary tree with the data 10, 5 ,7,6,8,9. Now you swap 7,9. Check the implementation , it will give you wrong answer. Thanks.]]></description>
		<content:encoded><![CDATA[<p>create a binary tree with the data 10, 5 ,7,6,8,9. Now you swap 7,9. Check the implementation , it will give you wrong answer. Thanks.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sumit Monga</title>
		<link>http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/#comment-25508</link>
		<dc:creator><![CDATA[Sumit Monga]]></dc:creator>
		<pubDate>Fri, 09 Aug 2013 03:49:47 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=23616#comment-25508</guid>
		<description><![CDATA[Sorry no need to use (count&#060;2) in both else if statements.]]></description>
		<content:encoded><![CDATA[<p>Sorry no need to use (count&lt;2) in both else if statements.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 12:43:58 -->

<!-- Compression = gzip -->