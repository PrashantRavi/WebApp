<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Largest Rectangular Area in a Histogram &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Nilendu Das</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-40027</link>
		<dc:creator><![CDATA[Nilendu Das]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 09:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-40027</guid>
		<description><![CDATA[The range over which the min-heap will be made changes in every segment. So you have to build as many segment trees as the number of segments. So, segment tree is best fit for this purpose. :)]]></description>
		<content:encoded><![CDATA[<p>The range over which the min-heap will be made changes in every segment. So you have to build as many segment trees as the number of segments. So, segment tree is best fit for this purpose. ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-35296</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Wed, 30 Apr 2014 02:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-35296</guid>
		<description><![CDATA[Why do we need to use Segmentation tree for min value? why cant we just use Min Heap? Can anyone please explain this?]]></description>
		<content:encoded><![CDATA[<p>Why do we need to use Segmentation tree for min value? why cant we just use Min Heap? Can anyone please explain this?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-34626</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 12 Apr 2014 19:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-34626</guid>
		<description><![CDATA[can this code work if we have  a histogram array with zero entry?????thanks ...]]></description>
		<content:encoded><![CDATA[<p>can this code work if we have  a histogram array with zero entry?????thanks &#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: zealfire</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-31516</link>
		<dc:creator><![CDATA[zealfire]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 16:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-31516</guid>
		<description><![CDATA[//would be great if someone verifies this solution
#include

#include

using namespace std;

int find1(int arr[],int l,int mid,int h)

{

	int k1=0,key,l1;

	if((h-l)%2!=0)

	mid=mid+1;

	key=min(min(arr[mid],arr[mid-1]),arr[mid+1]);

	l1=mid;

	while(l1&#062;=0)

	{

	if(arr[l1]&#062;=key)

	{

		l1--;

		k1++;

	}

	else

	break;

	}

	l1=mid+1;

	while(l1=key)

	{

		l1++;

		k1++;

	}

	else

	break;

	}

	//printf(&quot;%dn&quot;,k1*key);

	return k1*key;

}

int find(int arr[],int l,int h)

{

	if(l==h)

	return arr[l];

	int mid=(l+h)/2;

	return max(max(find(arr,l,mid),find(arr,mid+1,h)),find1(arr,l,mid,h));

}

int main()

{

	int arr[7],i;

	for(i=0;i&#060;7;i++)

	{

		scanf(&#034;%d&#034;,&#038;arr[i]);

	}

	printf(&#034;%d&#034;,find(arr,0,6));

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>//would be great if someone verifies this solution<br />
#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>int find1(int arr[],int l,int mid,int h)</p>
<p>{</p>
<p>	int k1=0,key,l1;</p>
<p>	if((h-l)%2!=0)</p>
<p>	mid=mid+1;</p>
<p>	key=min(min(arr[mid],arr[mid-1]),arr[mid+1]);</p>
<p>	l1=mid;</p>
<p>	while(l1&gt;=0)</p>
<p>	{</p>
<p>	if(arr[l1]&gt;=key)</p>
<p>	{</p>
<p>		l1&#8211;;</p>
<p>		k1++;</p>
<p>	}</p>
<p>	else</p>
<p>	break;</p>
<p>	}</p>
<p>	l1=mid+1;</p>
<p>	while(l1=key)</p>
<p>	{</p>
<p>		l1++;</p>
<p>		k1++;</p>
<p>	}</p>
<p>	else</p>
<p>	break;</p>
<p>	}</p>
<p>	//printf(&#8220;%dn&#8221;,k1*key);</p>
<p>	return k1*key;</p>
<p>}</p>
<p>int find(int arr[],int l,int h)</p>
<p>{</p>
<p>	if(l==h)</p>
<p>	return arr[l];</p>
<p>	int mid=(l+h)/2;</p>
<p>	return max(max(find(arr,l,mid),find(arr,mid+1,h)),find1(arr,l,mid,h));</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>	int arr[7],i;</p>
<p>	for(i=0;i&lt;7;i++)</p>
<p>	{</p>
<p>		scanf(&quot;%d&quot;,&amp;arr[i]);</p>
<p>	}</p>
<p>	printf(&quot;%d&quot;,find(arr,0,6));</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pefullarton</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-27371</link>
		<dc:creator><![CDATA[pefullarton]]></dc:creator>
		<pubDate>Thu, 05 Sep 2013 14:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-27371</guid>
		<description><![CDATA[Yes this is correct, but the complexity is O(n^2).]]></description>
		<content:encoded><![CDATA[<p>Yes this is correct, but the complexity is O(n^2).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: A Kumar</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-26260</link>
		<dc:creator><![CDATA[A Kumar]]></dc:creator>
		<pubDate>Sun, 18 Aug 2013 18:37:23 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-26260</guid>
		<description><![CDATA[A very simple iterativer approach without stack and recursion . Please correct me if I am wrong. 

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#034;stdio.h&#034;
int getMaxArea(int hist[], int n )
{
	int height;
	int hist_index =0;
	int width =0;
	int maxRect =0;
	int rect ; 

	for(int i = 0 ;i&#060; n ; i++)
	{
		width = 0;
		height = hist[i]; 
		hist_index = i;
		//move left  till start 
		while(height &#060;=  hist[hist_index]  &#038;&#038; hist_index&#062;=0)
		{			
			width++;
			hist_index --;
		}
		//move right till end
		hist_index = i+1;
		while(height &#060;=  hist[hist_index] &#038;&#038; hist_index &#060; n)
		{			
			width++;
			hist_index ++;
		}
		rect = height*width;
		if(maxRect &#060; rect ) maxRect = rect ; 
	}
	return maxRect; 
}

int main()
{
	int hist[] = {1,2,1,1,3,4,3,3,4,5,2,1,2,3}; // Output -&#062;18
				// Input {6, 2, 5, 4, 5, 1, 6}; Output -&#062;12 
    int n = sizeof(hist)/sizeof(hist[0]);
    printf(&#034; Maxt rect Area  = %d \n\n&#034; ,getMaxArea(hist, n));
    return 0;
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>A very simple iterativer approach without stack and recursion . Please correct me if I am wrong. </p>
<pre> <code language="C">
#include &quot;stdio.h&quot;
int getMaxArea(int hist[], int n )
{
	int height;
	int hist_index =0;
	int width =0;
	int maxRect =0;
	int rect ; 

	for(int i = 0 ;i&lt; n ; i++)
	{
		width = 0;
		height = hist[i]; 
		hist_index = i;
		//move left  till start 
		while(height &lt;=  hist[hist_index]  &amp;&amp; hist_index&gt;=0)
		{			
			width++;
			hist_index --;
		}
		//move right till end
		hist_index = i+1;
		while(height &lt;=  hist[hist_index] &amp;&amp; hist_index &lt; n)
		{			
			width++;
			hist_index ++;
		}
		rect = height*width;
		if(maxRect &lt; rect ) maxRect = rect ; 
	}
	return maxRect; 
}

int main()
{
	int hist[] = {1,2,1,1,3,4,3,3,4,5,2,1,2,3}; // Output -&gt;18
				// Input {6, 2, 5, 4, 5, 1, 6}; Output -&gt;12 
    int n = sizeof(hist)/sizeof(hist[0]);
    printf(&quot; Maxt rect Area  = %d \n\n&quot; ,getMaxArea(hist, n));
    return 0;
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: innosam</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-23150</link>
		<dc:creator><![CDATA[innosam]]></dc:creator>
		<pubDate>Sat, 03 Aug 2013 11:50:06 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-23150</guid>
		<description><![CDATA[A straight forward  Recursive solution based on the first approach:
  http://wp.me/3bJAF]]></description>
		<content:encoded><![CDATA[<p>A straight forward  Recursive solution based on the first approach:<br />
  <a href="http://wp.me/3bJAF" rel="nofollow">http://wp.me/3bJAF</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sachin Jain</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-25722</link>
		<dc:creator><![CDATA[Sachin Jain]]></dc:creator>
		<pubDate>Mon, 06 May 2013 05:40:46 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-25722</guid>
		<description><![CDATA[Yes, my approach is same as above one. Thanks for optimized solution.]]></description>
		<content:encoded><![CDATA[<p>Yes, my approach is same as above one. Thanks for optimized solution.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-17911</link>
		<dc:creator><![CDATA[Rohit]]></dc:creator>
		<pubDate>Mon, 06 May 2013 00:58:39 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-17911</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
public static int LargestHist(int[] arr)
		{
			int curSide,curArea;
			curSide=arr[0];curArea=arr[0];
			int maxArea=arr[0],n=1;
			for(int i=1;i&#060;arr.length;i++)
			{
				n++;
				curSide=Math.min(curSide,arr[i]);
				curArea=curSide*n;
				System.out.println(curArea);
				if(curArea&#062;maxArea)
				{
					maxArea=curArea;
		
				}
				else if(n&#062;1)
				{
					n=0;
					curSide=Integer.MAX_VALUE;
					curArea=1;
				}
				System.out.println(maxArea);
			}
			
			return maxArea;
		}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
public static int LargestHist(int[] arr)
		{
			int curSide,curArea;
			curSide=arr[0];curArea=arr[0];
			int maxArea=arr[0],n=1;
			for(int i=1;i&lt;arr.length;i++)
			{
				n++;
				curSide=Math.min(curSide,arr[i]);
				curArea=curSide*n;
				System.out.println(curArea);
				if(curArea&gt;maxArea)
				{
					maxArea=curArea;
		
				}
				else if(n&gt;1)
				{
					n=0;
					curSide=Integer.MAX_VALUE;
					curArea=1;
				}
				System.out.println(maxArea);
			}
			
			return maxArea;
		}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-25721</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Sun, 05 May 2013 14:03:38 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-25721</guid>
		<description><![CDATA[Sachin: Please see http://www.geeksforgeeks.org/largest-rectangle-under-histogram/ .   Let us know if your approach is different from the link.]]></description>
		<content:encoded><![CDATA[<p>Sachin: Please see <a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/" rel="nofollow">http://www.geeksforgeeks.org/largest-rectangle-under-histogram/</a> .   Let us know if your approach is different from the link.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sachin Jain</title>
		<link>http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/#comment-17866</link>
		<dc:creator><![CDATA[Sachin Jain]]></dc:creator>
		<pubDate>Sat, 04 May 2013 11:15:18 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116623#comment-17866</guid>
		<description><![CDATA[[sourcecode language=&quot;C++&quot;]
#include &#060;iostream&#062;
#include &#060;vector&#062;
#include &#060;stack&#062;

int getMaxRectArea(std::vector&#060;int&#062;&#038; histogram) ;

int main()
{
 	int input[] = {6, 2, 5, 4, 5, 1, 6} ;
 	// int input[] = {6, 2, 5, 4, 5, 2, 6} ;
 	// int input[] = {6, 1, 5, 4, 5, 2, 6} ;
 	// int input[] = {3, 4, 5, 6, 5, 4, 3} ;
 	std::vector&#060;int&#062; histogram(input, input + sizeof(input) / sizeof(int)) ;
	
	std::cout &#060;&#060; getMaxRectArea(histogram) &#060;&#060; std::endl ;
	  	
 	return 0 ;
}

int getMaxRectArea(std::vector&#060;int&#062;&#038; histogram)
{
 	switch( histogram.size() )
	{
 		case 0 :	return 0 ;
 		
 		case 1 :	return histogram[0] ;
	}
	
 	int size = histogram.size() ;
 	
 	int *maxRectAreatoRight = new int[size] ;
 	int *maxRectAreatoLeft = new int[size] ;
 	int maxRectArea = 0 ;
 	std::stack&#060;int&#062; indexes;
 	
 	indexes.push(0);
 	
 	for ( int i = 1 ; i &#060; size ; i++ )
 	{
	 	while ( !indexes.empty() &#038;&#038; histogram[i] &#060; histogram[indexes.top()] )
	 	{
		   	 maxRectAreatoRight[indexes.top()] = histogram[indexes.top()] * ( i - indexes.top() ) ;
		   	 indexes.pop() ;
	 	}
	 	
	 	indexes.push(i) ;
	}
 	
 	while ( !indexes.empty() )
 	{
	 	  maxRectAreatoRight[indexes.top()] = histogram[indexes.top()] * ( size - indexes.top() ) ;
   	 	  indexes.pop() ;
  	}
 	
 	indexes.push(size - 1);
 	
 	for ( int i = size - 2 ; i &#062;= 0 ; i-- )
 	{
	 	while ( !indexes.empty() &#038;&#038; histogram[i] &#060; histogram[indexes.top()] )
	 	{
		   	 maxRectAreatoLeft[indexes.top()] = histogram[indexes.top()] * ( indexes.top() - i ) ;
		   	 indexes.pop() ;
	 	}
	 	
	 	indexes.push(i) ;
	}
 	
 	while ( !indexes.empty() )
 	{
	 	  maxRectAreatoLeft[indexes.top()] = histogram[indexes.top()] * ( indexes.top() + 1 ) ;
   	 	  indexes.pop() ;
  	}
  	
  	for ( int i = 0 ; i &#060; size ; i++ )
  	{
	 	int currentRectArea = maxRectAreatoLeft[i] + maxRectAreatoRight[i] - histogram[i] ;
	 	if ( maxRectArea &#060; currentRectArea )
	 	   maxRectArea = currentRectArea ;
	}
  	
 	return maxRectArea;
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>#include &lt;iostream&gt;<br />
#include &lt;vector&gt;<br />
#include &lt;stack&gt;</p>
<p>int getMaxRectArea(std::vector&lt;int&gt;&amp; histogram) ;</p>
<p>int main()<br />
{<br />
 	int input[] = {6, 2, 5, 4, 5, 1, 6} ;<br />
 	// int input[] = {6, 2, 5, 4, 5, 2, 6} ;<br />
 	// int input[] = {6, 1, 5, 4, 5, 2, 6} ;<br />
 	// int input[] = {3, 4, 5, 6, 5, 4, 3} ;<br />
 	std::vector&lt;int&gt; histogram(input, input + sizeof(input) / sizeof(int)) ;</p>
<p>	std::cout &lt;&lt; getMaxRectArea(histogram) &lt;&lt; std::endl ;</p>
<p> 	return 0 ;<br />
}</p>
<p>int getMaxRectArea(std::vector&lt;int&gt;&amp; histogram)<br />
{<br />
 	switch( histogram.size() )<br />
	{<br />
 		case 0 :	return 0 ;</p>
<p> 		case 1 :	return histogram[0] ;<br />
	}</p>
<p> 	int size = histogram.size() ;</p>
<p> 	int *maxRectAreatoRight = new int[size] ;<br />
 	int *maxRectAreatoLeft = new int[size] ;<br />
 	int maxRectArea = 0 ;<br />
 	std::stack&lt;int&gt; indexes;</p>
<p> 	indexes.push(0);</p>
<p> 	for ( int i = 1 ; i &lt; size ; i++ )<br />
 	{<br />
	 	while ( !indexes.empty() &amp;&amp; histogram[i] &lt; histogram[indexes.top()] )<br />
	 	{<br />
		   	 maxRectAreatoRight[indexes.top()] = histogram[indexes.top()] * ( i &#8211; indexes.top() ) ;<br />
		   	 indexes.pop() ;<br />
	 	}</p>
<p>	 	indexes.push(i) ;<br />
	}</p>
<p> 	while ( !indexes.empty() )<br />
 	{<br />
	 	  maxRectAreatoRight[indexes.top()] = histogram[indexes.top()] * ( size &#8211; indexes.top() ) ;<br />
   	 	  indexes.pop() ;<br />
  	}</p>
<p> 	indexes.push(size &#8211; 1);</p>
<p> 	for ( int i = size &#8211; 2 ; i &gt;= 0 ; i&#8211; )<br />
 	{<br />
	 	while ( !indexes.empty() &amp;&amp; histogram[i] &lt; histogram[indexes.top()] )<br />
	 	{<br />
		   	 maxRectAreatoLeft[indexes.top()] = histogram[indexes.top()] * ( indexes.top() &#8211; i ) ;<br />
		   	 indexes.pop() ;<br />
	 	}</p>
<p>	 	indexes.push(i) ;<br />
	}</p>
<p> 	while ( !indexes.empty() )<br />
 	{<br />
	 	  maxRectAreatoLeft[indexes.top()] = histogram[indexes.top()] * ( indexes.top() + 1 ) ;<br />
   	 	  indexes.pop() ;<br />
  	}</p>
<p>  	for ( int i = 0 ; i &lt; size ; i++ )<br />
  	{<br />
	 	int currentRectArea = maxRectAreatoLeft[i] + maxRectAreatoRight[i] &#8211; histogram[i] ;<br />
	 	if ( maxRectArea &lt; currentRectArea )<br />
	 	   maxRectArea = currentRectArea ;<br />
	}</p>
<p> 	return maxRectArea;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.052 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:57:48 -->

<!-- Compression = gzip -->