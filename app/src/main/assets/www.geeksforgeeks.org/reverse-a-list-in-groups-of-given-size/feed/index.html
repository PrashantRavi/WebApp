<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Reverse a Linked List in groups of given size &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-39527</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 12:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-39527</guid>
		<description><![CDATA[Iterative Version for Above Problem:
&lt;code&gt;

#include 
#include 
#define MAX 1000

using namespace std;

struct node {
  int data;
  struct node *next;
};

typedef struct node Node ;

Node *insert(Node *head, int val)
{
  Node *ptr=NULL, *tmp = head;
  
  ptr = new Node();
  ptr-&#062;data = val;
  
  if(head==NULL)
  {
    ptr-&#062;next = NULL;
    return ptr;
  }
  while(tmp-&#062;next != NULL)
    tmp = tmp-&#062;next;

  tmp-&#062;next = ptr;
  ptr-&#062;next = NULL;

  return head;
}

void printList(Node *head)
{
  while(head != NULL){
    cout&#060;data&#060;next;
  }
  cout&#060;next;
      ptr-&#062;next = NULL;

      Node *p, *c, *n;
      p = nxt;
      if(start==NULL)
        c = head;
      else
        c = start-&#062;next;
      tmp=c;
      while(c!=NULL)
      {
        n = c-&#062;next;
        c-&#062;next = p;
        p = c;
        c = n;
      }
      if(start==NULL)
        head = p;
      else
        start-&#062;next = p;
      
      start = tmp;
      ptr = nxt;
      i=1;
    }
    else
    {
      ptr = ptr-&#062;next;
      i++;
    }
    totalNodes++;
  }

  if(totalNodesnext;
      c-&#062;next = p;
      p = c;
      c = n;
    }
    return p;
  }
  return head;
}

int main()
{
  int n, val, k;
  Node *head = NULL;
  cout&#060;&#060;&#034;Number of Nodes in List ??&#034;&#060;&#062;n;  
  cout&#060;&#060;&#034;Node Values ?? &#034;&#060;&#062;val;
    head = insert(head, val);
  }
  cout&#060;&#060;&#034;Value of k&#034;&#060;&#062;k;
  cout&#060;&#060;&#034;Original List&#034;&#060;&#060;endl;
  printList(head);
  head = reverseKNodeList(head, k);
  cout&#060;&#060;&#034;Final List: &#034;&#060;&#060;endl;
  printList(head);
  cout&#060;&#060;endl;
  return 0;
}

&lt;/code&gt;
]]></description>
		<content:encoded><![CDATA[<p>Iterative Version for Above Problem:<br />
<code></p>
<p>#include<br />
#include<br />
#define MAX 1000</p>
<p>using namespace std;</p>
<p>struct node {<br />
  int data;<br />
  struct node *next;<br />
};</p>
<p>typedef struct node Node ;</p>
<p>Node *insert(Node *head, int val)<br />
{<br />
  Node *ptr=NULL, *tmp = head;</p>
<p>  ptr = new Node();<br />
  ptr-&gt;data = val;</p>
<p>  if(head==NULL)<br />
  {<br />
    ptr-&gt;next = NULL;<br />
    return ptr;<br />
  }<br />
  while(tmp-&gt;next != NULL)<br />
    tmp = tmp-&gt;next;</p>
<p>  tmp-&gt;next = ptr;<br />
  ptr-&gt;next = NULL;</p>
<p>  return head;<br />
}</p>
<p>void printList(Node *head)<br />
{<br />
  while(head != NULL){<br />
    cout&lt;data&lt;next;<br />
  }<br />
  cout&lt;next;<br />
      ptr-&gt;next = NULL;</p>
<p>      Node *p, *c, *n;<br />
      p = nxt;<br />
      if(start==NULL)<br />
        c = head;<br />
      else<br />
        c = start-&gt;next;<br />
      tmp=c;<br />
      while(c!=NULL)<br />
      {<br />
        n = c-&gt;next;<br />
        c-&gt;next = p;<br />
        p = c;<br />
        c = n;<br />
      }<br />
      if(start==NULL)<br />
        head = p;<br />
      else<br />
        start-&gt;next = p;</p>
<p>      start = tmp;<br />
      ptr = nxt;<br />
      i=1;<br />
    }<br />
    else<br />
    {<br />
      ptr = ptr-&gt;next;<br />
      i++;<br />
    }<br />
    totalNodes++;<br />
  }</p>
<p>  if(totalNodesnext;<br />
      c-&gt;next = p;<br />
      p = c;<br />
      c = n;<br />
    }<br />
    return p;<br />
  }<br />
  return head;<br />
}</p>
<p>int main()<br />
{<br />
  int n, val, k;<br />
  Node *head = NULL;<br />
  cout&lt;&lt;&quot;Number of Nodes in List ??&quot;&lt;&gt;n;<br />
  cout&lt;&lt;&quot;Node Values ?? &quot;&lt;&gt;val;<br />
    head = insert(head, val);<br />
  }<br />
  cout&lt;&lt;&quot;Value of k&quot;&lt;&gt;k;<br />
  cout&lt;&lt;&quot;Original List&quot;&lt;&lt;endl;<br />
  printList(head);<br />
  head = reverseKNodeList(head, k);<br />
  cout&lt;&lt;&quot;Final List: &quot;&lt;&lt;endl;<br />
  printList(head);<br />
  cout&lt;&lt;endl;<br />
  return 0;<br />
}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neelabhsingh</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-38694</link>
		<dc:creator><![CDATA[neelabhsingh]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 13:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-38694</guid>
		<description><![CDATA[@geeksforgeeks:disqus, Thanks for providing very good solution but above code will fail in one test case when linked is null, so plz initialize 
struct node *next=null;]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus, Thanks for providing very good solution but above code will fail in one test case when linked is null, so plz initialize<br />
struct node *next=null;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Renjith</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-38272</link>
		<dc:creator><![CDATA[Renjith]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 06:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-38272</guid>
		<description><![CDATA[Iterative solution in java:


public void reverseEvery(int n) {
    Node current = this.head;
    Node prev = null;
    Node next = null;
    Node f1 = null, f2 = null;

    int count = 0;
    boolean veryFirst = true;

    while (current != null) {
        if (count == 0) {
            f1 = current;
        }
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;

        count++;
        if (count == n) {
            if (veryFirst) {
                this.head = prev;
                veryFirst = false;
            }
            count = 0;
            if (f2 != null) {
                 f2.next = prev;
            }
            f2 = f1;
            prev = null;
       }
    }

    if (veryFirst) { // if size of list lesser than n
        this.head = prev;
    } else if (count != 0) { // if size of list mod n != 0...
        f2.next = prev;
    }
}]]></description>
		<content:encoded><![CDATA[<p>Iterative solution in java:</p>
<p>public void reverseEvery(int n) {<br />
    Node current = this.head;<br />
    Node prev = null;<br />
    Node next = null;<br />
    Node f1 = null, f2 = null;</p>
<p>    int count = 0;<br />
    boolean veryFirst = true;</p>
<p>    while (current != null) {<br />
        if (count == 0) {<br />
            f1 = current;<br />
        }<br />
        next = current.next;<br />
        current.next = prev;<br />
        prev = current;<br />
        current = next;</p>
<p>        count++;<br />
        if (count == n) {<br />
            if (veryFirst) {<br />
                this.head = prev;<br />
                veryFirst = false;<br />
            }<br />
            count = 0;<br />
            if (f2 != null) {<br />
                 f2.next = prev;<br />
            }<br />
            f2 = f1;<br />
            prev = null;<br />
       }<br />
    }</p>
<p>    if (veryFirst) { // if size of list lesser than n<br />
        this.head = prev;<br />
    } else if (count != 0) { // if size of list mod n != 0&#8230;<br />
        f2.next = prev;<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-37994</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 10:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-37994</guid>
		<description><![CDATA[can anyone explain here how the recursive call maintains the linklist here.
head-&#062;next = rec_call
How does this works?]]></description>
		<content:encoded><![CDATA[<p>can anyone explain here how the recursive call maintains the linklist here.<br />
head-&gt;next = rec_call<br />
How does this works?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: RACHIT SAXENA</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-37434</link>
		<dc:creator><![CDATA[RACHIT SAXENA]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 13:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-37434</guid>
		<description><![CDATA[iterative solution is here :    :)

#include

struct list

{

    int data;

    struct list *next;

};

void insert(struct list **root,int x)

{

    struct list *temp=(struct list *)malloc(sizeof(struct list)),*current;

    temp-&#062;data=x;

    temp-&#062;next=NULL;

    if(*root==NULL)

    {

        *root=temp;

        return;

    }

    current=*root;

    while(current-&#062;next!=NULL)

    current=current-&#062;next;

    current-&#062;next=temp;

}

void print(struct list *root)

{

    struct list *temp=root;

    while(temp!=NULL)

    {

        printf(&quot;%d &quot;,temp-&#062;data);

        temp=temp-&#062;next;

    }

    printf(&quot;n&quot;);

}

void reverse(struct list **root,int k)

{

    int count=0;

    if(*root==NULL)

        return;

    struct list *temp=*root,*prev=NULL,*current,*last;

    while(temp!=NULL &#038;&#038; count!=k)

    {

        count++;

        current=temp-&#062;next;

        temp-&#062;next=prev;

        prev=temp;

        temp=current;

    }

    last=*root;  // used this to store the first element of original list so as to continue for further reversals

    *root=prev;

    if(temp==NULL)

        return;

    count=0;

    //temp=current;

    prev=NULL;

    struct list *last1; // this is used to remember the very first element in each division of k as we have to link it to next one but it is pointing to null.

    while(temp!=NULL)

    {

        count++;

        current=temp-&#062;next;

        temp-&#062;next=prev;

        prev=temp;

        if(count==1)

            last1=prev;

        temp=current;

        if(count==k)

        {

            count=0;

            last-&#062;next=prev;

            last=last1;

            prev=NULL;

        }

    }

    if(count!=k)

        last-&#062;next=prev;

}

int main()

{

    int k=2;

    struct list *root=NULL;

    insert(&#038;root,1);

    insert(&#038;root,2);

    insert(&#038;root,3);

    insert(&#038;root,4);

    insert(&#038;root,5);

    insert(&#038;root,6);

    insert(&#038;root,7);

    insert(&#038;root,8);

    reverse(&#038;root,k);

    print(root);

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>iterative solution is here :    🙂</p>
<p>#include</p>
<p>struct list</p>
<p>{</p>
<p>    int data;</p>
<p>    struct list *next;</p>
<p>};</p>
<p>void insert(struct list **root,int x)</p>
<p>{</p>
<p>    struct list *temp=(struct list *)malloc(sizeof(struct list)),*current;</p>
<p>    temp-&gt;data=x;</p>
<p>    temp-&gt;next=NULL;</p>
<p>    if(*root==NULL)</p>
<p>    {</p>
<p>        *root=temp;</p>
<p>        return;</p>
<p>    }</p>
<p>    current=*root;</p>
<p>    while(current-&gt;next!=NULL)</p>
<p>    current=current-&gt;next;</p>
<p>    current-&gt;next=temp;</p>
<p>}</p>
<p>void print(struct list *root)</p>
<p>{</p>
<p>    struct list *temp=root;</p>
<p>    while(temp!=NULL)</p>
<p>    {</p>
<p>        printf(&#8220;%d &#8220;,temp-&gt;data);</p>
<p>        temp=temp-&gt;next;</p>
<p>    }</p>
<p>    printf(&#8220;n&#8221;);</p>
<p>}</p>
<p>void reverse(struct list **root,int k)</p>
<p>{</p>
<p>    int count=0;</p>
<p>    if(*root==NULL)</p>
<p>        return;</p>
<p>    struct list *temp=*root,*prev=NULL,*current,*last;</p>
<p>    while(temp!=NULL &amp;&amp; count!=k)</p>
<p>    {</p>
<p>        count++;</p>
<p>        current=temp-&gt;next;</p>
<p>        temp-&gt;next=prev;</p>
<p>        prev=temp;</p>
<p>        temp=current;</p>
<p>    }</p>
<p>    last=*root;  // used this to store the first element of original list so as to continue for further reversals</p>
<p>    *root=prev;</p>
<p>    if(temp==NULL)</p>
<p>        return;</p>
<p>    count=0;</p>
<p>    //temp=current;</p>
<p>    prev=NULL;</p>
<p>    struct list *last1; // this is used to remember the very first element in each division of k as we have to link it to next one but it is pointing to null.</p>
<p>    while(temp!=NULL)</p>
<p>    {</p>
<p>        count++;</p>
<p>        current=temp-&gt;next;</p>
<p>        temp-&gt;next=prev;</p>
<p>        prev=temp;</p>
<p>        if(count==1)</p>
<p>            last1=prev;</p>
<p>        temp=current;</p>
<p>        if(count==k)</p>
<p>        {</p>
<p>            count=0;</p>
<p>            last-&gt;next=prev;</p>
<p>            last=last1;</p>
<p>            prev=NULL;</p>
<p>        }</p>
<p>    }</p>
<p>    if(count!=k)</p>
<p>        last-&gt;next=prev;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    int k=2;</p>
<p>    struct list *root=NULL;</p>
<p>    insert(&amp;root,1);</p>
<p>    insert(&amp;root,2);</p>
<p>    insert(&amp;root,3);</p>
<p>    insert(&amp;root,4);</p>
<p>    insert(&amp;root,5);</p>
<p>    insert(&amp;root,6);</p>
<p>    insert(&amp;root,7);</p>
<p>    insert(&amp;root,8);</p>
<p>    reverse(&amp;root,k);</p>
<p>    print(root);</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gautam Goyal</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-36543</link>
		<dc:creator><![CDATA[Gautam Goyal]]></dc:creator>
		<pubDate>Fri, 23 May 2014 16:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-36543</guid>
		<description><![CDATA[Iterative version working for all cases. As explained below need to know the original head of reversed sublist i.e. head before reversing and tail of the sublist next to be reversed, link these and advance the head pointer to the next sublist to be reversed.
typedef struct node* Link;
Link getTail(Link head,int k){

	if(head == NULL)

		return NULL;

	int count = 0;

	Link temp = head;

	while(count next != NULL){

		temp= temp-&#062;next;

		count++;

	}



	return temp;

}

Link kReverse(Link head, int k ){

	Link curr,prev,finalH,next;

	curr = head;

	prev = NULL;

	if(curr == NULL &#124;&#124; curr-&#062;next == NULL)

		return head;

	int count = 0,times = 0;

	while(head != NULL){

		

		curr = head;

		if(curr-&#062;next == NULL)

			break;

		while(curr != NULL &#038;&#038; countnext;

			curr-&#062;next = prev;

			prev = curr;

			curr = next;

			count++;	

		}

		if(!times){

			finalH = prev;   //capturing the final head of the list, finalH updated only                            //once.

			times++;

		}

		count = 0;

		head-&#062;next = getTail(curr,k);

		head = curr;

		prev = NULL;

	}

	return finalH;

}]]></description>
		<content:encoded><![CDATA[<p>Iterative version working for all cases. As explained below need to know the original head of reversed sublist i.e. head before reversing and tail of the sublist next to be reversed, link these and advance the head pointer to the next sublist to be reversed.<br />
typedef struct node* Link;<br />
Link getTail(Link head,int k){</p>
<p>	if(head == NULL)</p>
<p>		return NULL;</p>
<p>	int count = 0;</p>
<p>	Link temp = head;</p>
<p>	while(count next != NULL){</p>
<p>		temp= temp-&gt;next;</p>
<p>		count++;</p>
<p>	}</p>
<p>	return temp;</p>
<p>}</p>
<p>Link kReverse(Link head, int k ){</p>
<p>	Link curr,prev,finalH,next;</p>
<p>	curr = head;</p>
<p>	prev = NULL;</p>
<p>	if(curr == NULL || curr-&gt;next == NULL)</p>
<p>		return head;</p>
<p>	int count = 0,times = 0;</p>
<p>	while(head != NULL){</p>
<p>		curr = head;</p>
<p>		if(curr-&gt;next == NULL)</p>
<p>			break;</p>
<p>		while(curr != NULL &amp;&amp; countnext;</p>
<p>			curr-&gt;next = prev;</p>
<p>			prev = curr;</p>
<p>			curr = next;</p>
<p>			count++;	</p>
<p>		}</p>
<p>		if(!times){</p>
<p>			finalH = prev;   //capturing the final head of the list, finalH updated only                            //once.</p>
<p>			times++;</p>
<p>		}</p>
<p>		count = 0;</p>
<p>		head-&gt;next = getTail(curr,k);</p>
<p>		head = curr;</p>
<p>		prev = NULL;</p>
<p>	}</p>
<p>	return finalH;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gaurav Reddy</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-35636</link>
		<dc:creator><![CDATA[Gaurav Reddy]]></dc:creator>
		<pubDate>Sun, 04 May 2014 14:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-35636</guid>
		<description><![CDATA[It does. The problem might be because you are storing value in head node, I used head node only as a reference to the linked list.]]></description>
		<content:encoded><![CDATA[<p>It does. The problem might be because you are storing value in head node, I used head node only as a reference to the linked list.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ashish jaiswal</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-35635</link>
		<dc:creator><![CDATA[ashish jaiswal]]></dc:creator>
		<pubDate>Sun, 04 May 2014 14:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-35635</guid>
		<description><![CDATA[it does not reverse the first node.....]]></description>
		<content:encoded><![CDATA[<p>it does not reverse the first node&#8230;..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-35132</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Fri, 25 Apr 2014 21:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-35132</guid>
		<description><![CDATA[Iterative version is much easier to understand than this recursive algorithm]]></description>
		<content:encoded><![CDATA[<p>Iterative version is much easier to understand than this recursive algorithm</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AMIT JAMBOTKAR</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-35037</link>
		<dc:creator><![CDATA[AMIT JAMBOTKAR]]></dc:creator>
		<pubDate>Wed, 23 Apr 2014 18:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-35037</guid>
		<description><![CDATA[In java

public class LinkedList implements Cloneable {

	Node head = null;

	

	// Adding at the End

	class Node {

		T value;

		Node nextReference;

		public Node(T value) {

			this.value = value;

			this.nextReference = null;

		}

		public Node(T value, Node ref) {

			this.value = value;

			this.nextReference = ref;

		}

		public Node() {

			// TODO Auto-generated constructor stub

		}

		public T getValue() {

			return value;

		}

		public void setValue(T value) {

			this.value = value;

		}

		public Node getNextReference() {

			return nextReference;

		}

		public void setNextReference(Node nextReference) {

			this.nextReference = nextReference;

		}

	}

	public void add(E value) {

		Node nodeToBeAdded = head;

		if (validate(head)) {

			head = new Node(value);

			return;

		}

		while (nodeToBeAdded.getNextReference() != null) {

			nodeToBeAdded = nodeToBeAdded.getNextReference();

		}

		Node node = new Node(value);

		nodeToBeAdded.setNextReference(node);

	}

	Node  reverseLinkedList(Node head,int k){

		Node next=null;

		Node prevNode=null;

		Node currentNode=head;

		int count =0;

		while(currentNode!=null &#038;&#038;count&#060;k){

			next=currentNode.nextReference;

			currentNode.setNextReference(prevNode);

			prevNode=currentNode;

			currentNode=next;

		count++;

		}

		if(next !=  null)

	    {  

			head.setNextReference(reverseLinkedList(next, k))  ; 

			}

	 

		return prevNode;

	}

	

	void printAll(Node head) {

		Node node =head ;

		while (node != null) {

			System.out.println(node.getValue());

			node = node.getNextReference();

		}

	}

	

	public boolean validate(Node head) {

		if (head == null) {

			return true;

		}

		return false;

	}

	

	

	public static void main(String[] args) {

		LinkedList linkedList = new LinkedList();

		

		linkedList.add(&quot;1&quot;);

		linkedList.add(&quot;2&quot;);

		linkedList.add(&quot;3&quot;);

		linkedList.add(&quot;4&quot;);

		linkedList.add(&quot;5&quot;);

		linkedList.add(&quot;8&quot;);

		linkedList.add(&quot;7&quot;);

		;

	

		linkedList.printAll(linkedList.reverseLinkedList(linkedList.head,3));

	}

}]]></description>
		<content:encoded><![CDATA[<p>In java</p>
<p>public class LinkedList implements Cloneable {</p>
<p>	Node head = null;</p>
<p>	// Adding at the End</p>
<p>	class Node {</p>
<p>		T value;</p>
<p>		Node nextReference;</p>
<p>		public Node(T value) {</p>
<p>			this.value = value;</p>
<p>			this.nextReference = null;</p>
<p>		}</p>
<p>		public Node(T value, Node ref) {</p>
<p>			this.value = value;</p>
<p>			this.nextReference = ref;</p>
<p>		}</p>
<p>		public Node() {</p>
<p>			// TODO Auto-generated constructor stub</p>
<p>		}</p>
<p>		public T getValue() {</p>
<p>			return value;</p>
<p>		}</p>
<p>		public void setValue(T value) {</p>
<p>			this.value = value;</p>
<p>		}</p>
<p>		public Node getNextReference() {</p>
<p>			return nextReference;</p>
<p>		}</p>
<p>		public void setNextReference(Node nextReference) {</p>
<p>			this.nextReference = nextReference;</p>
<p>		}</p>
<p>	}</p>
<p>	public void add(E value) {</p>
<p>		Node nodeToBeAdded = head;</p>
<p>		if (validate(head)) {</p>
<p>			head = new Node(value);</p>
<p>			return;</p>
<p>		}</p>
<p>		while (nodeToBeAdded.getNextReference() != null) {</p>
<p>			nodeToBeAdded = nodeToBeAdded.getNextReference();</p>
<p>		}</p>
<p>		Node node = new Node(value);</p>
<p>		nodeToBeAdded.setNextReference(node);</p>
<p>	}</p>
<p>	Node  reverseLinkedList(Node head,int k){</p>
<p>		Node next=null;</p>
<p>		Node prevNode=null;</p>
<p>		Node currentNode=head;</p>
<p>		int count =0;</p>
<p>		while(currentNode!=null &amp;&amp;count&lt;k){</p>
<p>			next=currentNode.nextReference;</p>
<p>			currentNode.setNextReference(prevNode);</p>
<p>			prevNode=currentNode;</p>
<p>			currentNode=next;</p>
<p>		count++;</p>
<p>		}</p>
<p>		if(next !=  null)</p>
<p>	    {  </p>
<p>			head.setNextReference(reverseLinkedList(next, k))  ; </p>
<p>			}</p>
<p>		return prevNode;</p>
<p>	}</p>
<p>	void printAll(Node head) {</p>
<p>		Node node =head ;</p>
<p>		while (node != null) {</p>
<p>			System.out.println(node.getValue());</p>
<p>			node = node.getNextReference();</p>
<p>		}</p>
<p>	}</p>
<p>	public boolean validate(Node head) {</p>
<p>		if (head == null) {</p>
<p>			return true;</p>
<p>		}</p>
<p>		return false;</p>
<p>	}</p>
<p>	public static void main(String[] args) {</p>
<p>		LinkedList linkedList = new LinkedList();</p>
<p>		linkedList.add(&#8220;1&#8221;);</p>
<p>		linkedList.add(&#8220;2&#8221;);</p>
<p>		linkedList.add(&#8220;3&#8221;);</p>
<p>		linkedList.add(&#8220;4&#8221;);</p>
<p>		linkedList.add(&#8220;5&#8221;);</p>
<p>		linkedList.add(&#8220;8&#8221;);</p>
<p>		linkedList.add(&#8220;7&#8221;);</p>
<p>		;</p>
<p>		linkedList.printAll(linkedList.reverseLinkedList(linkedList.head,3));</p>
<p>	}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/#comment-32337</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Sat, 08 Feb 2014 10:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=8014#comment-32337</guid>
		<description><![CDATA[can refer to below code for this

http://ideone.com/aFXDFT]]></description>
		<content:encoded><![CDATA[<p>can refer to below code for this</p>
<p><a href="http://ideone.com/aFXDFT" rel="nofollow">http://ideone.com/aFXDFT</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:59:46 -->

<!-- Compression = gzip -->