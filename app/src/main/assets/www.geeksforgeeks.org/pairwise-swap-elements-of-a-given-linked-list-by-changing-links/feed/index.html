<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Pairwise swap elements of a given linked list by changing links</title>
	<atom:link href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Shailesh Tayde</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-38558</link>
		<dc:creator><![CDATA[Shailesh Tayde]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 12:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-38558</guid>
		<description><![CDATA[#include
#include

struct node{
int data;
struct node* link;
};

struct node *start=NULL;

void displayS(){
    int count=1;
    struct node* temp;
    printf(&quot;Entered data isn&quot;);
    temp=start;
    while(temp!=NULL){
        printf(&quot;%d-&#062; &quot;,temp-&#062;data);
        temp=temp-&#062;link;
        count++;
    }
//printf(&quot;bbbb&quot;);
printf(&quot;n&quot;);
}

void swap(){
int count=0;
struct node *temp1,*temp2,*temp3;
if(start-&#062;link==NULL &#038;&#038; start==NULL)
    return;
temp1=start-&#062;link;
temp2=temp1-&#062;link;
temp3=start;
start=temp1;
temp1-&#062;link=temp3;
while(temp2!=NULL &#038;&#038; temp2-&#062;link!=NULL){
    temp3-&#062;link=temp2-&#062;link;
    temp3=temp2;
    temp1=temp3-&#062;link;
    temp2=temp1-&#062;link;
    temp1-&#062;link=temp3;
    count++;
    //temp3-&#062;link=temp2;
}
//printf(&quot;count=%d&quot;,count);
if(count%2!=0){
    temp3-&#062;link=NULL;
  }
  else{
    temp3-&#062;link=temp2;
  }
displayS();
}

int main(){
 struct node *nn,*temp;
 int i=0;
 while(i&quot;);
    nn-&#062;data=++i;
    nn-&#062;link=NULL;
    if(start==NULL){
    start=nn;
    temp=start;
    }
    else{
        temp-&#062;link=nn;
        temp=nn;
        } 
 }

displayS();
swap();
return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include</p>
<p>struct node{<br />
int data;<br />
struct node* link;<br />
};</p>
<p>struct node *start=NULL;</p>
<p>void displayS(){<br />
    int count=1;<br />
    struct node* temp;<br />
    printf(&#8220;Entered data isn&#8221;);<br />
    temp=start;<br />
    while(temp!=NULL){<br />
        printf(&#8220;%d-&gt; &#8220;,temp-&gt;data);<br />
        temp=temp-&gt;link;<br />
        count++;<br />
    }<br />
//printf(&#8220;bbbb&#8221;);<br />
printf(&#8220;n&#8221;);<br />
}</p>
<p>void swap(){<br />
int count=0;<br />
struct node *temp1,*temp2,*temp3;<br />
if(start-&gt;link==NULL &amp;&amp; start==NULL)<br />
    return;<br />
temp1=start-&gt;link;<br />
temp2=temp1-&gt;link;<br />
temp3=start;<br />
start=temp1;<br />
temp1-&gt;link=temp3;<br />
while(temp2!=NULL &amp;&amp; temp2-&gt;link!=NULL){<br />
    temp3-&gt;link=temp2-&gt;link;<br />
    temp3=temp2;<br />
    temp1=temp3-&gt;link;<br />
    temp2=temp1-&gt;link;<br />
    temp1-&gt;link=temp3;<br />
    count++;<br />
    //temp3-&gt;link=temp2;<br />
}<br />
//printf(&#8220;count=%d&#8221;,count);<br />
if(count%2!=0){<br />
    temp3-&gt;link=NULL;<br />
  }<br />
  else{<br />
    temp3-&gt;link=temp2;<br />
  }<br />
displayS();<br />
}</p>
<p>int main(){<br />
 struct node *nn,*temp;<br />
 int i=0;<br />
 while(i&#8221;);<br />
    nn-&gt;data=++i;<br />
    nn-&gt;link=NULL;<br />
    if(start==NULL){<br />
    start=nn;<br />
    temp=start;<br />
    }<br />
    else{<br />
        temp-&gt;link=nn;<br />
        temp=nn;<br />
        }<br />
 }</p>
<p>displayS();<br />
swap();<br />
return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tweety</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-38145</link>
		<dc:creator><![CDATA[tweety]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 19:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-38145</guid>
		<description><![CDATA[this is a simple method with O(n) complexity.... plz check
#include
#include
#include
struct node
{
       int d;
       struct node* next;
}*start=NULL;
void print();
void swap();
int main()
{
    int n,i,x;
    printf(&quot;enter no of elementsn&quot;);
    scanf(&quot;%d&quot;,&#038;n);
    struct node *p,*q;
    for(i=0;id=x;
                    p-&#062;next=NULL;
                    if(start==NULL)
                                   q=start=p;
                    else
                    {
                        q-&#062;next=p;
                        q=p;
                    }
    }
    print();
    swap();
    printf(&quot;n here is the outputn&quot;);
    print();
    getch();
}
void print()
{
     struct node *p;
     for(p=start;p!=NULL;p=p-&#062;next)
                                  printf(&quot;%dt&quot;,p-&#062;d);
     printf(&quot;n&quot;);
}
void swap()
{
     struct node *p,*q,*r;
     for(p=start;p!=NULL;p=p-&#062;next)
     {
                                   q=p-&#062;next;
                                   if(p-&#062;next!=NULL)
                                   {
                                                    if(p==start)
                                                    {
                                                                start=start-&#062;next;
                                                                p-&#062;next=start-&#062;next;
                                                                start-&#062;next=p;
                                                                r=p;
                                                    }
                                                    else
                                                    {
                                                        q=p-&#062;next;
                                                        p-&#062;next=q-&#062;next;
                                                        q-&#062;next=p;
                                                        r-&#062;next=q;
                                                        r=p;
                                                    }
                                   }
     }
}
and using this approach is correct ??]]></description>
		<content:encoded><![CDATA[<p>this is a simple method with O(n) complexity&#8230;. plz check<br />
#include<br />
#include<br />
#include<br />
struct node<br />
{<br />
       int d;<br />
       struct node* next;<br />
}*start=NULL;<br />
void print();<br />
void swap();<br />
int main()<br />
{<br />
    int n,i,x;<br />
    printf(&#8220;enter no of elementsn&#8221;);<br />
    scanf(&#8220;%d&#8221;,&amp;n);<br />
    struct node *p,*q;<br />
    for(i=0;id=x;<br />
                    p-&gt;next=NULL;<br />
                    if(start==NULL)<br />
                                   q=start=p;<br />
                    else<br />
                    {<br />
                        q-&gt;next=p;<br />
                        q=p;<br />
                    }<br />
    }<br />
    print();<br />
    swap();<br />
    printf(&#8220;n here is the outputn&#8221;);<br />
    print();<br />
    getch();<br />
}<br />
void print()<br />
{<br />
     struct node *p;<br />
     for(p=start;p!=NULL;p=p-&gt;next)<br />
                                  printf(&#8220;%dt&#8221;,p-&gt;d);<br />
     printf(&#8220;n&#8221;);<br />
}<br />
void swap()<br />
{<br />
     struct node *p,*q,*r;<br />
     for(p=start;p!=NULL;p=p-&gt;next)<br />
     {<br />
                                   q=p-&gt;next;<br />
                                   if(p-&gt;next!=NULL)<br />
                                   {<br />
                                                    if(p==start)<br />
                                                    {<br />
                                                                start=start-&gt;next;<br />
                                                                p-&gt;next=start-&gt;next;<br />
                                                                start-&gt;next=p;<br />
                                                                r=p;<br />
                                                    }<br />
                                                    else<br />
                                                    {<br />
                                                        q=p-&gt;next;<br />
                                                        p-&gt;next=q-&gt;next;<br />
                                                        q-&gt;next=p;<br />
                                                        r-&gt;next=q;<br />
                                                        r=p;<br />
                                                    }<br />
                                   }<br />
     }<br />
}<br />
and using this approach is correct ??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-37624</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 18:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-37624</guid>
		<description><![CDATA[recursive solution . pls check ?

struct node *pairwise( struct node *head)
{
if ( head == NULL &#124;&#124; head-&#062;next == NULL ){
return head;
}
struct node *p = head;
struct node *q = head-&#062;next;
struct node *t = pairwise(head-&#062;next-&#062;next);
q-&#062;next = p;
p-&#062;next = t;
      return q;
 };]]></description>
		<content:encoded><![CDATA[<p>recursive solution . pls check ?</p>
<p>struct node *pairwise( struct node *head)<br />
{<br />
if ( head == NULL || head-&gt;next == NULL ){<br />
return head;<br />
}<br />
struct node *p = head;<br />
struct node *q = head-&gt;next;<br />
struct node *t = pairwise(head-&gt;next-&gt;next);<br />
q-&gt;next = p;<br />
p-&gt;next = t;<br />
      return q;<br />
 };</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vipinkaushal</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-37526</link>
		<dc:creator><![CDATA[vipinkaushal]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 16:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-37526</guid>
		<description><![CDATA[// iterative much simple implementation  

#include
using namespace std;
typedef struct list
{
    int data;
    struct list *next;
} node;
node *header=NULL;
void createlist(node*);
void printlist(node*);
void alter(node*);
int main()
{
    header = new node; 
    header-&#062;data=0; 
    header-&#062;next=NULL; 
    createlist(header); 
    cout&#060;&#060;endl; 
    printlist(header); 
    alter(header); 
    cout&#060;next!=NULL&#038;&#038;ptr-&#062;next-&#062;next!=NULL){
  ptr1=ptr-&#062;next;
  ptr2=ptr1-&#062;next;
  ptr3=ptr2-&#062;next;
  ptr-&#062;next=ptr2;
  ptr2-&#062;next=ptr1;
  ptr1-&#062;next=ptr3;
  ptr=ptr-&#062;next-&#062;next;
  }
  return;
}

void createlist(node *ptr)
{
    int d;
    do{
        cout&#060;&#062;d;
        if(d!=-1)
        {
            node *ptr2=new node;
            ptr2-&#062;data=d;
            ptr2-&#062;next=NULL;
            ptr-&#062;next=ptr2;
            ptr=ptr2;
        }
        else
            break;
    }while(1);
    return;
}

void printlist(node *ptr)
{
    ptr=ptr-&#062;next;
    while(ptr!=NULL)
    {
        cout&#060;data&#060;&quot;;
        ptr=ptr-&#062;next;

    }
    return;
}]]></description>
		<content:encoded><![CDATA[<p>// iterative much simple implementation  </p>
<p>#include<br />
using namespace std;<br />
typedef struct list<br />
{<br />
    int data;<br />
    struct list *next;<br />
} node;<br />
node *header=NULL;<br />
void createlist(node*);<br />
void printlist(node*);<br />
void alter(node*);<br />
int main()<br />
{<br />
    header = new node;<br />
    header-&gt;data=0;<br />
    header-&gt;next=NULL;<br />
    createlist(header);<br />
    cout&lt;&lt;endl;<br />
    printlist(header);<br />
    alter(header);<br />
    cout&lt;next!=NULL&amp;&amp;ptr-&gt;next-&gt;next!=NULL){<br />
  ptr1=ptr-&gt;next;<br />
  ptr2=ptr1-&gt;next;<br />
  ptr3=ptr2-&gt;next;<br />
  ptr-&gt;next=ptr2;<br />
  ptr2-&gt;next=ptr1;<br />
  ptr1-&gt;next=ptr3;<br />
  ptr=ptr-&gt;next-&gt;next;<br />
  }<br />
  return;<br />
}</p>
<p>void createlist(node *ptr)<br />
{<br />
    int d;<br />
    do{<br />
        cout&lt;&gt;d;<br />
        if(d!=-1)<br />
        {<br />
            node *ptr2=new node;<br />
            ptr2-&gt;data=d;<br />
            ptr2-&gt;next=NULL;<br />
            ptr-&gt;next=ptr2;<br />
            ptr=ptr2;<br />
        }<br />
        else<br />
            break;<br />
    }while(1);<br />
    return;<br />
}</p>
<p>void printlist(node *ptr)<br />
{<br />
    ptr=ptr-&gt;next;<br />
    while(ptr!=NULL)<br />
    {<br />
        cout&lt;data&lt;&#8220;;<br />
        ptr=ptr-&gt;next;</p>
<p>    }<br />
    return;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Srikar ED</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-37514</link>
		<dc:creator><![CDATA[Srikar ED]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 13:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-37514</guid>
		<description><![CDATA[recursion another way....
void pairWiseSwap(struct node **head)
{
struct node *temp,*x;
temp=*head;
if(temp==NULL)
{
return;
}
else if(temp-&#062;next==NULL)
{
return;
}
pairWiseSwap(&#038;(temp-&#062;next-&#062;next));
x=temp-&#062;next;
temp-&#062;next=temp-&#062;next-&#062;next;
x-&#062;next=temp;
*head=x;
}]]></description>
		<content:encoded><![CDATA[<p>recursion another way&#8230;.<br />
void pairWiseSwap(struct node **head)<br />
{<br />
struct node *temp,*x;<br />
temp=*head;<br />
if(temp==NULL)<br />
{<br />
return;<br />
}<br />
else if(temp-&gt;next==NULL)<br />
{<br />
return;<br />
}<br />
pairWiseSwap(&amp;(temp-&gt;next-&gt;next));<br />
x=temp-&gt;next;<br />
temp-&gt;next=temp-&gt;next-&gt;next;<br />
x-&gt;next=temp;<br />
*head=x;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: freak</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-36978</link>
		<dc:creator><![CDATA[freak]]></dc:creator>
		<pubDate>Wed, 28 May 2014 22:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-36978</guid>
		<description><![CDATA[A thing to note is that the function returns the new head along too. :)]]></description>
		<content:encoded><![CDATA[<p>A thing to note is that the function returns the new head along too. 🙂</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: santosh gupta</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-35768</link>
		<dc:creator><![CDATA[santosh gupta]]></dc:creator>
		<pubDate>Wed, 07 May 2014 18:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-35768</guid>
		<description><![CDATA[void rearrange(struct node **nd)
{
    struct node *first,*second,*third,*head;
    first=*nd;
    *nd=(*nd)-&#062;next;

    while(first&#038;&#038;first-&#062;next){
        third=first-&#062;next-&#062;next;
        second=first-&#062;next;
        
        if(third&#038;&#038;third-&#062;next){
            first-&#062;next=third-&#062;next;
        }
        else{
            first-&#062;next=third;
        }
        
        second-&#062;next=first;
        first=third;
    }
}]]></description>
		<content:encoded><![CDATA[<p>void rearrange(struct node **nd)<br />
{<br />
    struct node *first,*second,*third,*head;<br />
    first=*nd;<br />
    *nd=(*nd)-&gt;next;</p>
<p>    while(first&amp;&amp;first-&gt;next){<br />
        third=first-&gt;next-&gt;next;<br />
        second=first-&gt;next;</p>
<p>        if(third&amp;&amp;third-&gt;next){<br />
            first-&gt;next=third-&gt;next;<br />
        }<br />
        else{<br />
            first-&gt;next=third;<br />
        }</p>
<p>        second-&gt;next=first;<br />
        first=third;<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sandeep</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-35524</link>
		<dc:creator><![CDATA[sandeep]]></dc:creator>
		<pubDate>Fri, 02 May 2014 09:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-35524</guid>
		<description><![CDATA[void pairWiseSwap(struct node **head)

{

   if(*head==NULL) return;

	struct node *p1=*head;

	struct node *p2=(*head)-&#062;next;

	if(p2!=NULL) *head=p2;

	struct node *curr=NULL;

	struct node *prev=NULL;

	while(p1!=NULL &#038;&#038; p2!=NULL)

	{

		

		curr=p2-&#062;next;

		p2-&#062;next=p1;

		if(prev!=NULL) prev-&#062;next=p2;

		p1-&#062;next=curr;

		prev=p1;

		p1=curr;

		if(p1!=NULL)p2=p1-&#062;next;

	}

 }]]></description>
		<content:encoded><![CDATA[<p>void pairWiseSwap(struct node **head)</p>
<p>{</p>
<p>   if(*head==NULL) return;</p>
<p>	struct node *p1=*head;</p>
<p>	struct node *p2=(*head)-&gt;next;</p>
<p>	if(p2!=NULL) *head=p2;</p>
<p>	struct node *curr=NULL;</p>
<p>	struct node *prev=NULL;</p>
<p>	while(p1!=NULL &amp;&amp; p2!=NULL)</p>
<p>	{</p>
<p>		curr=p2-&gt;next;</p>
<p>		p2-&gt;next=p1;</p>
<p>		if(prev!=NULL) prev-&gt;next=p2;</p>
<p>		p1-&gt;next=curr;</p>
<p>		prev=p1;</p>
<p>		p1=curr;</p>
<p>		if(p1!=NULL)p2=p1-&gt;next;</p>
<p>	}</p>
<p> }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-35278</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Tue, 29 Apr 2014 12:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-35278</guid>
		<description><![CDATA[void umar_rearrange(struct node *odd )
{
if(!odd &#124;&#124; !(odd-&#062;next) &#124;&#124; !(odd-&#062;next-&#062;next))
return;
struct node *even = NULL, *odd_prev = NULL, *temp = NULL;
while(odd &#038;&#038; odd-&#062;next)
{
if(!even)
{
even = odd-&#062;next;
temp = even-&#062;next;
even-&#062;next = NULL;
}
else
{
temp = odd-&#062;next-&#062;next;
odd-&#062;next-&#062;next = even;
even = odd-&#062;next;
}
odd_prev = odd;
odd-&#062;next = temp;
odd = odd-&#062;next;
}
if(odd)
odd-&#062;next = even;
else
odd_prev-&#062;next = even;
}]]></description>
		<content:encoded><![CDATA[<p>void umar_rearrange(struct node *odd )<br />
{<br />
if(!odd || !(odd-&gt;next) || !(odd-&gt;next-&gt;next))<br />
return;<br />
struct node *even = NULL, *odd_prev = NULL, *temp = NULL;<br />
while(odd &amp;&amp; odd-&gt;next)<br />
{<br />
if(!even)<br />
{<br />
even = odd-&gt;next;<br />
temp = even-&gt;next;<br />
even-&gt;next = NULL;<br />
}<br />
else<br />
{<br />
temp = odd-&gt;next-&gt;next;<br />
odd-&gt;next-&gt;next = even;<br />
even = odd-&gt;next;<br />
}<br />
odd_prev = odd;<br />
odd-&gt;next = temp;<br />
odd = odd-&gt;next;<br />
}<br />
if(odd)<br />
odd-&gt;next = even;<br />
else<br />
odd_prev-&gt;next = even;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-35137</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 04:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-35137</guid>
		<description><![CDATA[Good alternative.  Merging list is also discussed separately at
http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/]]></description>
		<content:encoded><![CDATA[<p>Good alternative.  Merging list is also discussed separately at<br />
<a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/" rel="nofollow">http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/#comment-35136</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 04:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125153#comment-35136</guid>
		<description><![CDATA[Java implementation
http://ideone.com/VJvknN]]></description>
		<content:encoded><![CDATA[<p>Java implementation<br />
<a href="http://ideone.com/VJvknN" rel="nofollow">http://ideone.com/VJvknN</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:14:54 -->

<!-- Compression = gzip -->