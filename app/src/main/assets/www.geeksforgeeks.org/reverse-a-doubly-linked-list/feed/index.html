<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Reverse a Doubly Linked List</title>
	<atom:link href="http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Srijal Sahu</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-37531</link>
		<dc:creator><![CDATA[Srijal Sahu]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 17:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-37531</guid>
		<description><![CDATA[Best site for data structures

finally I got the concept :) :)]]></description>
		<content:encoded><![CDATA[<p>Best site for data structures</p>
<p>finally I got the concept ðŸ™‚ ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-36273</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Mon, 19 May 2014 12:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-36273</guid>
		<description><![CDATA[It won&#039;t work. But you are right in that reversing a double linked list is a bit futile since it is equivalent in either directions and it is easy to consider the reverse list by starting with the tail instead of the head and following the prev pointers instead of the next pointers]]></description>
		<content:encoded><![CDATA[<p>It won&#8217;t work. But you are right in that reversing a double linked list is a bit futile since it is equivalent in either directions and it is easy to consider the reverse list by starting with the tail instead of the head and following the prev pointers instead of the next pointers</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-36272</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Mon, 19 May 2014 12:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-36272</guid>
		<description><![CDATA[The data in a general linked list need not be ints or chars. The nodes can be quite big objects. In that case, the cost per swap will be more. The pointers on the other hand are always 4/8 bytes]]></description>
		<content:encoded><![CDATA[<p>The data in a general linked list need not be ints or chars. The nodes can be quite big objects. In that case, the cost per swap will be more. The pointers on the other hand are always 4/8 bytes</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sam</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-35667</link>
		<dc:creator><![CDATA[sam]]></dc:creator>
		<pubDate>Mon, 05 May 2014 09:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-35667</guid>
		<description><![CDATA[why the time required would be more in case of swapping data items
as there will be n/2 swaps only as compared to swapping pointers with n swaps..??]]></description>
		<content:encoded><![CDATA[<p>why the time required would be more in case of swapping data items<br />
as there will be n/2 swaps only as compared to swapping pointers with n swaps..??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Castle Age</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-31871</link>
		<dc:creator><![CDATA[Castle Age]]></dc:creator>
		<pubDate>Sun, 26 Jan 2014 15:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-31871</guid>
		<description><![CDATA[What is the last nodes&#039;s next pointer points to? NULL]]></description>
		<content:encoded><![CDATA[<p>What is the last nodes&#8217;s next pointer points to? NULL</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nishant M Gandhi</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-31474</link>
		<dc:creator><![CDATA[Nishant M Gandhi]]></dc:creator>
		<pubDate>Sun, 12 Jan 2014 11:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-31474</guid>
		<description><![CDATA[revise your concepts via figure.
It wont work.]]></description>
		<content:encoded><![CDATA[<p>revise your concepts via figure.<br />
It wont work.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-31318</link>
		<dc:creator><![CDATA[Amit]]></dc:creator>
		<pubDate>Tue, 07 Jan 2014 07:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-31318</guid>
		<description><![CDATA[I don&#039;t understand  what is the need of all this code. Just store the pointer of the last node to the start, the double linked list is reversed. :) Done :P]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t understand  what is the need of all this code. Just store the pointer of the last node to the start, the double linked list is reversed. ðŸ™‚ Done ðŸ˜›</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nikolche Kolev</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-30634</link>
		<dc:creator><![CDATA[Nikolche Kolev]]></dc:creator>
		<pubDate>Tue, 10 Dec 2013 18:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-30634</guid>
		<description><![CDATA[void reverse(Node * &#038;head){

	Node * prev = NULL;

	Node * next;

	Node * temp;

	while(head){

		temp = head;

		//remember next

		next = head-&#062;next;

		// set next

		head-&#062;next = prev;

		// set prev

		head-&#062;prev = next;

		// set prev for next

		prev = head;

		head = next;

	}

	head = prev;

}]]></description>
		<content:encoded><![CDATA[<p>void reverse(Node * &amp;head){</p>
<p>	Node * prev = NULL;</p>
<p>	Node * next;</p>
<p>	Node * temp;</p>
<p>	while(head){</p>
<p>		temp = head;</p>
<p>		//remember next</p>
<p>		next = head-&gt;next;</p>
<p>		// set next</p>
<p>		head-&gt;next = prev;</p>
<p>		// set prev</p>
<p>		head-&gt;prev = next;</p>
<p>		// set prev for next</p>
<p>		prev = head;</p>
<p>		head = next;</p>
<p>	}</p>
<p>	head = prev;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arunx</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-22876</link>
		<dc:creator><![CDATA[Arunx]]></dc:creator>
		<pubDate>Mon, 29 Jul 2013 07:08:33 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-22876</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
node* reversedouble(node* &#038;L){
 
node* ahead = L;
node* curr  = NULL;

if(!ahead){
	
	cout &#060;&#060; &#034; empty list&#034;;
	return L;
}

while(ahead){

 curr = ahead;
 ahead = ahead-&#062;next;
 curr-&#062; next = curr -&#062; prev;
 curr-&#062; prev = ahead;  	

}
return curr;  
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
node* reversedouble(node* &amp;L){
 
node* ahead = L;
node* curr  = NULL;

if(!ahead){
	
	cout &lt;&lt; &quot; empty list&quot;;
	return L;
}

while(ahead){

 curr = ahead;
 ahead = ahead-&gt;next;
 curr-&gt; next = curr -&gt; prev;
 curr-&gt; prev = ahead;  	

}
return curr;  
}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arunx</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-22875</link>
		<dc:creator><![CDATA[Arunx]]></dc:creator>
		<pubDate>Mon, 29 Jul 2013 07:06:42 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-22875</guid>
		<description><![CDATA[[sourcecodnode* reversedouble(node* &amp;L){
 
node* ahead = L;
node* curr  = NULL;

if(!ahead){
	
	cout &lt;&lt; &quot; empty list&quot;;
	return L;
}

while(ahead){

curr = ahead;
ahead = ahead-&gt;next;

curr-&gt; next = curr -&gt; prev;
curr-&gt; prev = ahead;  	

}

return curr;
   
}]]></description>
		<content:encoded><![CDATA[<p>[sourcecodnode* reversedouble(node* &#038;L){</p>
<p>node* ahead = L;<br />
node* curr  = NULL;</p>
<p>if(!ahead){</p>
<p>	cout < < " empty list";
	return L;
}

while(ahead){

curr = ahead;
ahead = ahead->next;</p>
<p>curr-> next = curr -> prev;<br />
curr-> prev = ahead;  	</p>
<p>}</p>
<p>return curr;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/#comment-17877</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Sat, 04 May 2013 19:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5985#comment-17877</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;
#include&#060;stdlib.h&#062;

struct node {
  int data;
  struct node * prev;
  struct node * next;
};

void insert_node(struct node ** head_ref, struct node *prev_node, int value) {
  struct node * head=*head_ref;
  struct node * new_node=NULL;
  if(head==NULL) {
    new_node=(struct node *)malloc(sizeof(struct node));
    new_node-&#062;data=value;
    new_node-&#062;prev=prev_node;
    new_node-&#062;next=NULL;
    *head_ref=new_node;
  } else {
    insert_node(&#038;head-&#062;next, head, value);
  }
}

void print_dll(struct node * head) {
  struct node * current=head;
  while(current!=NULL) {
    printf(&#034;%d &#034;, current-&#062;data);
    current=current-&#062;next;
  }
  printf(&#034;\n&#034;);
}


void print_dll_reverse_order(struct node * head) {
  struct node * current=head;
  struct node * prev=NULL;
  while(current!=NULL) {
    prev=current;
    current=current-&#062;next;
  }
  while(prev!=NULL) {
    printf(&#034;%d &#034;, prev-&#062;data);
    prev=prev-&#062;prev;
  }
  printf(&#034;\n&#034;);
}

struct node * reverse_dll(struct node ** head_ref) {
  struct node * head=*head_ref;
  if(head==NULL) {
    return head;
  } else {
    struct node * temp=head-&#062;next;
    head-&#062;next=head-&#062;prev;
    head-&#062;prev=temp;
    if(temp!=NULL) return reverse_dll(&#038;temp);
  }
}

int main() {
  struct node * head=NULL;

  insert_node(&#038;head, NULL, 40);
  insert_node(&#038;head, NULL, 30);
  insert_node(&#038;head, NULL, 50);
  insert_node(&#038;head, NULL, 25);
  insert_node(&#038;head, NULL, 35);
  insert_node(&#038;head, NULL, 45);
  insert_node(&#038;head, NULL, 55);
  insert_node(&#038;head, NULL, 60);
  insert_node(&#038;head, NULL, 65);
  insert_node(&#038;head, NULL, 70);
  insert_node(&#038;head, NULL, 75);
  insert_node(&#038;head, NULL, 100);

  print_dll(head);
  print_dll_reverse_order(head);
  head=reverse_dll(&#038;head);
  print_dll(head);

  return 0;
}
&lt;/code&gt; &lt;/pre&gt;

40 30 50 25 35 45 55 60 65 70 75 100 
100 75 70 65 60 55 45 35 25 50 30 40 
100 75 70 65 60 55 45 35 25 50 30 40]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node {
  int data;
  struct node * prev;
  struct node * next;
};

void insert_node(struct node ** head_ref, struct node *prev_node, int value) {
  struct node * head=*head_ref;
  struct node * new_node=NULL;
  if(head==NULL) {
    new_node=(struct node *)malloc(sizeof(struct node));
    new_node-&gt;data=value;
    new_node-&gt;prev=prev_node;
    new_node-&gt;next=NULL;
    *head_ref=new_node;
  } else {
    insert_node(&amp;head-&gt;next, head, value);
  }
}

void print_dll(struct node * head) {
  struct node * current=head;
  while(current!=NULL) {
    printf(&quot;%d &quot;, current-&gt;data);
    current=current-&gt;next;
  }
  printf(&quot;\n&quot;);
}


void print_dll_reverse_order(struct node * head) {
  struct node * current=head;
  struct node * prev=NULL;
  while(current!=NULL) {
    prev=current;
    current=current-&gt;next;
  }
  while(prev!=NULL) {
    printf(&quot;%d &quot;, prev-&gt;data);
    prev=prev-&gt;prev;
  }
  printf(&quot;\n&quot;);
}

struct node * reverse_dll(struct node ** head_ref) {
  struct node * head=*head_ref;
  if(head==NULL) {
    return head;
  } else {
    struct node * temp=head-&gt;next;
    head-&gt;next=head-&gt;prev;
    head-&gt;prev=temp;
    if(temp!=NULL) return reverse_dll(&amp;temp);
  }
}

int main() {
  struct node * head=NULL;

  insert_node(&amp;head, NULL, 40);
  insert_node(&amp;head, NULL, 30);
  insert_node(&amp;head, NULL, 50);
  insert_node(&amp;head, NULL, 25);
  insert_node(&amp;head, NULL, 35);
  insert_node(&amp;head, NULL, 45);
  insert_node(&amp;head, NULL, 55);
  insert_node(&amp;head, NULL, 60);
  insert_node(&amp;head, NULL, 65);
  insert_node(&amp;head, NULL, 70);
  insert_node(&amp;head, NULL, 75);
  insert_node(&amp;head, NULL, 100);

  print_dll(head);
  print_dll_reverse_order(head);
  head=reverse_dll(&amp;head);
  print_dll(head);

  return 0;
}
</code> </pre>
<p>40 30 50 25 35 45 55 60 65 70 75 100<br />
100 75 70 65 60 55 45 35 25 50 30 40<br />
100 75 70 65 60 55 45 35 25 50 30 40</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:00:55 -->

<!-- Compression = gzip -->