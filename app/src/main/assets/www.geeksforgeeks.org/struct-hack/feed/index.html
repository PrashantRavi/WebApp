<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Struct Hack</title>
	<atom:link href="http://www.geeksforgeeks.org/struct-hack/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/struct-hack/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Arpit Jain</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-28386</link>
		<dc:creator><![CDATA[Arpit Jain]]></dc:creator>
		<pubDate>Wed, 02 Oct 2013 18:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-28386</guid>
		<description><![CDATA[Malloc should not be casted in c.]]></description>
		<content:encoded><![CDATA[<p>Malloc should not be casted in c.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: owais</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-27701</link>
		<dc:creator><![CDATA[owais]]></dc:creator>
		<pubDate>Sun, 15 Sep 2013 15:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-27701</guid>
		<description><![CDATA[In you example you have defined carr as an array of 10 therefore you dont need to allocate memory for it however if you would have declared carr as a pointer to a char array i.e char *carr; then in that case you have to dynamically allocate memory as sizeof(*e) is dependent on amount of memory carr has .]]></description>
		<content:encoded><![CDATA[<p>In you example you have defined carr as an array of 10 therefore you dont need to allocate memory for it however if you would have declared carr as a pointer to a char array i.e char *carr; then in that case you have to dynamically allocate memory as sizeof(*e) is dependent on amount of memory carr has .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tamoghna Bhaduri</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-22909</link>
		<dc:creator><![CDATA[Tamoghna Bhaduri]]></dc:creator>
		<pubDate>Mon, 29 Jul 2013 18:43:52 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-22909</guid>
		<description><![CDATA[Thanks a lot :)


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Thanks a lot ðŸ™‚</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: linuxWorld</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-22894</link>
		<dc:creator><![CDATA[linuxWorld]]></dc:creator>
		<pubDate>Mon, 29 Jul 2013 13:51:40 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-22894</guid>
		<description><![CDATA[#include
#include 
typedef struct Node
{
    int data;
struct Node *next;
}Node;
int count=1;
Node *head , *gen ;

Node * create_list(int value)
{
 
    Node *temp;
    temp=(Node *)malloc(sizeof(Node));
    if(count==1)
    {
    head=temp;
    gen=temp;
    temp-&#062;data=value;
    temp-&#062;next=NULL;
    }
    else
    {
    gen-&#062;next=temp;
    temp-&#062;next=NULL;
    temp-&#062;data=value;
    gen=temp;
    }
count++;
return head;
}
int main()
{
    int num,value,i;
    Node *ptr;
printf(&quot;how many nodes::&quot;);
scanf(&quot;%d&quot;,&#038;num);
printf(&quot;\nplease enter the number of nodes ::\n&quot;);
for(i=1;inext!=NULL)  // last data will not be printed // you should write   while(ptr) 
{
    printf(&quot;\n%d\n&quot;,ptr-&#062;data);
    ptr=ptr-&#062;next;
}
    return 0;
}

// check it i think it will run  .... rest is ok]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
typedef struct Node<br />
{<br />
    int data;<br />
struct Node *next;<br />
}Node;<br />
int count=1;<br />
Node *head , *gen ;</p>
<p>Node * create_list(int value)<br />
{</p>
<p>    Node *temp;<br />
    temp=(Node *)malloc(sizeof(Node));<br />
    if(count==1)<br />
    {<br />
    head=temp;<br />
    gen=temp;<br />
    temp-&gt;data=value;<br />
    temp-&gt;next=NULL;<br />
    }<br />
    else<br />
    {<br />
    gen-&gt;next=temp;<br />
    temp-&gt;next=NULL;<br />
    temp-&gt;data=value;<br />
    gen=temp;<br />
    }<br />
count++;<br />
return head;<br />
}<br />
int main()<br />
{<br />
    int num,value,i;<br />
    Node *ptr;<br />
printf(&#8220;how many nodes::&#8221;);<br />
scanf(&#8220;%d&#8221;,&amp;num);<br />
printf(&#8220;\nplease enter the number of nodes ::\n&#8221;);<br />
for(i=1;inext!=NULL)  // last data will not be printed // you should write   while(ptr)<br />
{<br />
    printf(&#8220;\n%d\n&#8221;,ptr-&gt;data);<br />
    ptr=ptr-&gt;next;<br />
}<br />
    return 0;<br />
}</p>
<p>// check it i think it will run  &#8230;. rest is ok</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: linuxWorld</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-22892</link>
		<dc:creator><![CDATA[linuxWorld]]></dc:creator>
		<pubDate>Mon, 29 Jul 2013 13:42:27 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-22892</guid>
		<description><![CDATA[gen-&#062;next=temp; line has error due to wild/ uninitialzed pointer  (SIGSEGV error means invalid acess of the valid memory address)

your implementation needs little modification  // reason your list is not linking with the other node.]]></description>
		<content:encoded><![CDATA[<p>gen-&gt;next=temp; line has error due to wild/ uninitialzed pointer  (SIGSEGV error means invalid acess of the valid memory address)</p>
<p>your implementation needs little modification  // reason your list is not linking with the other node.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tamoghna Bhaduri</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-16754</link>
		<dc:creator><![CDATA[Tamoghna Bhaduri]]></dc:creator>
		<pubDate>Tue, 26 Mar 2013 12:36:40 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-16754</guid>
		<description><![CDATA[this code below is generating SEGMENTATION fault.


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;
#include &#060;stdlib.h&#062;
typedef struct Node
{
    int data;
struct Node *next;
}Node;
int count=1;
Node * create_list(int);
Node * create_list(int value)
{

    Node *temp,*head,*gen;
    temp=(Node *)malloc(sizeof(Node));
    if(count==1)
    {
    head=temp;
    gen=temp;
    temp-&#062;data=value;
    temp-&#062;next=NULL;
    }
    else
    {
    gen-&#062;next=temp;
    temp-&#062;next=NULL;
    temp-&#062;data=value;
    gen=temp;
    }
count++;
return head;
}
int main()
{
    int num,value,i;
    Node *ptr;
printf(&#034;how many nodes::&#034;);
scanf(&#034;%d&#034;,&#038;num);
printf(&#034;\nplease enter the number of nodes ::\n&#034;);
for(i=1;i&#060;=num;i++)
{
    scanf(&#034;%d&#034;,&#038;value);
    ptr=create_list(value);
}
while(ptr-&#062;next!=NULL)
{
    printf(&#034;\n%d\n&#034;,ptr-&#062;data);
    ptr=ptr-&#062;next;
}
    return 0;
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>this code below is generating SEGMENTATION fault.</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Node
{
    int data;
struct Node *next;
}Node;
int count=1;
Node * create_list(int);
Node * create_list(int value)
{

    Node *temp,*head,*gen;
    temp=(Node *)malloc(sizeof(Node));
    if(count==1)
    {
    head=temp;
    gen=temp;
    temp-&gt;data=value;
    temp-&gt;next=NULL;
    }
    else
    {
    gen-&gt;next=temp;
    temp-&gt;next=NULL;
    temp-&gt;data=value;
    gen=temp;
    }
count++;
return head;
}
int main()
{
    int num,value,i;
    Node *ptr;
printf(&quot;how many nodes::&quot;);
scanf(&quot;%d&quot;,&amp;num);
printf(&quot;\nplease enter the number of nodes ::\n&quot;);
for(i=1;i&lt;=num;i++)
{
    scanf(&quot;%d&quot;,&amp;value);
    ptr=create_list(value);
}
while(ptr-&gt;next!=NULL)
{
    printf(&quot;\n%d\n&quot;,ptr-&gt;data);
    ptr=ptr-&gt;next;
}
    return 0;
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ashish</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-13878</link>
		<dc:creator><![CDATA[Ashish]]></dc:creator>
		<pubDate>Fri, 21 Dec 2012 20:04:32 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-13878</guid>
		<description><![CDATA[Do you mean to say instead of fixing size in structure definition name[0](struct hack) can be used to make structure size variable and still all the memory of structure as contiguous?


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Do you mean to say instead of fixing size in structure definition name[0](struct hack) can be used to make structure size variable and still all the memory of structure as contiguous?</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Venki</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-13740</link>
		<dc:creator><![CDATA[Venki]]></dc:creator>
		<pubDate>Tue, 18 Dec 2012 16:36:30 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-13740</guid>
		<description><![CDATA[This technique is new to me. But as long as portability is concerned, we will stick to standard.

Can we define an array of such structures? If not, it breaks the guarantee made by normal structure definition.]]></description>
		<content:encoded><![CDATA[<p>This technique is new to me. But as long as portability is concerned, we will stick to standard.</p>
<p>Can we define an array of such structures? If not, it breaks the guarantee made by normal structure definition.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Venki</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-13739</link>
		<dc:creator><![CDATA[Venki]]></dc:creator>
		<pubDate>Tue, 18 Dec 2012 16:34:45 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-13739</guid>
		<description><![CDATA[The definition of &#039;e&#039; is complete just before assignment sign, so we can use e there after. Not sure, whether any compiler flags it as an error. Perhaps old compilers may throw error.]]></description>
		<content:encoded><![CDATA[<p>The definition of &#8216;e&#8217; is complete just before assignment sign, so we can use e there after. Not sure, whether any compiler flags it as an error. Perhaps old compilers may throw error.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ashish</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-13737</link>
		<dc:creator><![CDATA[Ashish]]></dc:creator>
		<pubDate>Tue, 18 Dec 2012 15:50:10 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-13737</guid>
		<description><![CDATA[Sorry experts:
This article looks strange to me, not sure what am I missing.

But I could not understand above article. I tried below code:
&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
struct employee {
int a;
int b;
char carr[10];
};

int main()
{
struct employee e;
struct employee *e1=NULL;
printf(&#034;size:%d:%d\n&#034;,sizeof(e), sizeof(*(&#038;e)));

printf(&#034;size before alocation:%d\n&#034;,sizeof(*e1));
e1 = malloc(sizeof(struct employee));

strcpy(e1-&#062;carr,&#034;ashish&#034;);

printf(&#034;size:%d,str:%s\n&#034;,sizeof(*e1),e1-&#062;carr);

}

&lt;/code&gt; &lt;/pre&gt;

Output is:
----
size:20:20
size before alocation:20
size:20:str:ashish
----

So why do we need to allocate memory for char array in separate, while sizeof(*e) should returns the complete size of structure itself.
i.e.
why do we need to allocate memory like: malloc(sizeof(*e) + sizeof(char) * 128); while malloc(sizeof(*e)); should be sufficient.]]></description>
		<content:encoded><![CDATA[<p>Sorry experts:<br />
This article looks strange to me, not sure what am I missing.</p>
<p>But I could not understand above article. I tried below code:</p>
<pre> <code language="C">
struct employee {
int a;
int b;
char carr[10];
};

int main()
{
struct employee e;
struct employee *e1=NULL;
printf(&quot;size:%d:%d\n&quot;,sizeof(e), sizeof(*(&amp;e)));

printf(&quot;size before alocation:%d\n&quot;,sizeof(*e1));
e1 = malloc(sizeof(struct employee));

strcpy(e1-&gt;carr,&quot;ashish&quot;);

printf(&quot;size:%d,str:%s\n&quot;,sizeof(*e1),e1-&gt;carr);

}

</code> </pre>
<p>Output is:<br />
&#8212;-<br />
size:20:20<br />
size before alocation:20<br />
size:20:str:ashish<br />
&#8212;-</p>
<p>So why do we need to allocate memory for char array in separate, while sizeof(*e) should returns the complete size of structure itself.<br />
i.e.<br />
why do we need to allocate memory like: malloc(sizeof(*e) + sizeof(char) * 128); while malloc(sizeof(*e)); should be sufficient.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sharath</title>
		<link>http://www.geeksforgeeks.org/struct-hack/#comment-10542</link>
		<dc:creator><![CDATA[Sharath]]></dc:creator>
		<pubDate>Fri, 31 Aug 2012 09:02:57 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=22677#comment-10542</guid>
		<description><![CDATA[Good article.  I never knew about &#039;struct hack&#039;.  Is it a new concept. Where did you get to know about it ? book/generals/man pages ??]]></description>
		<content:encoded><![CDATA[<p>Good article.  I never knew about &#8216;struct hack&#8217;.  Is it a new concept. Where did you get to know about it ? book/generals/man pages ??</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.072 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:25:41 -->

<!-- Compression = gzip -->