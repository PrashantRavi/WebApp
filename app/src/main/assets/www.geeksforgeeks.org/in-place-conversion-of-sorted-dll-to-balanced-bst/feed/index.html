<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: In-place conversion of Sorted DLL to Balanced BST</title>
	<atom:link href="http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-34947</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Mon, 21 Apr 2014 06:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-34947</guid>
		<description><![CDATA[Thanks for pointing this out.  We have updated the comments.]]></description>
		<content:encoded><![CDATA[<p>Thanks for pointing this out.  We have updated the comments.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tinku</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-34944</link>
		<dc:creator><![CDATA[Tinku]]></dc:creator>
		<pubDate>Mon, 21 Apr 2014 04:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-34944</guid>
		<description><![CDATA[@GeeksforGeeks: In the Method2, when structure of type node has been defined, in the comments it has been written as next pointer can be used as left subtree pointer. So please correct it as the prev pointer will point to left subtree and next pointer will point to right subtree.]]></description>
		<content:encoded><![CDATA[<p>@GeeksforGeeks: In the Method2, when structure of type node has been defined, in the comments it has been written as next pointer can be used as left subtree pointer. So please correct it as the prev pointer will point to left subtree and next pointer will point to right subtree.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: alien</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-34636</link>
		<dc:creator><![CDATA[alien]]></dc:creator>
		<pubDate>Sun, 13 Apr 2014 04:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-34636</guid>
		<description><![CDATA[Excellent]]></description>
		<content:encoded><![CDATA[<p>Excellent</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-33908</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 27 Mar 2014 04:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-33908</guid>
		<description><![CDATA[Every node in DLL is visited once so O(n).]]></description>
		<content:encoded><![CDATA[<p>Every node in DLL is visited once so O(n).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: SwaS</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-29400</link>
		<dc:creator><![CDATA[SwaS]]></dc:creator>
		<pubDate>Tue, 29 Oct 2013 01:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-29400</guid>
		<description><![CDATA[How is method 1 different from method 2 ?
Both algo work in the same fashion.. Using the recursion properly we can achieve O(n), which is done in method 2. 
Implementation of method 1 is not provided ..I think the author intends to update the pointers(left node n right node) for current node before making recursive calls for left &#038; right subtrees. Then the complexity wud be O(nlg n) . If we use recursion properly and return the root node at each level we dont need to traverse and calculate mid node at each level. We get these value as sub probs in deeper levels of recursion are solved. So the complexity reduces to O(n).]]></description>
		<content:encoded><![CDATA[<p>How is method 1 different from method 2 ?<br />
Both algo work in the same fashion.. Using the recursion properly we can achieve O(n), which is done in method 2.<br />
Implementation of method 1 is not provided ..I think the author intends to update the pointers(left node n right node) for current node before making recursive calls for left &amp; right subtrees. Then the complexity wud be O(nlg n) . If we use recursion properly and return the root node at each level we dont need to traverse and calculate mid node at each level. We get these value as sub probs in deeper levels of recursion are solved. So the complexity reduces to O(n).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ayush Jain</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-29123</link>
		<dc:creator><![CDATA[Ayush Jain]]></dc:creator>
		<pubDate>Sun, 20 Oct 2013 16:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-29123</guid>
		<description><![CDATA[Even if head_ref is stored in a temp, it will not work because they pointing to same location (in java).They going to refer same list and once root-&#062;next is null list is also modified and there will be a Null Pointer exception.Correct me if i&#039;m wrong.]]></description>
		<content:encoded><![CDATA[<p>Even if head_ref is stored in a temp, it will not work because they pointing to same location (in java).They going to refer same list and once root-&gt;next is null list is also modified and there will be a Null Pointer exception.Correct me if i&#8217;m wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arpit Baheti</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-28655</link>
		<dc:creator><![CDATA[Arpit Baheti]]></dc:creator>
		<pubDate>Thu, 10 Oct 2013 07:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-28655</guid>
		<description><![CDATA[For method 1:

#include 

#include 

using namespace std;

/*

sample input:

9

10 5 14 1 8 7 11 16 13

*/

typedef struct tree

{

    int data;

    struct tree *left;

    struct tree *right;

    struct tree *parent;

} tree;

tree* BSTtoDLL(tree *root)

{

    static tree *pre = NULL;

    static int started =0;

    static tree *head = NULL;

    if(root!=NULL)

    {

        BSTtoDLL(root-&#062;left);

        if(pre)

            pre-&#062;right = root;

        root-&#062;left = pre;

        pre = root;

        if(!started)

        {

            started =1;

            head = root;

        }

        BSTtoDLL(root-&#062;right);

    }

    return head;

}

tree* FindMiddle(tree* head)

{

    tree* slowPtr=head,*fastPtr=head;

    while(fastPtr&#038;&#038;slowPtr)

    {

        fastPtr = fastPtr-&#062;right;

        if(!fastPtr)

            return slowPtr;

        fastPtr = fastPtr-&#062;right;

        if(!fastPtr)

            return slowPtr;

        slowPtr = slowPtr-&#062;right;

    }

    return slowPtr;

}

tree* DLLtoBST(tree *head)

{

    tree *temp,*q;

    if(!head&#124;&#124;!head-&#062;right)

        return head;

    temp = FindMiddle(head);

    if(head==temp)

    {

        if(head-&#062;right!=NULL){

            head-&#062;left =NULL;

            head-&#062;right-&#062;left = NULL;

            return temp;

        }

        else

            return temp;

    }

    if(temp-&#062;left)

        temp-&#062;left-&#062;right = NULL;

    else

        return temp;

    q = temp-&#062;right;

    q-&#062;left = NULL;

    temp-&#062;left =NULL;

    temp-&#062;left = DLLtoBST(head);

    temp-&#062;right = DLLtoBST(q);

    return temp;

}

tree* makenode(int d)

{

    tree *t = new tree;

    t-&#062;data =d;

    t-&#062;left =NULL;

    t-&#062;right =NULL;

    t-&#062;parent =NULL;

    return t;

}

void tree_insert(tree *t,tree *z)

{

    tree *x,*y;

    y = NULL;

    x = t;

    while(x!=NULL)

    {

        y = x;

        if(x-&#062;data&#062;z-&#062;data)

            x = x-&#062;left;

        else

            x = x-&#062;right;

    }

    z-&#062;parent = y;

    if(z-&#062;datadata)

        y-&#062;left = z;

    else

        y-&#062;right =z;

}

void printDLL(tree *head)

{

    tree *ptr = head;

    tree *pr;

    while(ptr)

    {

        pr = ptr;

        cout&#060;data&#060;right;

    }

}

void preorder_walk(tree *t)

{

    if(t==NULL)

        return;

    cout&#060;data&#060;left);

    preorder_walk(t-&#062;right);

}

int main()

{

    int i,n,data;

    cin&#062;&#062;n;

    tree *t,*x,*root;

    cin&#062;&#062;data;

    root = makenode(data);

    tree *newNode;

    for(i=1;i&#062;data;

        newNode = makenode(data);

        tree_insert(root,newNode);

    }

    tree *head = BSTtoDLL(root);

    cout&#060;&#060;&#034;nBST to doubly link list :  &#034;;

    printDLL(head);

    cout&#060;&#060;endl&#060;&#060;&#034;Doubly link list to BST(preorder print) :  &#034;;

    root = DLLtoBST(head);

    preorder_walk(root);

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>For method 1:</p>
<p>#include </p>
<p>#include </p>
<p>using namespace std;</p>
<p>/*</p>
<p>sample input:</p>
<p>9</p>
<p>10 5 14 1 8 7 11 16 13</p>
<p>*/</p>
<p>typedef struct tree</p>
<p>{</p>
<p>    int data;</p>
<p>    struct tree *left;</p>
<p>    struct tree *right;</p>
<p>    struct tree *parent;</p>
<p>} tree;</p>
<p>tree* BSTtoDLL(tree *root)</p>
<p>{</p>
<p>    static tree *pre = NULL;</p>
<p>    static int started =0;</p>
<p>    static tree *head = NULL;</p>
<p>    if(root!=NULL)</p>
<p>    {</p>
<p>        BSTtoDLL(root-&gt;left);</p>
<p>        if(pre)</p>
<p>            pre-&gt;right = root;</p>
<p>        root-&gt;left = pre;</p>
<p>        pre = root;</p>
<p>        if(!started)</p>
<p>        {</p>
<p>            started =1;</p>
<p>            head = root;</p>
<p>        }</p>
<p>        BSTtoDLL(root-&gt;right);</p>
<p>    }</p>
<p>    return head;</p>
<p>}</p>
<p>tree* FindMiddle(tree* head)</p>
<p>{</p>
<p>    tree* slowPtr=head,*fastPtr=head;</p>
<p>    while(fastPtr&amp;&amp;slowPtr)</p>
<p>    {</p>
<p>        fastPtr = fastPtr-&gt;right;</p>
<p>        if(!fastPtr)</p>
<p>            return slowPtr;</p>
<p>        fastPtr = fastPtr-&gt;right;</p>
<p>        if(!fastPtr)</p>
<p>            return slowPtr;</p>
<p>        slowPtr = slowPtr-&gt;right;</p>
<p>    }</p>
<p>    return slowPtr;</p>
<p>}</p>
<p>tree* DLLtoBST(tree *head)</p>
<p>{</p>
<p>    tree *temp,*q;</p>
<p>    if(!head||!head-&gt;right)</p>
<p>        return head;</p>
<p>    temp = FindMiddle(head);</p>
<p>    if(head==temp)</p>
<p>    {</p>
<p>        if(head-&gt;right!=NULL){</p>
<p>            head-&gt;left =NULL;</p>
<p>            head-&gt;right-&gt;left = NULL;</p>
<p>            return temp;</p>
<p>        }</p>
<p>        else</p>
<p>            return temp;</p>
<p>    }</p>
<p>    if(temp-&gt;left)</p>
<p>        temp-&gt;left-&gt;right = NULL;</p>
<p>    else</p>
<p>        return temp;</p>
<p>    q = temp-&gt;right;</p>
<p>    q-&gt;left = NULL;</p>
<p>    temp-&gt;left =NULL;</p>
<p>    temp-&gt;left = DLLtoBST(head);</p>
<p>    temp-&gt;right = DLLtoBST(q);</p>
<p>    return temp;</p>
<p>}</p>
<p>tree* makenode(int d)</p>
<p>{</p>
<p>    tree *t = new tree;</p>
<p>    t-&gt;data =d;</p>
<p>    t-&gt;left =NULL;</p>
<p>    t-&gt;right =NULL;</p>
<p>    t-&gt;parent =NULL;</p>
<p>    return t;</p>
<p>}</p>
<p>void tree_insert(tree *t,tree *z)</p>
<p>{</p>
<p>    tree *x,*y;</p>
<p>    y = NULL;</p>
<p>    x = t;</p>
<p>    while(x!=NULL)</p>
<p>    {</p>
<p>        y = x;</p>
<p>        if(x-&gt;data&gt;z-&gt;data)</p>
<p>            x = x-&gt;left;</p>
<p>        else</p>
<p>            x = x-&gt;right;</p>
<p>    }</p>
<p>    z-&gt;parent = y;</p>
<p>    if(z-&gt;datadata)</p>
<p>        y-&gt;left = z;</p>
<p>    else</p>
<p>        y-&gt;right =z;</p>
<p>}</p>
<p>void printDLL(tree *head)</p>
<p>{</p>
<p>    tree *ptr = head;</p>
<p>    tree *pr;</p>
<p>    while(ptr)</p>
<p>    {</p>
<p>        pr = ptr;</p>
<p>        cout&lt;data&lt;right;</p>
<p>    }</p>
<p>}</p>
<p>void preorder_walk(tree *t)</p>
<p>{</p>
<p>    if(t==NULL)</p>
<p>        return;</p>
<p>    cout&lt;data&lt;left);</p>
<p>    preorder_walk(t-&gt;right);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    int i,n,data;</p>
<p>    cin&gt;&gt;n;</p>
<p>    tree *t,*x,*root;</p>
<p>    cin&gt;&gt;data;</p>
<p>    root = makenode(data);</p>
<p>    tree *newNode;</p>
<p>    for(i=1;i&gt;data;</p>
<p>        newNode = makenode(data);</p>
<p>        tree_insert(root,newNode);</p>
<p>    }</p>
<p>    tree *head = BSTtoDLL(root);</p>
<p>    cout&lt;&lt;&quot;nBST to doubly link list :  &quot;;</p>
<p>    printDLL(head);</p>
<p>    cout&lt;&lt;endl&lt;&lt;&quot;Doubly link list to BST(preorder print) :  &quot;;</p>
<p>    root = DLLtoBST(head);</p>
<p>    preorder_walk(root);</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Apurvkagrawal</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-24919</link>
		<dc:creator><![CDATA[Apurvkagrawal]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 13:31:54 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-24919</guid>
		<description><![CDATA[I think there is a bug in this.
When you go to make the right subtree, it will change root to point to the next element and that will reflect in the callee function too.
After you return from this recursive call to right subtree, you cannot set root-&gt;next = sortedListToBSTRecur(head_ref, n-n/2-1); because root has already been incremented.
So I guess we need to store it a temp and then change that temp?]]></description>
		<content:encoded><![CDATA[<p>I think there is a bug in this.<br />
When you go to make the right subtree, it will change root to point to the next element and that will reflect in the callee function too.<br />
After you return from this recursive call to right subtree, you cannot set root->next = sortedListToBSTRecur(head_ref, n-n/2-1); because root has already been incremented.<br />
So I guess we need to store it a temp and then change that temp?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-17928</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Mon, 06 May 2013 11:01:38 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-17928</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ajinkya</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-16632</link>
		<dc:creator><![CDATA[ajinkya]]></dc:creator>
		<pubDate>Sun, 24 Mar 2013 07:11:53 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-16632</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;iostream&#062;
#include &#060;conio.h&#062;

using namespace std;

struct DLinkList
{
	int data ;
	DLinkList *pPrev;
	DLinkList *pNext;
};

DLinkList* FindMiddleElement( DLinkList *pStart , DLinkList **p1 , DLinkList **p2 )
{
	DLinkList *pTemp = pStart , *pFast = NULL ;

	if(NULL == pTemp)
	{
		return NULL;
	}
	else if( NULL == pTemp-&#062;pNext )
	{
		pTemp-&#062;pPrev = NULL;
		*p1 = NULL;
		*p2 = NULL;
		return pTemp;
	}
	else if( pTemp-&#062;pNext-&#062;pNext ==  NULL )
	{
		pTemp-&#062;pPrev = NULL;
		*p1 = NULL;
		*p2 = pTemp-&#062;pNext;
		pTemp-&#062;pNext-&#062;pPrev = NULL;
		pTemp-&#062;pNext = NULL;
		

	}
	else
	{
		pFast = pTemp;
		while( NULL != pFast )
		{
			pFast = pFast-&#062;pNext;

			if( NULL != pFast )
			{
				pTemp = pTemp-&#062;pNext;
				pFast = pFast-&#062;pNext;
			}
		}

		*p1 = pStart;
		*p2 = pTemp-&#062;pNext;
		pTemp-&#062;pPrev-&#062;pNext = NULL;
		pTemp-&#062;pNext = NULL;
		pTemp-&#062;pPrev = NULL;
		return pTemp;
	}
	
}

DLinkList* ConvertFromDoublytoTree(DLinkList* pHead1)
{
	DLinkList *pTemp = pHead1 , *p1 = NULL , *p2 = NULL , *p3 = NULL ;

	 p3 = FindMiddleElement(pTemp,&#038;p1,&#038;p2);
	
	 if(NULL == p3)
		 return NULL;
	
	 p3-&#062;pNext = ConvertFromDoublytoTree(p2);

	p3-&#062;pPrev = ConvertFromDoublytoTree(p1);

	return p3;
	_getch();
}

int main()
{
	DLinkList *pHead1 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead2 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead3 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead4 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead5 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead6 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead7 = (DLinkList*)calloc(1,sizeof(DLinkList));
	//-------------------------------------------------------------//

	pHead1-&#062;data = 10;
	pHead2-&#062;data = 20;
	pHead3-&#062;data = 30;
	pHead4-&#062;data = 40;
	pHead5-&#062;data = 50;
	pHead6-&#062;data = 60;
	pHead7-&#062;data = 70;
	//-------------------------------------------------------------//

	pHead1-&#062;pNext = pHead2;
	pHead2-&#062;pNext = pHead3;
	pHead3-&#062;pNext = pHead4;
	pHead4-&#062;pNext = pHead5;
	pHead5-&#062;pNext = pHead6;
	pHead6-&#062;pNext = pHead7;
	//-------------------------------------------------------------//

	pHead1-&#062;pPrev = NULL;
	pHead2-&#062;pPrev = pHead1;
	pHead3-&#062;pPrev = pHead2;
	pHead4-&#062;pPrev = pHead3;
	pHead5-&#062;pPrev = pHead4;
	pHead6-&#062;pPrev = pHead5;
	pHead7-&#062;pPrev = pHead6;
	//-------------------------------------------------------------//

	pHead1 = ConvertFromDoublytoTree(pHead1);


	_getch();
	return 0;
}


&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;conio.h&gt;

using namespace std;

struct DLinkList
{
	int data ;
	DLinkList *pPrev;
	DLinkList *pNext;
};

DLinkList* FindMiddleElement( DLinkList *pStart , DLinkList **p1 , DLinkList **p2 )
{
	DLinkList *pTemp = pStart , *pFast = NULL ;

	if(NULL == pTemp)
	{
		return NULL;
	}
	else if( NULL == pTemp-&gt;pNext )
	{
		pTemp-&gt;pPrev = NULL;
		*p1 = NULL;
		*p2 = NULL;
		return pTemp;
	}
	else if( pTemp-&gt;pNext-&gt;pNext ==  NULL )
	{
		pTemp-&gt;pPrev = NULL;
		*p1 = NULL;
		*p2 = pTemp-&gt;pNext;
		pTemp-&gt;pNext-&gt;pPrev = NULL;
		pTemp-&gt;pNext = NULL;
		

	}
	else
	{
		pFast = pTemp;
		while( NULL != pFast )
		{
			pFast = pFast-&gt;pNext;

			if( NULL != pFast )
			{
				pTemp = pTemp-&gt;pNext;
				pFast = pFast-&gt;pNext;
			}
		}

		*p1 = pStart;
		*p2 = pTemp-&gt;pNext;
		pTemp-&gt;pPrev-&gt;pNext = NULL;
		pTemp-&gt;pNext = NULL;
		pTemp-&gt;pPrev = NULL;
		return pTemp;
	}
	
}

DLinkList* ConvertFromDoublytoTree(DLinkList* pHead1)
{
	DLinkList *pTemp = pHead1 , *p1 = NULL , *p2 = NULL , *p3 = NULL ;

	 p3 = FindMiddleElement(pTemp,&amp;p1,&amp;p2);
	
	 if(NULL == p3)
		 return NULL;
	
	 p3-&gt;pNext = ConvertFromDoublytoTree(p2);

	p3-&gt;pPrev = ConvertFromDoublytoTree(p1);

	return p3;
	_getch();
}

int main()
{
	DLinkList *pHead1 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead2 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead3 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead4 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead5 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead6 = (DLinkList*)calloc(1,sizeof(DLinkList));
	DLinkList *pHead7 = (DLinkList*)calloc(1,sizeof(DLinkList));
	//-------------------------------------------------------------//

	pHead1-&gt;data = 10;
	pHead2-&gt;data = 20;
	pHead3-&gt;data = 30;
	pHead4-&gt;data = 40;
	pHead5-&gt;data = 50;
	pHead6-&gt;data = 60;
	pHead7-&gt;data = 70;
	//-------------------------------------------------------------//

	pHead1-&gt;pNext = pHead2;
	pHead2-&gt;pNext = pHead3;
	pHead3-&gt;pNext = pHead4;
	pHead4-&gt;pNext = pHead5;
	pHead5-&gt;pNext = pHead6;
	pHead6-&gt;pNext = pHead7;
	//-------------------------------------------------------------//

	pHead1-&gt;pPrev = NULL;
	pHead2-&gt;pPrev = pHead1;
	pHead3-&gt;pPrev = pHead2;
	pHead4-&gt;pPrev = pHead3;
	pHead5-&gt;pPrev = pHead4;
	pHead6-&gt;pPrev = pHead5;
	pHead7-&gt;pPrev = pHead6;
	//-------------------------------------------------------------//

	pHead1 = ConvertFromDoublytoTree(pHead1);


	_getch();
	return 0;
}


</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ayush</title>
		<link>http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/#comment-14880</link>
		<dc:creator><![CDATA[Ayush]]></dc:creator>
		<pubDate>Tue, 29 Jan 2013 06:41:53 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17629#comment-14880</guid>
		<description><![CDATA[I still dun knw how its O(n) and not O(n Logn) 

i mean in nlogn one u r finding the middle using some linear approach and then trying the recursion on left and right sub tree ryt?

so in O(n) u r finding the middle and then applying the recursion on the remaining left and right and then joining it with the root ....so where z the difference?]]></description>
		<content:encoded><![CDATA[<p>I still dun knw how its O(n) and not O(n Logn) </p>
<p>i mean in nlogn one u r finding the middle using some linear approach and then trying the recursion on left and right sub tree ryt?</p>
<p>so in O(n) u r finding the middle and then applying the recursion on the remaining left and right and then joining it with the root &#8230;.so where z the difference?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:06:43 -->

<!-- Compression = gzip -->