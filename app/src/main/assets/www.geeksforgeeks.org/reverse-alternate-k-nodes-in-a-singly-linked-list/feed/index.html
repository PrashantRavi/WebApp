<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Reverse alternate K nodes in a Singly Linked List</title>
	<atom:link href="http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-39037</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 12:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-39037</guid>
		<description><![CDATA[void kreverse(int k){

struct node* p=head,*q,*temp,*next;

struct node* prev=NULL;

int i;

if(knext==NULL)

 return;

q=p;

temp=p;

while(q){

 for(i=0;inext;

   p-&#062;next=prev;

   prev=p;

   p=next;

  }

 q=p;

 p=NULL;

 if(q-&#062;next==NULL)

   return;

 for(i=0;inext;

   q-&#062;next=p;

   p=q;

   q=next;

 }

 }

 temp-&#062;next=p;

 head=prev;

}



This is my algorithm]]></description>
		<content:encoded><![CDATA[<p>void kreverse(int k){</p>
<p>struct node* p=head,*q,*temp,*next;</p>
<p>struct node* prev=NULL;</p>
<p>int i;</p>
<p>if(knext==NULL)</p>
<p> return;</p>
<p>q=p;</p>
<p>temp=p;</p>
<p>while(q){</p>
<p> for(i=0;inext;</p>
<p>   p-&gt;next=prev;</p>
<p>   prev=p;</p>
<p>   p=next;</p>
<p>  }</p>
<p> q=p;</p>
<p> p=NULL;</p>
<p> if(q-&gt;next==NULL)</p>
<p>   return;</p>
<p> for(i=0;inext;</p>
<p>   q-&gt;next=p;</p>
<p>   p=q;</p>
<p>   q=next;</p>
<p> }</p>
<p> }</p>
<p> temp-&gt;next=p;</p>
<p> head=prev;</p>
<p>}</p>
<p>This is my algorithm</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neelabhsingh</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-38241</link>
		<dc:creator><![CDATA[neelabhsingh]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 19:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-38241</guid>
		<description><![CDATA[In the first method why we need second condition, there is no need of head..]]></description>
		<content:encoded><![CDATA[<p>In the first method why we need second condition, there is no need of head..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: The Big Idiot</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-37555</link>
		<dc:creator><![CDATA[The Big Idiot]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 18:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-37555</guid>
		<description><![CDATA[better code for the 2nd method
http://ideone.com/COMX8J]]></description>
		<content:encoded><![CDATA[<p>better code for the 2nd method<br />
<a href="http://ideone.com/COMX8J" rel="nofollow">http://ideone.com/COMX8J</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: RACHIT SAXENA</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-37453</link>
		<dc:creator><![CDATA[RACHIT SAXENA]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 18:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-37453</guid>
		<description><![CDATA[iterative program for above concept =D
:)
http://ideone.com/0Hq59W]]></description>
		<content:encoded><![CDATA[<p>iterative program for above concept =D<br />
ðŸ™‚<br />
<a href="http://ideone.com/0Hq59W" rel="nofollow">http://ideone.com/0Hq59W</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-37452</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 18:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-37452</guid>
		<description><![CDATA[one more iterative small program :)

#include

struct list

{

    int data;

    struct list *next;

};

void insert(struct list **root,int x)

{

    struct list *temp=(struct list *)malloc(sizeof(struct list)),*current;

    temp-&#062;data=x;

    temp-&#062;next=NULL;

    if(*root==NULL)

    {

        *root=temp;

        return;

    }

    current=*root;

    while(current-&#062;next!=NULL)

    current=current-&#062;next;

    current-&#062;next=temp;

}

void print(struct list *root)

{

    struct list *temp=root;

    while(temp!=NULL)

    {

        printf(&quot;%d &quot;,temp-&#062;data);

        temp=temp-&#062;next;

    }

    printf(&quot;n&quot;);

}

void reverse(struct list **root,int k)

{

    int count=0;

    if(*root==NULL)

        return;

    struct list *temp=*root,*prev=NULL,*current,*last;

    while(temp!=NULL &#038;&#038; count!=k)

    {

        count++;

        current=temp-&#062;next;

        temp-&#062;next=prev;

        prev=temp;

        temp=current;

    }

    last=*root;
 // used this to store the first element of original list so as to 
//continue for further reversals

    *root=prev;

    if(temp==NULL)

        return;

    count=0;

    //temp=current;

    prev=NULL;

    struct list *last1; 
//used to remember the very first element in each 
//division of k as we have to link it to next one but it is pointing to null.

    while(temp!=NULL)

    {

        count++;

        if(countnext=temp;

            temp=temp-&#062;next;

            if(count==k-1)

                last=temp;

            continue;

        }

        current=temp-&#062;next;

        temp-&#062;next=prev;

        prev=temp;

        if(count==k+1)

            last1=prev;

        temp=current;

        if(count==2*k)

        {

            count=0;

            last-&#062;next=prev;

            last=last1;

            prev=NULL;

        }

    }

    if(count!=k)

        last-&#062;next=prev;

}

int main()

{

    int k=2;

    struct list *root=NULL;

    insert(&#038;root,1);

    insert(&#038;root,2);

    insert(&#038;root,3);

    insert(&#038;root,4);

    insert(&#038;root,5);

    insert(&#038;root,6);

    insert(&#038;root,7);

    insert(&#038;root,8);

    insert(&#038;root,9);

    reverse(&#038;root,k);

    print(root);

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>one more iterative small program ðŸ™‚</p>
<p>#include</p>
<p>struct list</p>
<p>{</p>
<p>    int data;</p>
<p>    struct list *next;</p>
<p>};</p>
<p>void insert(struct list **root,int x)</p>
<p>{</p>
<p>    struct list *temp=(struct list *)malloc(sizeof(struct list)),*current;</p>
<p>    temp-&gt;data=x;</p>
<p>    temp-&gt;next=NULL;</p>
<p>    if(*root==NULL)</p>
<p>    {</p>
<p>        *root=temp;</p>
<p>        return;</p>
<p>    }</p>
<p>    current=*root;</p>
<p>    while(current-&gt;next!=NULL)</p>
<p>    current=current-&gt;next;</p>
<p>    current-&gt;next=temp;</p>
<p>}</p>
<p>void print(struct list *root)</p>
<p>{</p>
<p>    struct list *temp=root;</p>
<p>    while(temp!=NULL)</p>
<p>    {</p>
<p>        printf(&#8220;%d &#8220;,temp-&gt;data);</p>
<p>        temp=temp-&gt;next;</p>
<p>    }</p>
<p>    printf(&#8220;n&#8221;);</p>
<p>}</p>
<p>void reverse(struct list **root,int k)</p>
<p>{</p>
<p>    int count=0;</p>
<p>    if(*root==NULL)</p>
<p>        return;</p>
<p>    struct list *temp=*root,*prev=NULL,*current,*last;</p>
<p>    while(temp!=NULL &amp;&amp; count!=k)</p>
<p>    {</p>
<p>        count++;</p>
<p>        current=temp-&gt;next;</p>
<p>        temp-&gt;next=prev;</p>
<p>        prev=temp;</p>
<p>        temp=current;</p>
<p>    }</p>
<p>    last=*root;<br />
 // used this to store the first element of original list so as to<br />
//continue for further reversals</p>
<p>    *root=prev;</p>
<p>    if(temp==NULL)</p>
<p>        return;</p>
<p>    count=0;</p>
<p>    //temp=current;</p>
<p>    prev=NULL;</p>
<p>    struct list *last1;<br />
//used to remember the very first element in each<br />
//division of k as we have to link it to next one but it is pointing to null.</p>
<p>    while(temp!=NULL)</p>
<p>    {</p>
<p>        count++;</p>
<p>        if(countnext=temp;</p>
<p>            temp=temp-&gt;next;</p>
<p>            if(count==k-1)</p>
<p>                last=temp;</p>
<p>            continue;</p>
<p>        }</p>
<p>        current=temp-&gt;next;</p>
<p>        temp-&gt;next=prev;</p>
<p>        prev=temp;</p>
<p>        if(count==k+1)</p>
<p>            last1=prev;</p>
<p>        temp=current;</p>
<p>        if(count==2*k)</p>
<p>        {</p>
<p>            count=0;</p>
<p>            last-&gt;next=prev;</p>
<p>            last=last1;</p>
<p>            prev=NULL;</p>
<p>        }</p>
<p>    }</p>
<p>    if(count!=k)</p>
<p>        last-&gt;next=prev;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    int k=2;</p>
<p>    struct list *root=NULL;</p>
<p>    insert(&amp;root,1);</p>
<p>    insert(&amp;root,2);</p>
<p>    insert(&amp;root,3);</p>
<p>    insert(&amp;root,4);</p>
<p>    insert(&amp;root,5);</p>
<p>    insert(&amp;root,6);</p>
<p>    insert(&amp;root,7);</p>
<p>    insert(&amp;root,8);</p>
<p>    insert(&amp;root,9);</p>
<p>    reverse(&amp;root,k);</p>
<p>    print(root);</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anisha Malik</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-36564</link>
		<dc:creator><![CDATA[Anisha Malik]]></dc:creator>
		<pubDate>Sat, 24 May 2014 06:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-36564</guid>
		<description><![CDATA[Easy to understand and efficient solution...
Keep up the good work (y)]]></description>
		<content:encoded><![CDATA[<p>Easy to understand and efficient solution&#8230;<br />
Keep up the good work (y)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anisha Malik</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-36563</link>
		<dc:creator><![CDATA[Anisha Malik]]></dc:creator>
		<pubDate>Sat, 24 May 2014 05:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-36563</guid>
		<description><![CDATA[Easy to understand and efficient solution...
Keep up the good work (y)]]></description>
		<content:encoded><![CDATA[<p>Easy to understand and efficient solution&#8230;<br />
Keep up the good work (y)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gautam Goyal</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-36562</link>
		<dc:creator><![CDATA[Gautam Goyal]]></dc:creator>
		<pubDate>Sat, 24 May 2014 05:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-36562</guid>
		<description><![CDATA[Here&#039;s the iterative method, working for all cases: 
Step1: Reverse k nodes. with original head saved 
Step2: Update final-head, should be done once, also point original head&#039;s next to the first element of next k nodes. 
Step3: Traverse next k nodes 
Step4: Next of the last in these k nodes should point to tail of the next k nodes, update head to the first of these next k nodes.

http://ideone.com/hHDHV6]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s the iterative method, working for all cases:<br />
Step1: Reverse k nodes. with original head saved<br />
Step2: Update final-head, should be done once, also point original head&#8217;s next to the first element of next k nodes.<br />
Step3: Traverse next k nodes<br />
Step4: Next of the last in these k nodes should point to tail of the next k nodes, update head to the first of these next k nodes.</p>
<p><a href="http://ideone.com/hHDHV6" rel="nofollow">http://ideone.com/hHDHV6</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-36561</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 24 May 2014 04:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-36561</guid>
		<description><![CDATA[Here&#039;s the iterative method, working for all cases:
 Step1: Reverse k nodes. with original head saved 
Step2: Update final-head, should be done once, also point original head&#039;s next to the first element of next k nodes. 
Step3: 
Travel next k nodes 
Step4: Next of the last in these k nodes should point to tail of the next k nodes, update head to the first of these next k nodes.

typedef struct node* Link;

Link getTail(Link head,int k){
	if(head == NULL)
		return NULL;
	int count = 0;
	Link temp = head;
	while(count next != NULL){
		temp= temp-&#062;next;
		count++;
	}
	printf(&quot;%sn&quot;, temp-&#062;d-&#062;s);
	return temp;
}



Link alternateKReverse(Link head, int k){
	if(head == NULL &#124;&#124; head-&#062;next == NULL &#124;&#124; k ==1&#124;&#124;k==0 )
		return head;


	Link curr,prev,next,temp,finalH=NULL;
	int count = 0;
	prev = NULL;
	int times = 0;
	while(head != NULL){
		curr = head;
		prev = NULL;
		if(curr-&#062;next == NULL)
			break;
		while(curr != NULL &#038;&#038; countnext;
			curr-&#062;next = prev;
			prev = curr;
			curr  = next;
			count++;
		}
		head-&#062;next = curr;
		if(!times){
			finalH = prev;
			times++;
		}
		while(curr!= NULL &#038;&#038; countnext;
			count++;
		}
		
		if(curr != NULL){
			temp = curr-&#062;next;
			curr-&#062;next = getTail(curr-&#062;next,k);
			//printf(&quot;%sn&quot;, curr-&#062;next-&#062;d-&#062;s);
			head = temp;
			count = 0;
		}
		else head = NULL;
		
		

	}
	return finalH;
}]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s the iterative method, working for all cases:<br />
 Step1: Reverse k nodes. with original head saved<br />
Step2: Update final-head, should be done once, also point original head&#8217;s next to the first element of next k nodes.<br />
Step3:<br />
Travel next k nodes<br />
Step4: Next of the last in these k nodes should point to tail of the next k nodes, update head to the first of these next k nodes.</p>
<p>typedef struct node* Link;</p>
<p>Link getTail(Link head,int k){<br />
	if(head == NULL)<br />
		return NULL;<br />
	int count = 0;<br />
	Link temp = head;<br />
	while(count next != NULL){<br />
		temp= temp-&gt;next;<br />
		count++;<br />
	}<br />
	printf(&#8220;%sn&#8221;, temp-&gt;d-&gt;s);<br />
	return temp;<br />
}</p>
<p>Link alternateKReverse(Link head, int k){<br />
	if(head == NULL || head-&gt;next == NULL || k ==1||k==0 )<br />
		return head;</p>
<p>	Link curr,prev,next,temp,finalH=NULL;<br />
	int count = 0;<br />
	prev = NULL;<br />
	int times = 0;<br />
	while(head != NULL){<br />
		curr = head;<br />
		prev = NULL;<br />
		if(curr-&gt;next == NULL)<br />
			break;<br />
		while(curr != NULL &amp;&amp; countnext;<br />
			curr-&gt;next = prev;<br />
			prev = curr;<br />
			curr  = next;<br />
			count++;<br />
		}<br />
		head-&gt;next = curr;<br />
		if(!times){<br />
			finalH = prev;<br />
			times++;<br />
		}<br />
		while(curr!= NULL &amp;&amp; countnext;<br />
			count++;<br />
		}</p>
<p>		if(curr != NULL){<br />
			temp = curr-&gt;next;<br />
			curr-&gt;next = getTail(curr-&gt;next,k);<br />
			//printf(&#8220;%sn&#8221;, curr-&gt;next-&gt;d-&gt;s);<br />
			head = temp;<br />
			count = 0;<br />
		}<br />
		else head = NULL;</p>
<p>	}<br />
	return finalH;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-32339</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Sat, 08 Feb 2014 11:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-32339</guid>
		<description><![CDATA[can refer to below code for above question

http://ideone.com/vEfXwP]]></description>
		<content:encoded><![CDATA[<p>can refer to below code for above question</p>
<p><a href="http://ideone.com/vEfXwP" rel="nofollow">http://ideone.com/vEfXwP</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vinod</title>
		<link>http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/#comment-30300</link>
		<dc:creator><![CDATA[vinod]]></dc:creator>
		<pubDate>Sun, 01 Dec 2013 17:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11371#comment-30300</guid>
		<description><![CDATA[We can do it in O(n) also by just taking a stack of size K and storing 
values of k nodes in stack than once stack is full then replace the 
values of those K nodes in linked list by the values in stack by popping
 out one by one. After then repeat the same for the next K nodes until 
we hit NULL...!!]]></description>
		<content:encoded><![CDATA[<p>We can do it in O(n) also by just taking a stack of size K and storing<br />
values of k nodes in stack than once stack is full then replace the<br />
values of those K nodes in linked list by the values in stack by popping<br />
 out one by one. After then repeat the same for the next K nodes until<br />
we hit NULL&#8230;!!</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:14:47 -->

<!-- Compression = gzip -->