<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Radix Sort</title>
	<atom:link href="http://www.geeksforgeeks.org/radix-sort/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/radix-sort/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-39910</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 18:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-39910</guid>
		<description><![CDATA[base of radix sort should be no of digits of largest element.. ??
then why it is written that if base is n (no of elements).... then  complexity would be O(n).... confused]]></description>
		<content:encoded><![CDATA[<p>base of radix sort should be no of digits of largest element.. ??<br />
then why it is written that if base is n (no of elements)&#8230;. then  complexity would be O(n)&#8230;. confused</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saanvi</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-39611</link>
		<dc:creator><![CDATA[saanvi]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 08:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-39611</guid>
		<description><![CDATA[thanks...got it :)]]></description>
		<content:encoded><![CDATA[<p>thanks&#8230;got it ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gbrocks</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-39483</link>
		<dc:creator><![CDATA[gbrocks]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 18:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-39483</guid>
		<description><![CDATA[if two numbers differ by only last digit, let&#039;s say 182 and 186 then after encountering last digit operation, these two digits should remain in ascending order (182 and then 186).

Now if you use loop from 0 to n-1 then 182 number will come first and it will be stored as some index let&#039;s say x. Then after 186 will come and will be stored at x-1 index which is wrong. Since we are using count-- trick, higher number should be encountered first.]]></description>
		<content:encoded><![CDATA[<p>if two numbers differ by only last digit, let&#8217;s say 182 and 186 then after encountering last digit operation, these two digits should remain in ascending order (182 and then 186).</p>
<p>Now if you use loop from 0 to n-1 then 182 number will come first and it will be stored as some index let&#8217;s say x. Then after 186 will come and will be stored at x-1 index which is wrong. Since we are using count&#8211; trick, higher number should be encountered first.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saanvi</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-38003</link>
		<dc:creator><![CDATA[saanvi]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 12:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-38003</guid>
		<description><![CDATA[for (i = n - 1; i &#062;= 0; i--)
    {
        output[count[ (arr[i]/exp)%10 ] - 1] = arr[i];
        count[ (arr[i]/exp)%10 ]--;
    }
please explain why a loop from i=0 to n-1 is not working instead of above loop..]]></description>
		<content:encoded><![CDATA[<p>for (i = n &#8211; 1; i &gt;= 0; i&#8211;)<br />
    {<br />
        output[count[ (arr[i]/exp)%10 ] &#8211; 1] = arr[i];<br />
        count[ (arr[i]/exp)%10 ]&#8211;;<br />
    }<br />
please explain why a loop from i=0 to n-1 is not working instead of above loop..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ERROR</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-34532</link>
		<dc:creator><![CDATA[ERROR]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 19:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-34532</guid>
		<description><![CDATA[for (i = n - 1; i &#062;= 0; i--)
{
     // YOU ARE RUNNNING OUT OF ARRAY ... YOU KNOW
     output[count[ (arr[i]/exp)%10 ] - 1] = arr[i];
     count[ (arr[i]/exp)%10 ]--;
}


YOU wrote it badli]]></description>
		<content:encoded><![CDATA[<p>for (i = n &#8211; 1; i &gt;= 0; i&#8211;)<br />
{<br />
     // YOU ARE RUNNNING OUT OF ARRAY &#8230; YOU KNOW<br />
     output[count[ (arr[i]/exp)%10 ] &#8211; 1] = arr[i];<br />
     count[ (arr[i]/exp)%10 ]&#8211;;<br />
}</p>
<p>YOU wrote it badli</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: zzer</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-34491</link>
		<dc:creator><![CDATA[zzer]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 07:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-34491</guid>
		<description><![CDATA[here is a general version of radix sort, which you can choose any base you like

#include

#include

using namespace std;

const int base = 16; 

int get_max(int arr[],int n)

{

	int max = arr[0];

	for(int i = 1; i &#060; n; i++)

		if(max &#060; arr[i])

			max = arr[i];

	return max;

}

void count_sort(int arr[],int n,int exp,int output[])

{

	memset(output,0,sizeof(int)*n);

	int count[base]={0};

	for(int i = 0; i &#060; n;i++)

		count[(arr[i]/exp)%base]++;

	for(int i = 1; i = 0; i--)

	{

		output[count[(arr[i]/exp)%base]-1] = arr[i];

		count[(arr[i]/exp)%base]--;

	}

	for(int i = 0; i  0; exp*= base)

		count_sort(arr,n,exp,output);

	delete []output;

}

int main()

{

	srand(time(0));

	const int n = 30;

	int arr[n];

	for(int i = 0; i &#060; n; i++)

		arr[i] = rand()%500;

	

	for(int i = 0; i &#060; n; i++)

		cout &#060;&#060; arr[i] &#060;&#060; &#034; &#034;;

	cout &#060;&#060; endl;

	radix_sort(arr,n);

	for(int i = 0; i &#060; n; i++)

		cout &#060;&#060; arr[i] &#060;&#060; &#034; &#034;;

	cout &#060;&#060; endl;

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>here is a general version of radix sort, which you can choose any base you like</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>const int base = 16; </p>
<p>int get_max(int arr[],int n)</p>
<p>{</p>
<p>	int max = arr[0];</p>
<p>	for(int i = 1; i &lt; n; i++)</p>
<p>		if(max &lt; arr[i])</p>
<p>			max = arr[i];</p>
<p>	return max;</p>
<p>}</p>
<p>void count_sort(int arr[],int n,int exp,int output[])</p>
<p>{</p>
<p>	memset(output,0,sizeof(int)*n);</p>
<p>	int count[base]={0};</p>
<p>	for(int i = 0; i &lt; n;i++)</p>
<p>		count[(arr[i]/exp)%base]++;</p>
<p>	for(int i = 1; i = 0; i&#8211;)</p>
<p>	{</p>
<p>		output[count[(arr[i]/exp)%base]-1] = arr[i];</p>
<p>		count[(arr[i]/exp)%base]&#8211;;</p>
<p>	}</p>
<p>	for(int i = 0; i  0; exp*= base)</p>
<p>		count_sort(arr,n,exp,output);</p>
<p>	delete []output;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>	srand(time(0));</p>
<p>	const int n = 30;</p>
<p>	int arr[n];</p>
<p>	for(int i = 0; i &lt; n; i++)</p>
<p>		arr[i] = rand()%500;</p>
<p>	for(int i = 0; i &lt; n; i++)</p>
<p>		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</p>
<p>	cout &lt;&lt; endl;</p>
<p>	radix_sort(arr,n);</p>
<p>	for(int i = 0; i &lt; n; i++)</p>
<p>		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</p>
<p>	cout &lt;&lt; endl;</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hitesh</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-33642</link>
		<dc:creator><![CDATA[Hitesh]]></dc:creator>
		<pubDate>Tue, 18 Mar 2014 16:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-33642</guid>
		<description><![CDATA[int Maxdigits=3;
It&#039;s NOT a good practice.
Your code should work for all the maximum possible input without any change.]]></description>
		<content:encoded><![CDATA[<p>int Maxdigits=3;<br />
It&#8217;s NOT a good practice.<br />
Your code should work for all the maximum possible input without any change.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hitesh</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-33641</link>
		<dc:creator><![CDATA[Hitesh]]></dc:creator>
		<pubDate>Tue, 18 Mar 2014 16:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-33641</guid>
		<description><![CDATA[Dude! don&#039;t use built-in constructs like hashmap, etc in learning the basic algorithms!]]></description>
		<content:encoded><![CDATA[<p>Dude! don&#8217;t use built-in constructs like hashmap, etc in learning the basic algorithms!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sparsh</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-32286</link>
		<dc:creator><![CDATA[Sparsh]]></dc:creator>
		<pubDate>Thu, 06 Feb 2014 20:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-32286</guid>
		<description><![CDATA[I&#039;m not sure if that has been said, but I think one clarification to add is that when describing the runtime of radix sort, it should be noted that the constant c in n^c should be O(1) ( although I understand a constant, c, could be taken for granted to be O(1) )

A nice explanation of radix sort is given here:
http://courses.csail.mit.edu/6.006/spring11/exams/notes2-1.pdf]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not sure if that has been said, but I think one clarification to add is that when describing the runtime of radix sort, it should be noted that the constant c in n^c should be O(1) ( although I understand a constant, c, could be taken for granted to be O(1) )</p>
<p>A nice explanation of radix sort is given here:<br />
<a href="http://courses.csail.mit.edu/6.006/spring11/exams/notes2-1.pdf" rel="nofollow">http://courses.csail.mit.edu/6.006/spring11/exams/notes2-1.pdf</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prasaanth</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-31921</link>
		<dc:creator><![CDATA[Prasaanth]]></dc:creator>
		<pubDate>Tue, 28 Jan 2014 06:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-31921</guid>
		<description><![CDATA[http://pastie.org/8674341#8,11


Friends , please find my recursive java implementation above and give your comments and analysis at prasaanth07@gmail.com :)]]></description>
		<content:encoded><![CDATA[<p><a href="http://pastie.org/8674341#8,11" rel="nofollow">http://pastie.org/8674341#8,11</a></p>
<p>Friends , please find my recursive java implementation above and give your comments and analysis at <a href="mailto:prasaanth07@gmail.com">prasaanth07@gmail.com</a> ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guru</title>
		<link>http://www.geeksforgeeks.org/radix-sort/#comment-31041</link>
		<dc:creator><![CDATA[Guru]]></dc:creator>
		<pubDate>Thu, 26 Dec 2013 15:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=122061#comment-31041</guid>
		<description><![CDATA[#include
#include
#include
#include
using namespace std;
#define BASE 10

int arr[] = {23, 145, 11, 90, 115, 39, 13, 256, 47, 71};

void printArray(int arr[], int n)
{
    for(int i=0; i &#060; n; i++)
    {
        cout&#060;&#060;arr[i]&#060;&#060;&#034; &#034;;
    }
    cout&#060;&#060;endl;
}

void radixsort(int arr[], int n)
{
    int largest = INT_MIN;
    int digits = 0;
    for (int i=0; i largest)
            largest = arr[i];
    }

    do {
        digits++;
    }while(largest/=10);

    vector bucket;
    vector&#060; vector &#062; v;
    for (int i = 0; i &#060; BASE; i++) {
        v.push_back(vector()); // Add an empty row
    }

    for (int j=0;j &#060; n; j++)
    {
        bucket.push_back(arr[j]);
    }
    int divisor  = 1;
    int index;
    while(digits)
    {
        for (int j=0; j&#060;n; j++)
        {
            index = (bucket[j]/divisor)%10;
            v[index].push_back(bucket[j]);
        }
        bucket.clear();
        for (int i=0; i &#060; v.size(); i++)
        {
            for (int j=0; j &#060; v[i].size(); j++)
            {
                bucket.push_back(v[i][j]);
            }
            v[i].clear();
        }
        cout&#060;&#060;endl;
        for (int k=0; k &#060; bucket.size(); k++)
        {
                cout&#060;&#060;bucket[k]&#060;&#060;&#034; &#034;;
        }
        cout&#060;&#060;endl;
        digits--;
        divisor *= BASE;
    }
}

int main()
{
    int n = sizeof(arr)/sizeof(arr[0]);
    printArray(arr, n);
    radixsort(arr, n);
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
#include<br />
using namespace std;<br />
#define BASE 10</p>
<p>int arr[] = {23, 145, 11, 90, 115, 39, 13, 256, 47, 71};</p>
<p>void printArray(int arr[], int n)<br />
{<br />
    for(int i=0; i &lt; n; i++)<br />
    {<br />
        cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;<br />
    }<br />
    cout&lt;&lt;endl;<br />
}</p>
<p>void radixsort(int arr[], int n)<br />
{<br />
    int largest = INT_MIN;<br />
    int digits = 0;<br />
    for (int i=0; i largest)<br />
            largest = arr[i];<br />
    }</p>
<p>    do {<br />
        digits++;<br />
    }while(largest/=10);</p>
<p>    vector bucket;<br />
    vector&lt; vector &gt; v;<br />
    for (int i = 0; i &lt; BASE; i++) {<br />
        v.push_back(vector()); // Add an empty row<br />
    }</p>
<p>    for (int j=0;j &lt; n; j++)<br />
    {<br />
        bucket.push_back(arr[j]);<br />
    }<br />
    int divisor  = 1;<br />
    int index;<br />
    while(digits)<br />
    {<br />
        for (int j=0; j&lt;n; j++)<br />
        {<br />
            index = (bucket[j]/divisor)%10;<br />
            v[index].push_back(bucket[j]);<br />
        }<br />
        bucket.clear();<br />
        for (int i=0; i &lt; v.size(); i++)<br />
        {<br />
            for (int j=0; j &lt; v[i].size(); j++)<br />
            {<br />
                bucket.push_back(v[i][j]);<br />
            }<br />
            v[i].clear();<br />
        }<br />
        cout&lt;&lt;endl;<br />
        for (int k=0; k &lt; bucket.size(); k++)<br />
        {<br />
                cout&lt;&lt;bucket[k]&lt;&lt;&quot; &quot;;<br />
        }<br />
        cout&lt;&lt;endl;<br />
        digits&#8211;;<br />
        divisor *= BASE;<br />
    }<br />
}</p>
<p>int main()<br />
{<br />
    int n = sizeof(arr)/sizeof(arr[0]);<br />
    printArray(arr, n);<br />
    radixsort(arr, n);<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.054 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 12:26:23 -->

<!-- Compression = gzip -->