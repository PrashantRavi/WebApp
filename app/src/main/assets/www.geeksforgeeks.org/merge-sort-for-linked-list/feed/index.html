<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Merge Sort for Linked Lists</title>
	<atom:link href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-37517</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 15:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-37517</guid>
		<description><![CDATA[https://ideone.com/eYfGWE]]></description>
		<content:encoded><![CDATA[<p><a href="https://ideone.com/eYfGWE" rel="nofollow">https://ideone.com/eYfGWE</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-36549</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Fri, 23 May 2014 17:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-36549</guid>
		<description><![CDATA[Partition? You mean the split? &quot;number of partitions at each level i is equal to 2^i&quot; - wrong. There is a single split per level of recursion. 

I assume you know traditional merge sort on arrays. The recurrence relation is T(n) = 2T(n/2) + O(n). 2T(n/2) corresponding to the 2 recursive calls &#038; O(n) time for the merge operation that happens in each level.

Here, we have a split which takes O(n) time, 2 recursive calls on half size and a merge which takes O(n). So in total it is again T(n) = 2T(n/2) + O(n) giving us the same time complexity as merge sort.]]></description>
		<content:encoded><![CDATA[<p>Partition? You mean the split? &#8220;number of partitions at each level i is equal to 2^i&#8221; &#8211; wrong. There is a single split per level of recursion. </p>
<p>I assume you know traditional merge sort on arrays. The recurrence relation is T(n) = 2T(n/2) + O(n). 2T(n/2) corresponding to the 2 recursive calls &amp; O(n) time for the merge operation that happens in each level.</p>
<p>Here, we have a split which takes O(n) time, 2 recursive calls on half size and a merge which takes O(n). So in total it is again T(n) = 2T(n/2) + O(n) giving us the same time complexity as merge sort.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gonecase</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-36544</link>
		<dc:creator><![CDATA[gonecase]]></dc:creator>
		<pubDate>Fri, 23 May 2014 16:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-36544</guid>
		<description><![CDATA[look, you divide the list(be it array or linked list), log n times(refer to recursion tree), during each partition, given a list of size i=n, n/2, ..., n/2^k, we would take O(i) time to partition the original/already divided list..since sigma O(i)= O(n),we can say , we take O(n) time to partition for any given call of partition(sloppily), so given the time taken to perform a single partition, the question now arises as to how many partitions are going to happen all in all, we observe that the number of partitions at each level i is equal to 2^i , so summing 2^0+2^1+....+2^(lg n ) gives us [2(lg n)-1] as the sum which is nothing but (n-1) on simplification , implying that we call partition n-1, (let&#039;s approximate it to n), times so , the complexity is atleast big omega of n^2..
if i am wrong, please let me know where...thanks:)]]></description>
		<content:encoded><![CDATA[<p>look, you divide the list(be it array or linked list), log n times(refer to recursion tree), during each partition, given a list of size i=n, n/2, &#8230;, n/2^k, we would take O(i) time to partition the original/already divided list..since sigma O(i)= O(n),we can say , we take O(n) time to partition for any given call of partition(sloppily), so given the time taken to perform a single partition, the question now arises as to how many partitions are going to happen all in all, we observe that the number of partitions at each level i is equal to 2^i , so summing 2^0+2^1+&#8230;.+2^(lg n ) gives us [2(lg n)-1] as the sum which is nothing but (n-1) on simplification , implying that we call partition n-1, (let&#8217;s approximate it to n), times so , the complexity is atleast big omega of n^2..<br />
if i am wrong, please let me know where&#8230;thanks:)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-36429</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Wed, 21 May 2014 23:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-36429</guid>
		<description><![CDATA[It is order of O(nlogn). Each recursive call does O(n) work since regardless of whether midpoint-finding is O(1) or O(n), merge() will take O(n) time. So the recurrence relation is the same as that in standard merge sort.]]></description>
		<content:encoded><![CDATA[<p>It is order of O(nlogn). Each recursive call does O(n) work since regardless of whether midpoint-finding is O(1) or O(n), merge() will take O(n) time. So the recurrence relation is the same as that in standard merge sort.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Atreyee</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-35733</link>
		<dc:creator><![CDATA[Atreyee]]></dc:creator>
		<pubDate>Tue, 06 May 2014 19:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-35733</guid>
		<description><![CDATA[slow is the point before midpoint, so for the first list slow is the last node and for last node, next has to be set to NULL so as to have a check condition for last node]]></description>
		<content:encoded><![CDATA[<p>slow is the point before midpoint, so for the first list slow is the last node and for last node, next has to be set to NULL so as to have a check condition for last node</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-35125</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Fri, 25 Apr 2014 18:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-35125</guid>
		<description><![CDATA[Can go through below link for code : -

http://ideone.com/WcokHu]]></description>
		<content:encoded><![CDATA[<p>Can go through below link for code : &#8211;</p>
<p><a href="http://ideone.com/WcokHu" rel="nofollow">http://ideone.com/WcokHu</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aditya Chhilwar</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-34210</link>
		<dc:creator><![CDATA[Aditya Chhilwar]]></dc:creator>
		<pubDate>Wed, 02 Apr 2014 17:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-34210</guid>
		<description><![CDATA[FrontBackSplit will be called for every partition. For n elements for first call to this function will traverse n nodes (order of n), for second it will be called two times n/2+n/2 = n and so on. How the time complexity is order of nlogn?]]></description>
		<content:encoded><![CDATA[<p>FrontBackSplit will be called for every partition. For n elements for first call to this function will traverse n nodes (order of n), for second it will be called two times n/2+n/2 = n and so on. How the time complexity is order of nlogn?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aditya Chhilwar</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-34211</link>
		<dc:creator><![CDATA[Aditya Chhilwar]]></dc:creator>
		<pubDate>Wed, 02 Apr 2014 17:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-34211</guid>
		<description><![CDATA[FrontBackSplit will be called for every partition. For n elements for first call to this function will traverse n nodes (order of n), for second it will be called two times n/2+n/2 = n and so on. How the time complexity is order of nlogn?]]></description>
		<content:encoded><![CDATA[<p>FrontBackSplit will be called for every partition. For n elements for first call to this function will traverse n nodes (order of n), for second it will be called two times n/2+n/2 = n and so on. How the time complexity is order of nlogn?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: guest11</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-34136</link>
		<dc:creator><![CDATA[guest11]]></dc:creator>
		<pubDate>Tue, 01 Apr 2014 00:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-34136</guid>
		<description><![CDATA[can anyone explain why slow-&#062;next has been set to null]]></description>
		<content:encoded><![CDATA[<p>can anyone explain why slow-&gt;next has been set to null</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ankit</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-32620</link>
		<dc:creator><![CDATA[Ankit]]></dc:creator>
		<pubDate>Sun, 16 Feb 2014 20:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-32620</guid>
		<description><![CDATA[better understandable code ... 
&lt;code&gt;
#include
#include

struct node
{
    int data;
    struct node *next;
};

struct node * createNode(int value)
{
    struct node * N=(struct node *)malloc(sizeof(struct node));
    N-&#062;next=NULL;
    N-&#062;data=value;
    return N;
};

struct node *FindMid(struct node *head) // auxilary method required
{
    struct node *p=head,*q=head;
    if(p&#038;&#038;p-&#062;next)
    {
        p=p-&#062;next-&#062;next;
        q=q-&#062;next;
    }
    return q;
};
// auxilary method required
struct node * mergeSortedList(struct node *a,struct node *b) 
{
    if(!a)
        return b;
    if(!b)
        return a;
    struct node *result=NULL;
    if(a-&#062;data&lt;b&gt;data)
    {
        result=a;
        result-&#062;next=mergeSortedList(a-&#062;next,b);
    }
    else
    {
        result=b;
        result-&#062;next=mergeSortedList(a,b-&#062;next);
    }
    return result;
};

struct node *mergeSort(struct node *head)
{
    if(!head)
        return NULL;
    if(head-&#062;next==NULL)
        return head;

    else if(head-&#062;next-&#062;next==NULL)
    {
        struct node *p=head;
        if(p-&#062;data&#062;p-&#062;next-&#062;data)
        {
            head=head-&#062;next;
            p-&#062;next=NULL;
            head-&#062;next=p;
            return head;
        }
        else return head;

    }
    else
    {
        struct node *mid=FindMid(head);
        struct node *SHalf=mid-&#062;next;
        mid-&#062;next=NULL;
        struct node *head1=mergeSort(head);
        struct node *head2=mergeSort(SHalf);

        return mergeSortedList(head1,head2);
    }

};

void main()
{
    struct node *head=createNode(25);
    head-&#062;next=createNode(10);
    head-&#062;next-&#062;next=createNode(15);
    head-&#062;next-&#062;next-&#062;next=createNode(30);
    head-&#062;next-&#062;next-&#062;next-&#062;next=createNode(5);
    head-&#062;next-&#062;next-&#062;next-&#062;next-&#062;next=NULL;
    printf(&quot;LINKED LIST TO BE SORTEDnn&quot;);
    struct node *a=head;
    while(a!=NULL)
    {
        printf(&quot;%d--&#062;&quot;,a-&#062;data);
        a=a-&#062;next;
    }

    a=mergeSort(head);
    printf(&quot;nnSORTED LINKED LIST ISnn&quot;);
    while(a!=NULL)
    {
        printf(&quot;%d--&#062;&quot;,a-&#062;data);
        a=a-&#062;next;
    }
}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>better understandable code &#8230;<br />
<code><br />
#include<br />
#include</p>
<p>struct node<br />
{<br />
    int data;<br />
    struct node *next;<br />
};</p>
<p>struct node * createNode(int value)<br />
{<br />
    struct node * N=(struct node *)malloc(sizeof(struct node));<br />
    N-&gt;next=NULL;<br />
    N-&gt;data=value;<br />
    return N;<br />
};</p>
<p>struct node *FindMid(struct node *head) // auxilary method required<br />
{<br />
    struct node *p=head,*q=head;<br />
    if(p&amp;&amp;p-&gt;next)<br />
    {<br />
        p=p-&gt;next-&gt;next;<br />
        q=q-&gt;next;<br />
    }<br />
    return q;<br />
};<br />
// auxilary method required<br />
struct node * mergeSortedList(struct node *a,struct node *b)<br />
{<br />
    if(!a)<br />
        return b;<br />
    if(!b)<br />
        return a;<br />
    struct node *result=NULL;<br />
    if(a-&gt;data<b>data)<br />
    {<br />
        result=a;<br />
        result-&gt;next=mergeSortedList(a-&gt;next,b);<br />
    }<br />
    else<br />
    {<br />
        result=b;<br />
        result-&gt;next=mergeSortedList(a,b-&gt;next);<br />
    }<br />
    return result;<br />
};</p>
<p>struct node *mergeSort(struct node *head)<br />
{<br />
    if(!head)<br />
        return NULL;<br />
    if(head-&gt;next==NULL)<br />
        return head;</p>
<p>    else if(head-&gt;next-&gt;next==NULL)<br />
    {<br />
        struct node *p=head;<br />
        if(p-&gt;data&gt;p-&gt;next-&gt;data)<br />
        {<br />
            head=head-&gt;next;<br />
            p-&gt;next=NULL;<br />
            head-&gt;next=p;<br />
            return head;<br />
        }<br />
        else return head;</p>
<p>    }<br />
    else<br />
    {<br />
        struct node *mid=FindMid(head);<br />
        struct node *SHalf=mid-&gt;next;<br />
        mid-&gt;next=NULL;<br />
        struct node *head1=mergeSort(head);<br />
        struct node *head2=mergeSort(SHalf);</p>
<p>        return mergeSortedList(head1,head2);<br />
    }</p>
<p>};</p>
<p>void main()<br />
{<br />
    struct node *head=createNode(25);<br />
    head-&gt;next=createNode(10);<br />
    head-&gt;next-&gt;next=createNode(15);<br />
    head-&gt;next-&gt;next-&gt;next=createNode(30);<br />
    head-&gt;next-&gt;next-&gt;next-&gt;next=createNode(5);<br />
    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next=NULL;<br />
    printf("LINKED LIST TO BE SORTEDnn");<br />
    struct node *a=head;<br />
    while(a!=NULL)<br />
    {<br />
        printf("%d--&gt;",a-&gt;data);<br />
        a=a-&gt;next;<br />
    }</p>
<p>    a=mergeSort(head);<br />
    printf("nnSORTED LINKED LIST ISnn");<br />
    while(a!=NULL)<br />
    {<br />
        printf("%d--&gt;",a-&gt;data);<br />
        a=a-&gt;next;<br />
    }<br />
}<br />
</b></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/merge-sort-for-linked-list/#comment-32335</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Sat, 08 Feb 2014 08:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7740#comment-32335</guid>
		<description><![CDATA[Merge sort whole in recursive way is at below link

http://ideone.com/Wacpan]]></description>
		<content:encoded><![CDATA[<p>Merge sort whole in recursive way is at below link</p>
<p><a href="http://ideone.com/Wacpan" rel="nofollow">http://ideone.com/Wacpan</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:08:17 -->

<!-- Compression = gzip -->