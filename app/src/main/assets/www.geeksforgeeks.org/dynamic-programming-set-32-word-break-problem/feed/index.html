<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 32 (Word Break Problem)</title>
	<atom:link href="http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Karshit Jaiswal</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-39312</link>
		<dc:creator><![CDATA[Karshit Jaiswal]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 06:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-39312</guid>
		<description><![CDATA[Simple Recursive Implementation which counts and also prints the meaningfull words in string using a dictionary.
http://ideone.com/76aMxs]]></description>
		<content:encoded><![CDATA[<p>Simple Recursive Implementation which counts and also prints the meaningfull words in string using a dictionary.<br />
<a href="http://ideone.com/76aMxs" rel="nofollow">http://ideone.com/76aMxs</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-39085</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 01:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-39085</guid>
		<description><![CDATA[Cant we simply use Trie or Suffix Tree?]]></description>
		<content:encoded><![CDATA[<p>Cant we simply use Trie or Suffix Tree?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GS</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-38083</link>
		<dc:creator><![CDATA[GS]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 09:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-38083</guid>
		<description><![CDATA[http://ideone.com/f8yfuE

Here I have written a code that gives the min number of spaces required. I must be missing something as the algo works in O(n).

Please let me know what test cases I have missed.Its working fine with given cases]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/f8yfuE" rel="nofollow">http://ideone.com/f8yfuE</a></p>
<p>Here I have written a code that gives the min number of spaces required. I must be missing something as the algo works in O(n).</p>
<p>Please let me know what test cases I have missed.Its working fine with given cases</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-38068</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 08:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-38068</guid>
		<description><![CDATA[Would it be o(2^n) as we are calling the function n times recursively?]]></description>
		<content:encoded><![CDATA[<p>Would it be o(2^n) as we are calling the function n times recursively?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-35540</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 03 May 2014 03:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-35540</guid>
		<description><![CDATA[There are no overlapping sub problems in this program. Most of the commenters indicate the same. Need to make sure the code is fixed..]]></description>
		<content:encoded><![CDATA[<p>There are no overlapping sub problems in this program. Most of the commenters indicate the same. Need to make sure the code is fixed..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Brandon White</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-35299</link>
		<dc:creator><![CDATA[Brandon White]]></dc:creator>
		<pubDate>Wed, 30 Apr 2014 03:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-35299</guid>
		<description><![CDATA[Thanks for this breakdown -- it was actually very helpful.  It would be great if you could correct some of the mistakes, such as &#039;like&#039; vs. &#039;love&#039; and you skipped a letter in &quot;i becomes 4 &quot;ilk&quot;&quot; and &quot;i becomes 5 &quot;ilke&quot;&quot;]]></description>
		<content:encoded><![CDATA[<p>Thanks for this breakdown &#8212; it was actually very helpful.  It would be great if you could correct some of the mistakes, such as &#8216;like&#8217; vs. &#8216;love&#8217; and you skipped a letter in &#8220;i becomes 4 &#8220;ilk&#8221;&#8221; and &#8220;i becomes 5 &#8220;ilke&#8221;&#8221;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dmr</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-34650</link>
		<dc:creator><![CDATA[dmr]]></dc:creator>
		<pubDate>Sun, 13 Apr 2014 17:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-34650</guid>
		<description><![CDATA[Hi
I was searching for other solutions for this problem on net and found this(http://thenoisychannel.com/2011/08/08/retiring-a-great-interview-problem/#comment-10155) particular approach in a comment:
---------------------------------------------------------------
Build a directed graph consisting of vertices labeled 0, 1, 2, …, n, 
where n is the length of the string, where there is an edge from k to j 
if and only if there is a dictionary word of length j-k starting at 
position k in the string.
This can be done in O(n^2).
Solutions to the problem then correspond to paths through the graph 
from 0 to n. Use something like Dijkstra’s algorithm to find a minimal 
path in O(n^2), which corresponds to a solution that uses the smallest 
number of dictionary words to exactly cover the string.
------------------------------------------------------------
Now, that comment is very old, so not sure if someone will reply there. But does anyone here think this approach will work? I am particularly doubtful about being able to create that graph in O(n^2). Any comments ?]]></description>
		<content:encoded><![CDATA[<p>Hi<br />
I was searching for other solutions for this problem on net and found this(<a href="http://thenoisychannel.com/2011/08/08/retiring-a-great-interview-problem/#comment-10155" rel="nofollow">http://thenoisychannel.com/2011/08/08/retiring-a-great-interview-problem/#comment-10155</a>) particular approach in a comment:<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
Build a directed graph consisting of vertices labeled 0, 1, 2, …, n,<br />
where n is the length of the string, where there is an edge from k to j<br />
if and only if there is a dictionary word of length j-k starting at<br />
position k in the string.<br />
This can be done in O(n^2).<br />
Solutions to the problem then correspond to paths through the graph<br />
from 0 to n. Use something like Dijkstra’s algorithm to find a minimal<br />
path in O(n^2), which corresponds to a solution that uses the smallest<br />
number of dictionary words to exactly cover the string.<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
Now, that comment is very old, so not sure if someone will reply there. But does anyone here think this approach will work? I am particularly doubtful about being able to create that graph in O(n^2). Any comments ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: CodeCode54</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-34632</link>
		<dc:creator><![CDATA[CodeCode54]]></dc:creator>
		<pubDate>Sat, 12 Apr 2014 23:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-34632</guid>
		<description><![CDATA[I saw a lot of comments about people trying to see sub optimal structure for DP or the need for memoization. I was also skeptical about it first but after some try I have some clarity.

Suppose the string is: &quot;ilovesamsung&quot;

Dict: [i, love, loves, samsung]

String size is 12 so boolean[13]

First iteration i:1 
str.substr(0, i) = i present in dictionary so the array is

b[1] = t all false

no we iterate with j from i+1 (2) to 13

l not in dict

li not in dict 

lik not in dict

like in dictionary here j = 5

  so now the array is 

  b[1] = T b[5] = T rest all false

likes in dictionary here j = 6
  so now the array is 

  b[1] = T b[5] = T b[6] = T rest all false

likesa not in dictionary 

.

.

.

likesamsung not in dictionary 

j loop finishes

i  becomes 2 &quot;il&quot;
things happen 
i becomes 3 &quot;ili&quot;
things happen
i becomes 4 &quot;ilk&quot;
things happen
i becomes 5 &quot;ilke&quot;


We see b[5] is true so even &quot;ilike&quot; is not in dictionary we know that we have seen this before and there was a way to split it is valid word i.e. i like from earlier iterations so now go ahead and see if we can find right side word to be valid. 


Hope this helps.]]></description>
		<content:encoded><![CDATA[<p>I saw a lot of comments about people trying to see sub optimal structure for DP or the need for memoization. I was also skeptical about it first but after some try I have some clarity.</p>
<p>Suppose the string is: &#8220;ilovesamsung&#8221;</p>
<p>Dict: [i, love, loves, samsung]</p>
<p>String size is 12 so boolean[13]</p>
<p>First iteration i:1<br />
str.substr(0, i) = i present in dictionary so the array is</p>
<p>b[1] = t all false</p>
<p>no we iterate with j from i+1 (2) to 13</p>
<p>l not in dict</p>
<p>li not in dict </p>
<p>lik not in dict</p>
<p>like in dictionary here j = 5</p>
<p>  so now the array is </p>
<p>  b[1] = T b[5] = T rest all false</p>
<p>likes in dictionary here j = 6<br />
  so now the array is </p>
<p>  b[1] = T b[5] = T b[6] = T rest all false</p>
<p>likesa not in dictionary </p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>likesamsung not in dictionary </p>
<p>j loop finishes</p>
<p>i  becomes 2 &#8220;il&#8221;<br />
things happen<br />
i becomes 3 &#8220;ili&#8221;<br />
things happen<br />
i becomes 4 &#8220;ilk&#8221;<br />
things happen<br />
i becomes 5 &#8220;ilke&#8221;</p>
<p>We see b[5] is true so even &#8220;ilike&#8221; is not in dictionary we know that we have seen this before and there was a way to split it is valid word i.e. i like from earlier iterations so now go ahead and see if we can find right side word to be valid. </p>
<p>Hope this helps.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ali Nahid</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-34575</link>
		<dc:creator><![CDATA[Ali Nahid]]></dc:creator>
		<pubDate>Fri, 11 Apr 2014 06:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-34575</guid>
		<description><![CDATA[Thanks for the explanation. However, I am still not convinced. I understand what you&#039;re saying. But There&#039;s only 1 directed recursion going on. So I&#039;m pretty confident that there&#039;s no overlapping. 
Recursion like fibonacci or BST can have overlapping subproblems because of their tree structured traversal where one child can be visited multiple times.
For example : 1 recursion for left and 1 recursion on right.

BUT in this case it&#039;s a linear subproblem and i dont think there&#039;s any way they will be overlapping.]]></description>
		<content:encoded><![CDATA[<p>Thanks for the explanation. However, I am still not convinced. I understand what you&#8217;re saying. But There&#8217;s only 1 directed recursion going on. So I&#8217;m pretty confident that there&#8217;s no overlapping.<br />
Recursion like fibonacci or BST can have overlapping subproblems because of their tree structured traversal where one child can be visited multiple times.<br />
For example : 1 recursion for left and 1 recursion on right.</p>
<p>BUT in this case it&#8217;s a linear subproblem and i dont think there&#8217;s any way they will be overlapping.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pm</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-34502</link>
		<dc:creator><![CDATA[pm]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 11:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-34502</guid>
		<description><![CDATA[I will try to explain. The provided picture doesn&#039;t show the full recursion tree for a specific example. It shows all the possibilities for two nodes and as you can see there are some possibilities overlapping.


This probably didn&#039;t really help so here is something more specific. Let&#039;s use your example, but add the words a, p, ap.


applepie = a+pplepie OR ap+plepie OR apple+pie


The substring pplepie will be analyzed first. Obviously it will eventually return false. But one of the calls (the first one) will be for the substring plepie. Which overlaps with the second option ap+plepie.


Hope this makes at least a little sense.]]></description>
		<content:encoded><![CDATA[<p>I will try to explain. The provided picture doesn&#8217;t show the full recursion tree for a specific example. It shows all the possibilities for two nodes and as you can see there are some possibilities overlapping.</p>
<p>This probably didn&#8217;t really help so here is something more specific. Let&#8217;s use your example, but add the words a, p, ap.</p>
<p>applepie = a+pplepie OR ap+plepie OR apple+pie</p>
<p>The substring pplepie will be analyzed first. Obviously it will eventually return false. But one of the calls (the first one) will be for the substring plepie. Which overlaps with the second option ap+plepie.</p>
<p>Hope this makes at least a little sense.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ali Nahid</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-32-word-break-problem/#comment-34449</link>
		<dc:creator><![CDATA[Ali Nahid]]></dc:creator>
		<pubDate>Tue, 08 Apr 2014 03:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119449#comment-34449</guid>
		<description><![CDATA[I&#039;m sorry .. But I am seeing how the recursion method is causes overlapping ? can someone please explain ?

As far as I could understand .. because I am doing a return after the recursive call .. I will never overlap. If I did not do a &quot;return&quot; then for loop will iterate after the recursive call.

For Example:
&quot;applepie&quot; for dict {&quot;apple&quot;,&quot;pie&quot;} .. in the no recursion will be called unless i find apple. once i find apple then there will a recursion with pie. After that, I find prefix &quot;pie&quot; another recursion will be called with empty &quot;&quot; (well, yes, this is unnecessary call and with an if statement this can be avoided.. but it wont make any difference in the Big-O analysis cause cost of that if statement and cost of recursion is the same.. right ?[please correct me if i am wrong] ). 
So, where&#039;s the overlapping ?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m sorry .. But I am seeing how the recursion method is causes overlapping ? can someone please explain ?</p>
<p>As far as I could understand .. because I am doing a return after the recursive call .. I will never overlap. If I did not do a &#8220;return&#8221; then for loop will iterate after the recursive call.</p>
<p>For Example:<br />
&#8220;applepie&#8221; for dict {&#8220;apple&#8221;,&#8221;pie&#8221;} .. in the no recursion will be called unless i find apple. once i find apple then there will a recursion with pie. After that, I find prefix &#8220;pie&#8221; another recursion will be called with empty &#8220;&#8221; (well, yes, this is unnecessary call and with an if statement this can be avoided.. but it wont make any difference in the Big-O analysis cause cost of that if statement and cost of recursion is the same.. right ?[please correct me if i am wrong] ).<br />
So, where&#8217;s the overlapping ?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:54:18 -->

<!-- Compression = gzip -->