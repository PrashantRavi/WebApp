<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Merge two BSTs with limited extra space</title>
	<atom:link href="http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AMIT JAMBOTKAR</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-39823</link>
		<dc:creator><![CDATA[AMIT JAMBOTKAR]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 19:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-39823</guid>
		<description><![CDATA[http://ideone.com/UooBkI

Complete code is here]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/UooBkI" rel="nofollow">http://ideone.com/UooBkI</a></p>
<p>Complete code is here</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AMIT JAMBOTKAR</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-39821</link>
		<dc:creator><![CDATA[AMIT JAMBOTKAR]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 19:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-39821</guid>
		<description><![CDATA[@geeksforgeeks:disqus 
We can do it in simple way like this

void merge(Node root,Node root1){

		if(root!=null){

			putInToStack(stack1,root);		

		}

		if(root1!=null){

			putInToStack(stack2,root1);	

		}



		while(!stack1.isEmpty()&#124;&#124;!stack2.isEmpty()){

			if((!stack1.isEmpty()?stack1.peek().value.doubleValue():0.0)&#060; (!stack2.isEmpty()?stack2.peek().value.doubleValue():0.0) &#038;&#038; !stack1.isEmpty()){

				Node temp=stack1.pop();

				System.out.println(temp.value);

				if(temp.rightRef!=null)

					putInToStack(stack1,temp.rightRef);	

			}

			else if((!stack1.isEmpty()?stack1.peek().value.doubleValue():0.0)&#062; (!stack2.isEmpty()?stack2.peek().value.doubleValue():0.0) &#038;&#038; !stack2.isEmpty()){

				Node temp=stack2.pop();

				System.out.println(temp.value);

				if(temp.rightRef!=null)

					putInToStack(stack2,temp.rightRef);	

			}else if(!stack1.isEmpty() &#038;&#038; !stack2.isEmpty()) {

				

				Node temp=stack2.pop();

				Node temp2=stack1.pop();

				System.out.println(temp.value);

				if(temp.rightRef!=null)

					putInToStack(stack2,temp.rightRef);	

				if(temp2.rightRef!=null)

					putInToStack(stack1,temp2.rightRef);

			}

			

		}

		

		

	}

	

	void putInToStack(Stack&#060;Node&#062; stack1,Node root){

		

		while(root!=null){

			stack1.push(root);

			root=root.leftRef;

		}

		

	}]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus<br />
We can do it in simple way like this</p>
<p>void merge(Node root,Node root1){</p>
<p>		if(root!=null){</p>
<p>			putInToStack(stack1,root);		</p>
<p>		}</p>
<p>		if(root1!=null){</p>
<p>			putInToStack(stack2,root1);	</p>
<p>		}</p>
<p>		while(!stack1.isEmpty()||!stack2.isEmpty()){</p>
<p>			if((!stack1.isEmpty()?stack1.peek().value.doubleValue():0.0)&lt; (!stack2.isEmpty()?stack2.peek().value.doubleValue():0.0) &amp;&amp; !stack1.isEmpty()){</p>
<p>				Node temp=stack1.pop();</p>
<p>				System.out.println(temp.value);</p>
<p>				if(temp.rightRef!=null)</p>
<p>					putInToStack(stack1,temp.rightRef);	</p>
<p>			}</p>
<p>			else if((!stack1.isEmpty()?stack1.peek().value.doubleValue():0.0)&gt; (!stack2.isEmpty()?stack2.peek().value.doubleValue():0.0) &amp;&amp; !stack2.isEmpty()){</p>
<p>				Node temp=stack2.pop();</p>
<p>				System.out.println(temp.value);</p>
<p>				if(temp.rightRef!=null)</p>
<p>					putInToStack(stack2,temp.rightRef);	</p>
<p>			}else if(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) {</p>
<p>				Node temp=stack2.pop();</p>
<p>				Node temp2=stack1.pop();</p>
<p>				System.out.println(temp.value);</p>
<p>				if(temp.rightRef!=null)</p>
<p>					putInToStack(stack2,temp.rightRef);	</p>
<p>				if(temp2.rightRef!=null)</p>
<p>					putInToStack(stack1,temp2.rightRef);</p>
<p>			}</p>
<p>		}</p>
<p>	}</p>
<p>	void putInToStack(Stack&lt;Node&gt; stack1,Node root){</p>
<p>		while(root!=null){</p>
<p>			stack1.push(root);</p>
<p>			root=root.leftRef;</p>
<p>		}</p>
<p>	}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-39327</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 08:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-39327</guid>
		<description><![CDATA[converting a bst into dll requires O(height of the tree) extra space for the recursive calls. so if we convert both the trees into dll and then merge them, it would satisfy the given condition]]></description>
		<content:encoded><![CDATA[<p>converting a bst into dll requires O(height of the tree) extra space for the recursive calls. so if we convert both the trees into dll and then merge them, it would satisfy the given condition</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gautam Goyal</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-37481</link>
		<dc:creator><![CDATA[Gautam Goyal]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 06:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-37481</guid>
		<description><![CDATA[Easier implementation using similar idea...




void printMergedBST(struct node* root1, struct node* root2){

	if(root1 == NULL)

		inOrderTraversal(root2);

	if(root2 == NULL)

		inOrderTraversal(root1);

	Stack *s1,*s2;

	s1 = createStack();

	s2 = createStack();

	struct node *curr1 = root1, *curr2= root2;

	while(1){

		while(curr1){

			push(s1,curr1);

			curr1 = curr1-&#062;left;

		}

		while(curr2){

			push(s2,curr2);

			curr2 = curr2-&#062;left;

		}

		if(s1-&#062;size &#038;&#038; s2-&#062;size){

			if(s1-&#062;top-&#062;data &#062; s2-&#062;top-&#062;data){

				qLink temp = pop(s2);

				printf(&quot;%d &quot;,temp-&#062;data);

				curr2 = temp-&#062;right;

			}

			else{

				qLink temp = pop(s1);

				printf(&quot;%d &quot;,temp-&#062;data);

				curr1 = temp-&#062;right;

			}

		}

		if(s1-&#062;size == 0 &#038;&#038; curr1 == NULL){

			inOrderTraversal(curr2);

			break;

		}

		if(s2-&#062;size == 0 &#038;&#038; curr2 == NULL){

			inOrderTraversal(curr1);

			break;

		}

	}

}]]></description>
		<content:encoded><![CDATA[<p>Easier implementation using similar idea&#8230;</p>
<p>void printMergedBST(struct node* root1, struct node* root2){</p>
<p>	if(root1 == NULL)</p>
<p>		inOrderTraversal(root2);</p>
<p>	if(root2 == NULL)</p>
<p>		inOrderTraversal(root1);</p>
<p>	Stack *s1,*s2;</p>
<p>	s1 = createStack();</p>
<p>	s2 = createStack();</p>
<p>	struct node *curr1 = root1, *curr2= root2;</p>
<p>	while(1){</p>
<p>		while(curr1){</p>
<p>			push(s1,curr1);</p>
<p>			curr1 = curr1-&gt;left;</p>
<p>		}</p>
<p>		while(curr2){</p>
<p>			push(s2,curr2);</p>
<p>			curr2 = curr2-&gt;left;</p>
<p>		}</p>
<p>		if(s1-&gt;size &amp;&amp; s2-&gt;size){</p>
<p>			if(s1-&gt;top-&gt;data &gt; s2-&gt;top-&gt;data){</p>
<p>				qLink temp = pop(s2);</p>
<p>				printf(&#8220;%d &#8220;,temp-&gt;data);</p>
<p>				curr2 = temp-&gt;right;</p>
<p>			}</p>
<p>			else{</p>
<p>				qLink temp = pop(s1);</p>
<p>				printf(&#8220;%d &#8220;,temp-&gt;data);</p>
<p>				curr1 = temp-&gt;right;</p>
<p>			}</p>
<p>		}</p>
<p>		if(s1-&gt;size == 0 &amp;&amp; curr1 == NULL){</p>
<p>			inOrderTraversal(curr2);</p>
<p>			break;</p>
<p>		}</p>
<p>		if(s2-&gt;size == 0 &amp;&amp; curr2 == NULL){</p>
<p>			inOrderTraversal(curr1);</p>
<p>			break;</p>
<p>		}</p>
<p>	}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-35220</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 07:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-35220</guid>
		<description><![CDATA[The question is to just print  merged trees or actually merging them? According to the problem statement it seems that we only need to print 2 merged trees. Not actually merging them.]]></description>
		<content:encoded><![CDATA[<p>The question is to just print  merged trees or actually merging them? According to the problem statement it seems that we only need to print 2 merged trees. Not actually merging them.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-34639</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Sun, 13 Apr 2014 08:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-34639</guid>
		<description><![CDATA[@Geeksforgeeks

I have another recursive solution with o(m+n) time and o(log(m+n)) space complexity (for recursion).

#include

#include

 

// Structure of a BST Node

struct node

{

    int data;

    struct node *left;

    struct node *right;

};

 

 int isPrinted = 0;

 

/* Utility function to create a new Binary Tree node */

struct node* newNode (int data)

{

    struct node *temp = (struct node*)malloc(sizeof(struct node));

    temp-&#062;data = data;

    temp-&#062;left = NULL;

    temp-&#062;right = NULL;

    return temp;

}

/* A utility function to print Inoder traversal of a Binary Tree */

void inorder(struct node *root)

{

    if (root != NULL)

    {

        inorder(root-&#062;left);

        printf(&quot;%d--&#062;&quot;, root-&#062;data);

        inorder(root-&#062;right);

    }

}

 

// The function to print data of two BSTs in sorted order

void  merge(struct node *root1, struct node *root2, int *n1, int *n2)

{

    

    	// left subtrees

    	if(root1-&#062;data data)

    		if(root2-&#062;left)

    		{

    			--(*n2);

    			merge(root1,root2-&#062;left,n1,n2);

    		}

    			

    	if(root1-&#062;data &#062; root2-&#062;data)

    		if(root1-&#062;left)

    		{

    			--(*n1);

    			merge(root1-&#062;left,root2,n1,n2);

    		}

    	

    	// processing

    	if(root1-&#062;data data)

    	{

    		printf(&quot;%d--&#062;&quot;, root1-&#062;data);

    		if(root1-&#062;right != NULL)

    		{

    			--(*n1);

  		  		merge(root1-&#062;right,root2,n1,n2);	

  		  	}

    	}	

    	else if(root1-&#062;data &#062; root2-&#062;data)

    	{

    		printf(&quot;%d--&#062;&quot;, root2-&#062;data);

    		if(root2-&#062;right!=NULL)

    		{

    			--(*n2);

    			merge(root1,root2-&#062;right,n1,n2);	

    		}

    	}

    	

    	// If first BST is empty, then output is inorder

    // traversal of second BST

    if ((*n1)==1 &#038;&#038; !isPrinted)

    {

    	isPrinted = 1;

        inorder(root2);

        return;

    }

    // If second BST is empty, then output is inorder

    // traversal of first BST

    else if ((*n2) == 1 &#038;&#038; !isPrinted)

    {

        inorder(root1);

        return ;

    }

}

int size(struct node* root)

{	

	if(root == NULL)

		return 0;

		

	return (1 + size(root-&#062;left) + size(root-&#062;right));

}

void merger(struct node *root1, struct node *root2)

{

	int n1= size(root1);

	int n2= size(root2);

	merge(root1, root2, &#038;n1, &#038;n2);

}

 

/* Driver program to test above functions */

int main()

{

    struct node  *root1 = NULL, *root2 = NULL;

 

    /* Let us create the following tree as first tree

            6

          /  

        3     8

          

            4

     */

    root1 = newNode(6);

    root1-&#062;left = newNode(3);

        root1-&#062;left-&#062;right = newNode(4);

    root1-&#062;right = newNode(8);

 

    /* Let us create the following tree as second tree

            7

          /  

         5   9

               

               10

     */

    root2 = newNode(7);

    root2-&#062;left = newNode(5);

    root2-&#062;right = newNode(9);

    root2-&#062;right-&#062;right = newNode(10);

 

    // Print sorted nodes of both trees

    merger(root1, root2);

 

    return 0;

}





This solution is quite easier than iterative solution. Please consider this.]]></description>
		<content:encoded><![CDATA[<p>@Geeksforgeeks</p>
<p>I have another recursive solution with o(m+n) time and o(log(m+n)) space complexity (for recursion).</p>
<p>#include</p>
<p>#include</p>
<p>// Structure of a BST Node</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node *left;</p>
<p>    struct node *right;</p>
<p>};</p>
<p> int isPrinted = 0;</p>
<p>/* Utility function to create a new Binary Tree node */</p>
<p>struct node* newNode (int data)</p>
<p>{</p>
<p>    struct node *temp = (struct node*)malloc(sizeof(struct node));</p>
<p>    temp-&gt;data = data;</p>
<p>    temp-&gt;left = NULL;</p>
<p>    temp-&gt;right = NULL;</p>
<p>    return temp;</p>
<p>}</p>
<p>/* A utility function to print Inoder traversal of a Binary Tree */</p>
<p>void inorder(struct node *root)</p>
<p>{</p>
<p>    if (root != NULL)</p>
<p>    {</p>
<p>        inorder(root-&gt;left);</p>
<p>        printf(&#8220;%d&#8211;&gt;&#8221;, root-&gt;data);</p>
<p>        inorder(root-&gt;right);</p>
<p>    }</p>
<p>}</p>
<p>// The function to print data of two BSTs in sorted order</p>
<p>void  merge(struct node *root1, struct node *root2, int *n1, int *n2)</p>
<p>{</p>
<p>    	// left subtrees</p>
<p>    	if(root1-&gt;data data)</p>
<p>    		if(root2-&gt;left)</p>
<p>    		{</p>
<p>    			&#8211;(*n2);</p>
<p>    			merge(root1,root2-&gt;left,n1,n2);</p>
<p>    		}</p>
<p>    	if(root1-&gt;data &gt; root2-&gt;data)</p>
<p>    		if(root1-&gt;left)</p>
<p>    		{</p>
<p>    			&#8211;(*n1);</p>
<p>    			merge(root1-&gt;left,root2,n1,n2);</p>
<p>    		}</p>
<p>    	// processing</p>
<p>    	if(root1-&gt;data data)</p>
<p>    	{</p>
<p>    		printf(&#8220;%d&#8211;&gt;&#8221;, root1-&gt;data);</p>
<p>    		if(root1-&gt;right != NULL)</p>
<p>    		{</p>
<p>    			&#8211;(*n1);</p>
<p>  		  		merge(root1-&gt;right,root2,n1,n2);	</p>
<p>  		  	}</p>
<p>    	}	</p>
<p>    	else if(root1-&gt;data &gt; root2-&gt;data)</p>
<p>    	{</p>
<p>    		printf(&#8220;%d&#8211;&gt;&#8221;, root2-&gt;data);</p>
<p>    		if(root2-&gt;right!=NULL)</p>
<p>    		{</p>
<p>    			&#8211;(*n2);</p>
<p>    			merge(root1,root2-&gt;right,n1,n2);	</p>
<p>    		}</p>
<p>    	}</p>
<p>    	// If first BST is empty, then output is inorder</p>
<p>    // traversal of second BST</p>
<p>    if ((*n1)==1 &amp;&amp; !isPrinted)</p>
<p>    {</p>
<p>    	isPrinted = 1;</p>
<p>        inorder(root2);</p>
<p>        return;</p>
<p>    }</p>
<p>    // If second BST is empty, then output is inorder</p>
<p>    // traversal of first BST</p>
<p>    else if ((*n2) == 1 &amp;&amp; !isPrinted)</p>
<p>    {</p>
<p>        inorder(root1);</p>
<p>        return ;</p>
<p>    }</p>
<p>}</p>
<p>int size(struct node* root)</p>
<p>{	</p>
<p>	if(root == NULL)</p>
<p>		return 0;</p>
<p>	return (1 + size(root-&gt;left) + size(root-&gt;right));</p>
<p>}</p>
<p>void merger(struct node *root1, struct node *root2)</p>
<p>{</p>
<p>	int n1= size(root1);</p>
<p>	int n2= size(root2);</p>
<p>	merge(root1, root2, &amp;n1, &amp;n2);</p>
<p>}</p>
<p>/* Driver program to test above functions */</p>
<p>int main()</p>
<p>{</p>
<p>    struct node  *root1 = NULL, *root2 = NULL;</p>
<p>    /* Let us create the following tree as first tree</p>
<p>            6</p>
<p>          /  </p>
<p>        3     8</p>
<p>            4</p>
<p>     */</p>
<p>    root1 = newNode(6);</p>
<p>    root1-&gt;left = newNode(3);</p>
<p>        root1-&gt;left-&gt;right = newNode(4);</p>
<p>    root1-&gt;right = newNode(8);</p>
<p>    /* Let us create the following tree as second tree</p>
<p>            7</p>
<p>          /  </p>
<p>         5   9</p>
<p>               10</p>
<p>     */</p>
<p>    root2 = newNode(7);</p>
<p>    root2-&gt;left = newNode(5);</p>
<p>    root2-&gt;right = newNode(9);</p>
<p>    root2-&gt;right-&gt;right = newNode(10);</p>
<p>    // Print sorted nodes of both trees</p>
<p>    merger(root1, root2);</p>
<p>    return 0;</p>
<p>}</p>
<p>This solution is quite easier than iterative solution. Please consider this.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-31087</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 27 Dec 2013 20:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-31087</guid>
		<description><![CDATA[why are we calling inorder(current1)  in while loop
 if (isEmpty(s2))
            {
                while (!isEmpty(s1))
                {
                    current1 = pop (&#038;s1);
                    current1-&#062;left = NULL;
                    inorder(current1);
                }
                return ;
            }]]></description>
		<content:encoded><![CDATA[<p>why are we calling inorder(current1)  in while loop<br />
 if (isEmpty(s2))<br />
            {<br />
                while (!isEmpty(s1))<br />
                {<br />
                    current1 = pop (&amp;s1);<br />
                    current1-&gt;left = NULL;<br />
                    inorder(current1);<br />
                }<br />
                return ;<br />
            }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: powerhu</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-27597</link>
		<dc:creator><![CDATA[powerhu]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 08:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-27597</guid>
		<description><![CDATA[C# Code:

        public static void AddLeftNodes(Node node, Stack s)

        {

            while (node != null)

            {

                s.Push(node);

                node = node.left;

            }            

        }

        public static void PopCurrentNode(Stack stack)

        {

            Node nd = stack.Pop();

            Console.Write(nd.value + &quot;t&quot;);

            if (nd.right != null)

            {

                AddLeftNodes(nd.right, stack);

            }

        }

        public static void MergeTwoBST(Node a, Node b)

        {

            Stack astack = new Stack();

            Stack bstack = new Stack();

            AddLeftNodes(a, astack);

            AddLeftNodes(b, bstack);

            while (astack.Count &#062; 0 &#038;&#038; bstack.Count &#062; 0)

            {

                if (astack.Peek().value &#062; bstack.Peek().value)

                {

                    PopCurrentNode(bstack);

                }

                else

                {

                    PopCurrentNode(astack);

                }

            }

            

            if (astack.Count &#062; 0)

            {

                while (astack.Count &#062; 0)

                {

                    PopCurrentNode(astack);

                }

            }

            if (bstack.Count &#062; 0)

            {

                while (bstack.Count &#062; 0)

                {

                    PopCurrentNode(bstack);

                }

            }

            Console.WriteLine();

        }]]></description>
		<content:encoded><![CDATA[<p>C# Code:</p>
<p>        public static void AddLeftNodes(Node node, Stack s)</p>
<p>        {</p>
<p>            while (node != null)</p>
<p>            {</p>
<p>                s.Push(node);</p>
<p>                node = node.left;</p>
<p>            }            </p>
<p>        }</p>
<p>        public static void PopCurrentNode(Stack stack)</p>
<p>        {</p>
<p>            Node nd = stack.Pop();</p>
<p>            Console.Write(nd.value + &#8220;t&#8221;);</p>
<p>            if (nd.right != null)</p>
<p>            {</p>
<p>                AddLeftNodes(nd.right, stack);</p>
<p>            }</p>
<p>        }</p>
<p>        public static void MergeTwoBST(Node a, Node b)</p>
<p>        {</p>
<p>            Stack astack = new Stack();</p>
<p>            Stack bstack = new Stack();</p>
<p>            AddLeftNodes(a, astack);</p>
<p>            AddLeftNodes(b, bstack);</p>
<p>            while (astack.Count &gt; 0 &amp;&amp; bstack.Count &gt; 0)</p>
<p>            {</p>
<p>                if (astack.Peek().value &gt; bstack.Peek().value)</p>
<p>                {</p>
<p>                    PopCurrentNode(bstack);</p>
<p>                }</p>
<p>                else</p>
<p>                {</p>
<p>                    PopCurrentNode(astack);</p>
<p>                }</p>
<p>            }</p>
<p>            if (astack.Count &gt; 0)</p>
<p>            {</p>
<p>                while (astack.Count &gt; 0)</p>
<p>                {</p>
<p>                    PopCurrentNode(astack);</p>
<p>                }</p>
<p>            }</p>
<p>            if (bstack.Count &gt; 0)</p>
<p>            {</p>
<p>                while (bstack.Count &gt; 0)</p>
<p>                {</p>
<p>                    PopCurrentNode(bstack);</p>
<p>                }</p>
<p>            }</p>
<p>            Console.WriteLine();</p>
<p>        }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Bgl</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-25090</link>
		<dc:creator><![CDATA[Amit Bgl]]></dc:creator>
		<pubDate>Sat, 17 Aug 2013 02:43:01 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-25090</guid>
		<description><![CDATA[wow code :D]]></description>
		<content:encoded><![CDATA[<p>wow code 😀</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: saket</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-22667</link>
		<dc:creator><![CDATA[saket]]></dc:creator>
		<pubDate>Thu, 25 Jul 2013 11:36:05 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-22667</guid>
		<description><![CDATA[Yes I agre with you. 3rd method of previous post is  feasible and it does in o(m+n).


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Yes I agre with you. 3rd method of previous post is  feasible and it does in o(m+n).</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: bateesh</title>
		<link>http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/#comment-21440</link>
		<dc:creator><![CDATA[bateesh]]></dc:creator>
		<pubDate>Fri, 05 Jul 2013 11:12:45 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19422#comment-21440</guid>
		<description><![CDATA[@GeeksforGeeks  

Why Cant we apply 3rd method of previous post.Its 3rd step is just a merging two sorted DLLs.It depends upon the  number of nodes in the list.It will be done in 0(n) regardless of balanced/unbalanced as we have converted it to DLL.The problem can be with step 1 where we convert the BST to DLL.Can you plz explain with one example that why 3rd method of previous post is not feasible here to do in o(m+n).]]></description>
		<content:encoded><![CDATA[<p>@GeeksforGeeks  </p>
<p>Why Cant we apply 3rd method of previous post.Its 3rd step is just a merging two sorted DLLs.It depends upon the  number of nodes in the list.It will be done in 0(n) regardless of balanced/unbalanced as we have converted it to DLL.The problem can be with step 1 where we convert the BST to DLL.Can you plz explain with one example that why 3rd method of previous post is not feasible here to do in o(m+n).</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:06:34 -->

<!-- Compression = gzip -->