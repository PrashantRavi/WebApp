<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Next higher number with same number of set bits</title>
	<atom:link href="http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Deepesh Panjabi</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-38277</link>
		<dc:creator><![CDATA[Deepesh Panjabi]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 06:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-38277</guid>
		<description><![CDATA[http://ideone.com/3VzxXW]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/3VzxXW" rel="nofollow">http://ideone.com/3VzxXW</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek Garg</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-36412</link>
		<dc:creator><![CDATA[Vivek Garg]]></dc:creator>
		<pubDate>Wed, 21 May 2014 15:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-36412</guid>
		<description><![CDATA[Could you explain the algorithm ... my means of asking is why this algorithm is working.]]></description>
		<content:encoded><![CDATA[<p>Could you explain the algorithm &#8230; my means of asking is why this algorithm is working.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Wellwisher</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-34727</link>
		<dc:creator><![CDATA[Wellwisher]]></dc:creator>
		<pubDate>Wed, 16 Apr 2014 03:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-34727</guid>
		<description><![CDATA[Nice code in C#. Complexiety O(n)

http://onestopinterviewprep.blogspot.com/2014/04/find-next-higher-number-with-same-digits.html]]></description>
		<content:encoded><![CDATA[<p>Nice code in C#. Complexiety O(n)</p>
<p><a href="http://onestopinterviewprep.blogspot.com/2014/04/find-next-higher-number-with-same-digits.html" rel="nofollow">http://onestopinterviewprep.blogspot.com/2014/04/find-next-higher-number-with-same-digits.html</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Chen</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-32432</link>
		<dc:creator><![CDATA[Chen]]></dc:creator>
		<pubDate>Tue, 11 Feb 2014 06:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-32432</guid>
		<description><![CDATA[This is much more straightforward ! Thanks!]]></description>
		<content:encoded><![CDATA[<p>This is much more straightforward ! Thanks!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ritu</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-31382</link>
		<dc:creator><![CDATA[ritu]]></dc:creator>
		<pubDate>Thu, 09 Jan 2014 02:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-31382</guid>
		<description><![CDATA[could you please explain in detail. i am still a beginer. plz]]></description>
		<content:encoded><![CDATA[<p>could you please explain in detail. i am still a beginer. plz</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Omor J. Kocharee</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-28224</link>
		<dc:creator><![CDATA[Omor J. Kocharee]]></dc:creator>
		<pubDate>Sun, 29 Sep 2013 09:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-28224</guid>
		<description><![CDATA[Why its too complicated?
Please check this http://www.slideshare.net/gkumar007/bits-next-higher-presentation for very easy approach.]]></description>
		<content:encoded><![CDATA[<p>Why its too complicated?<br />
Please check this <a href="http://www.slideshare.net/gkumar007/bits-next-higher-presentation" rel="nofollow">http://www.slideshare.net/gkumar007/bits-next-higher-presentation</a> for very easy approach.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Shradha Agrawal</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-26844</link>
		<dc:creator><![CDATA[Shradha Agrawal]]></dc:creator>
		<pubDate>Fri, 23 Aug 2013 18:45:30 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-26844</guid>
		<description><![CDATA[Nice one! I solved the question in similar manner.]]></description>
		<content:encoded><![CDATA[<p>Nice one! I solved the question in similar manner.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rick Giuly</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-26172</link>
		<dc:creator><![CDATA[Rick Giuly]]></dc:creator>
		<pubDate>Thu, 08 Aug 2013 18:32:33 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-26172</guid>
		<description><![CDATA[The procedure in Gayle McDowell&#039;s book is as follows: First find the rightmost non-trailing zero, say at position i, set it to 1. Then consider the bits to the right of position I. Count how many 1&#039;s there are, say N. Zero them out and put N-1 high bits on in the least significant positions.

My comment here is a description of why I think this procedure actually works. Assume you have the answer to the problem X.

You know that at least one bit in X must have been flipped from 0 to 1 to make the number higher. Assume bit #i is the most significant bit that was flipped high to produce the answer.

So, your answer has the form:

[left part] [bit i] [right part].

You know that somewhere there must be compensation (considering number of bits) for the fact that [bit i] was set high. This would mean that the number of bits in either the left or right part must decrease.

Now you are guaranteed that the number of bits on left will not decrease. The reason is that the bits in the left part are too &#034;course grained.&#034; Specifically, any bit in the [left part] flipped from high to low would decrease the value so much that [bit i] (and any other bits to the right of it) would not be enough to make the number any bigger than the original. So, we know that the number of bits in the [left part] must say what it is, and the number in [right part] but decrease by exactly one.

Now we determine how [right part] is affected. When you increase bit I by one, that is enough to make the number bigger. You really don&#039;t need to increase it by any more than that. As far as increasing the number goes, you don&#039;t need any bits to the [right part] of it set to one. However, you can&#039;t neccesarily set all of them to zero -- you are only allowed to decrease the &#034;1&#034; count by 1. So you count how many bits are in [right part], say N. You clear out [right part] to all zeros, and then you put back N-1 in the least significant positions. This way the count goes from N to N-1 as you need it to, and you do &#034;minimal damage&#034; by loading the 1&#039;s into the last significant positions.

One more question in forming this procedure is determining how to best choose bit I. You know that it must be a zero. You also know that there must be one or more 1&#039;s after it (so that their count can be decreased by one). These two facts mean you are choosing a zero that has ones after it. There&#039;s one more consideration, you really want the *least significant* zero that has ones after it. The reason is that if you pick a more significant zero, you can only do damage.

Here&#039;s why you would only do damage. If you end up with extra 1&#039;s in right part [right part], those are just the pesky ones that make the number in [right part] higher than you need it to be. If you end up with extra 0&#039;s in the [right part], that means bit I was just chosen to be higher than it needed to be and you have make the number higher by too much. Considering these arguments, for bit i, you want to choose the least significant zero with ones after it, which is the same as saying the rightmost non-trailing zero.

In summary, this justifies (1) picking the righmost non-trailing zero as bit i, (2) setting bit I high, and (3) modifying the bits right of bit I so that the count of 1&#039;s is decreased by one and all 1&#039;s are pushed to the least significant places.]]></description>
		<content:encoded><![CDATA[<p>The procedure in Gayle McDowell&#039;s book is as follows: First find the rightmost non-trailing zero, say at position i, set it to 1. Then consider the bits to the right of position I. Count how many 1&#039;s there are, say N. Zero them out and put N-1 high bits on in the least significant positions.</p>
<p>My comment here is a description of why I think this procedure actually works. Assume you have the answer to the problem X.</p>
<p>You know that at least one bit in X must have been flipped from 0 to 1 to make the number higher. Assume bit #i is the most significant bit that was flipped high to produce the answer.</p>
<p>So, your answer has the form:</p>
<p>[left part] [bit i] [right part].</p>
<p>You know that somewhere there must be compensation (considering number of bits) for the fact that [bit i] was set high. This would mean that the number of bits in either the left or right part must decrease.</p>
<p>Now you are guaranteed that the number of bits on left will not decrease. The reason is that the bits in the left part are too &quot;course grained.&quot; Specifically, any bit in the [left part] flipped from high to low would decrease the value so much that [bit i] (and any other bits to the right of it) would not be enough to make the number any bigger than the original. So, we know that the number of bits in the [left part] must say what it is, and the number in [right part] but decrease by exactly one.</p>
<p>Now we determine how [right part] is affected. When you increase bit I by one, that is enough to make the number bigger. You really don&#039;t need to increase it by any more than that. As far as increasing the number goes, you don&#039;t need any bits to the [right part] of it set to one. However, you can&#039;t neccesarily set all of them to zero &#8212; you are only allowed to decrease the &quot;1&quot; count by 1. So you count how many bits are in [right part], say N. You clear out [right part] to all zeros, and then you put back N-1 in the least significant positions. This way the count goes from N to N-1 as you need it to, and you do &quot;minimal damage&quot; by loading the 1&#039;s into the last significant positions.</p>
<p>One more question in forming this procedure is determining how to best choose bit I. You know that it must be a zero. You also know that there must be one or more 1&#039;s after it (so that their count can be decreased by one). These two facts mean you are choosing a zero that has ones after it. There&#039;s one more consideration, you really want the *least significant* zero that has ones after it. The reason is that if you pick a more significant zero, you can only do damage.</p>
<p>Here&#039;s why you would only do damage. If you end up with extra 1&#039;s in right part [right part], those are just the pesky ones that make the number in [right part] higher than you need it to be. If you end up with extra 0&#039;s in the [right part], that means bit I was just chosen to be higher than it needed to be and you have make the number higher by too much. Considering these arguments, for bit i, you want to choose the least significant zero with ones after it, which is the same as saying the rightmost non-trailing zero.</p>
<p>In summary, this justifies (1) picking the righmost non-trailing zero as bit i, (2) setting bit I high, and (3) modifying the bits right of bit I so that the count of 1&#039;s is decreased by one and all 1&#039;s are pushed to the least significant places.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Siddharth Rajpal</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-26171</link>
		<dc:creator><![CDATA[Siddharth Rajpal]]></dc:creator>
		<pubDate>Wed, 17 Jul 2013 17:27:58 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-26171</guid>
		<description><![CDATA[There is another possible solution:
First find the rightmost 1, and then search for the first 0 to the left of the rightmost 1. Change that 0 to 1 and the bit to the immediate right to it to 0. Find the number of 1s to the left of it and add those many 1s to the end of the n bit number.

For example we have 100110:
The first 1 occurs on the second last bit. and the first 0 (after the second last bit) occurs on the 4th last bit. Change that 0 to 1 and the bit on the right of it to 0.

100110 -&#062; (change the 0 to 1) 101110-&#062; (change the bit on right of it to 0) 101010.

now, count the number of 1s to the left of the 0 after 1010, we have only one 1 to its left. Add it to the end of the list.

101010-&#062; 101001.

Hence the answer is 101001.]]></description>
		<content:encoded><![CDATA[<p>There is another possible solution:<br />
First find the rightmost 1, and then search for the first 0 to the left of the rightmost 1. Change that 0 to 1 and the bit to the immediate right to it to 0. Find the number of 1s to the left of it and add those many 1s to the end of the n bit number.</p>
<p>For example we have 100110:<br />
The first 1 occurs on the second last bit. and the first 0 (after the second last bit) occurs on the 4th last bit. Change that 0 to 1 and the bit on the right of it to 0.</p>
<p>100110 -&gt; (change the 0 to 1) 101110-&gt; (change the bit on right of it to 0) 101010.</p>
<p>now, count the number of 1s to the left of the 0 after 1010, we have only one 1 to its left. Add it to the end of the list.</p>
<p>101010-&gt; 101001.</p>
<p>Hence the answer is 101001.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: aditya kumar</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-21995</link>
		<dc:creator><![CDATA[aditya kumar]]></dc:creator>
		<pubDate>Fri, 12 Jul 2013 19:32:46 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-21995</guid>
		<description><![CDATA[first find out the pos of first rightmost &#039;0&#039; bit after(left of ) the rightmost
 set bit &#039;1&#039;
ex :  num(42) = 101010 ====&#062;pos=3; temp= 1&#060;&#062;1) = 101010 + 000100 -000010 = 101100 =44ans.
code:
int next_int_with_same_set_bit(int num)
t=num&#038;(-num);
while(1)
{t&#060;&#062;1);
return ans;
}]]></description>
		<content:encoded><![CDATA[<p>first find out the pos of first rightmost &#8216;0&#8217; bit after(left of ) the rightmost<br />
 set bit &#8216;1&#8217;<br />
ex :  num(42) = 101010 ====&gt;pos=3; temp= 1&lt;&gt;1) = 101010 + 000100 -000010 = 101100 =44ans.<br />
code:<br />
int next_int_with_same_set_bit(int num)<br />
t=num&amp;(-num);<br />
while(1)<br />
{t&lt;&gt;1);<br />
return ans;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: insect</title>
		<link>http://www.geeksforgeeks.org/next-higher-number-with-same-number-of-set-bits/#comment-21085</link>
		<dc:creator><![CDATA[insect]]></dc:creator>
		<pubDate>Tue, 02 Jul 2013 20:34:19 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10375#comment-21085</guid>
		<description><![CDATA[sry..its correct]]></description>
		<content:encoded><![CDATA[<p>sry..its correct</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.075 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 12:44:43 -->

<!-- Compression = gzip -->