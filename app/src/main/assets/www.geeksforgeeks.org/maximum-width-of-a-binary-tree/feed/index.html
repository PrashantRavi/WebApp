<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Maximum width of a binary tree</title>
	<atom:link href="http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Rajesh Yadav</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-40136</link>
		<dc:creator><![CDATA[Rajesh Yadav]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 11:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-40136</guid>
		<description><![CDATA[http://ideone.com/6hSKYf..............please check it.....it might be easier...]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/6hSKYf" rel="nofollow">http://ideone.com/6hSKYf</a>&#8230;&#8230;&#8230;&#8230;..please check it&#8230;..it might be easier&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38112</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 13:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38112</guid>
		<description><![CDATA[nice trick]]></description>
		<content:encoded><![CDATA[<p>nice trick</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38103</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 11:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38103</guid>
		<description><![CDATA[no need to use node*,int as type of element in queue.
see nilesh comment ( go very down )
he has suggested a nice solution.
in which we are inserting a dummy node to mark the end of a level.]]></description>
		<content:encoded><![CDATA[<p>no need to use node*,int as type of element in queue.<br />
see nilesh comment ( go very down )<br />
he has suggested a nice solution.<br />
in which we are inserting a dummy node to mark the end of a level.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38077</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 09:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38077</guid>
		<description><![CDATA[My implementation of 1st method using a queue (C++) http://ideone.com/VBMwpR]]></description>
		<content:encoded><![CDATA[<p>My implementation of 1st method using a queue (C++) <a href="http://ideone.com/VBMwpR" rel="nofollow">http://ideone.com/VBMwpR</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38062</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 07:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38062</guid>
		<description><![CDATA[What will be the type of element in queue? I used node*, int pair for storing the node &#038; the level it belongs to. Is there a simpler way?]]></description>
		<content:encoded><![CDATA[<p>What will be the type of element in queue? I used node*, int pair for storing the node &amp; the level it belongs to. Is there a simpler way?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Klaus</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38046</link>
		<dc:creator><![CDATA[Klaus]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 02:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38046</guid>
		<description><![CDATA[Thanx]]></description>
		<content:encoded><![CDATA[<p>Thanx</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38045</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 02:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38045</guid>
		<description><![CDATA[2. Width is simply the no of nodes at a particular level.]]></description>
		<content:encoded><![CDATA[<p>2. Width is simply the no of nodes at a particular level.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-38031</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 19:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-38031</guid>
		<description><![CDATA[unless you are using queue for level order. it will take O(n^2).]]></description>
		<content:encoded><![CDATA[<p>unless you are using queue for level order. it will take O(n^2).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Klaus</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-37972</link>
		<dc:creator><![CDATA[Klaus]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 07:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-37972</guid>
		<description><![CDATA[What will be the max. width of following tree?
                                        A
                                     /     
                                    B      C
                                  /           
                                 D           E
                              /                 
                            F                   G           ]]></description>
		<content:encoded><![CDATA[<p>What will be the max. width of following tree?<br />
                                        A<br />
                                     /<br />
                                    B      C<br />
                                  /<br />
                                 D           E<br />
                              /<br />
                            F                   G           </p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Omi</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-37599</link>
		<dc:creator><![CDATA[Omi]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 11:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-37599</guid>
		<description><![CDATA[Using Level Order traversal With  Queue.Correct if i am wrong..

int findWidth(node* root)

{

    vector Queue;

    int count=0,max=0;

    if(root==NULL)

        return 0;

    Queue.push_back(root);

    Queue.push_back(NULL);

    while(!Queue.empty())

    {

        node* temp=Queue.front();

        Queue.erase(Queue.begin());

        if(temp==NULL)

        {

            if(!Queue.empty()){

            Queue.push_back(NULL);

            max=max&#062;count?max:count;

            count=0;

            continue;

            }

            else

            break;

        }

        count++;

        if(temp-&#062;left)

        Queue.push_back(temp-&#062;left);

        if(temp-&#062;right)

        Queue.push_back(temp-&#062;right);

    }

    return max;

}]]></description>
		<content:encoded><![CDATA[<p>Using Level Order traversal With  Queue.Correct if i am wrong..</p>
<p>int findWidth(node* root)</p>
<p>{</p>
<p>    vector Queue;</p>
<p>    int count=0,max=0;</p>
<p>    if(root==NULL)</p>
<p>        return 0;</p>
<p>    Queue.push_back(root);</p>
<p>    Queue.push_back(NULL);</p>
<p>    while(!Queue.empty())</p>
<p>    {</p>
<p>        node* temp=Queue.front();</p>
<p>        Queue.erase(Queue.begin());</p>
<p>        if(temp==NULL)</p>
<p>        {</p>
<p>            if(!Queue.empty()){</p>
<p>            Queue.push_back(NULL);</p>
<p>            max=max&gt;count?max:count;</p>
<p>            count=0;</p>
<p>            continue;</p>
<p>            }</p>
<p>            else</p>
<p>            break;</p>
<p>        }</p>
<p>        count++;</p>
<p>        if(temp-&gt;left)</p>
<p>        Queue.push_back(temp-&gt;left);</p>
<p>        if(temp-&gt;right)</p>
<p>        Queue.push_back(temp-&gt;right);</p>
<p>    }</p>
<p>    return max;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neerajks</title>
		<link>http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/#comment-37023</link>
		<dc:creator><![CDATA[neerajks]]></dc:creator>
		<pubDate>Thu, 29 May 2014 16:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7447#comment-37023</guid>
		<description><![CDATA[#include 

#include 

 

struct node

{

  int data;

  struct node* lChild;

  struct node* rChild;

};

typedef struct node *BSTNODE;

struct nodeQueue

{

  BSTNODE bstNodePtr;

  struct nodeQueue *link;

};

typedef struct nodeQueue *nodeQ;

nodeQ createQNode(BSTNODE bstNodePtr)

{

  nodeQ temp = (nodeQ)malloc(sizeof(nodeQ));

  if (temp == NULL)

  {

    printf(&quot;Not enough memoryn&quot;);

    return NULL;

  }

  temp-&#062;bstNodePtr = bstNodePtr;

  temp-&#062;link       = NULL;

  return temp;

}

void EnqueueNode(nodeQ *front, nodeQ *rear, BSTNODE bstNodePtr)

{

  nodeQ temp = NULL;

  if ((*front == NULL) &#038;&#038; (*rear == NULL))

  {

    temp  = createQNode(bstNodePtr);

    *rear = *front = temp;

    return;

  }

  else

  {

    temp = createQNode(bstNodePtr);

    (*rear)-&#062;link = temp;

    *rear         = temp;

  }

  return;

}

BSTNODE DequeueNode(nodeQ *front, nodeQ *rear)

{

  nodeQ temp = NULL;

  BSTNODE bstNodePtr = NULL;

  if ((*front == NULL) &#038;&#038; (*rear == NULL))

  {

    printf(&quot;Empty queuen&quot;);

  }

  else

  {

    temp = *front;

    *front = (*front)-&#062;link;

    *rear = ((*front == NULL) ? NULL : *rear);

    bstNodePtr = temp-&#062;bstNodePtr;

    free(temp);

    temp = NULL;

  }

  return bstNodePtr;

}

BSTNODE newNode(int data)

{

  BSTNODE temp = (BSTNODE)malloc(sizeof(BSTNODE));

  if (temp == NULL)

  {

    printf(&quot;In-sufficient memoryn&quot;);

    return 0;

  }

  temp-&#062;data   = data;

  temp-&#062;lChild = NULL;

  temp-&#062;rChild = NULL;

  return temp;

}

void insert(BSTNODE *root, int data)

{

  BSTNODE rootNode = *root;

  if (rootNode == NULL)

  {

    rootNode = newNode(data);

    *root    = rootNode;

    return;

  }

  else if (data data)

  {

    insert(&#038;rootNode-&#062;lChild,data);

  }

  else

  {

    insert(&#038;rootNode-&#062;rChild,data);

  }

 return;

}

void treeLevelCount(nodeQ *front, nodeQ *rear, int *width, int *max_width)

{

  int local_wd = *width;

  *width       = 0;

  

  if ((*front == NULL) &#038;&#038; (*rear == NULL)) 

   return;

  

  if ((*front != NULL) &#038;&#038; (*rear != NULL))

  {

    while (local_wd != 0)

    {

      BSTNODE temp = DequeueNode(front, rear);

      if ((temp != NULL) &#038;&#038; (temp-&#062;lChild))

      {

        EnqueueNode(front, rear, temp-&#062;lChild);

        (*width)++;

      }

      if ((temp != NULL) &#038;&#038; (temp-&#062;rChild))

      {

        EnqueueNode(front, rear, temp-&#062;rChild);

        (*width)++;

      }

      local_wd--;

    }

   } 

  if (*max_width &#060; *width)

  {

    *max_width = *width;

  }

  treeLevelCount(front, rear, width, max_width);

}

int main()

{

  BSTNODE root = NULL;

  nodeQ front  = NULL;

  nodeQ rear   = NULL;

  int width    = 1;

  int tree_width = 1;

  insert(&#038;root,6);

  insert(&#038;root,4);

  insert(&#038;root,8);

  insert(&#038;root,3);

  insert(&#038;root,5);

  insert(&#038;root,7);

  insert(&#038;root,9);

  /* Enqueue root node */

  EnqueueNode(&#038;front, &#038;rear, root);

  treeLevelCount(&#038;front, &#038;rear, &#038;width, &#038;tree_width);

  printf(&#034;Width of Tree:%dn&#034;,tree_width);

  return 0;

}]]></description>
		<content:encoded><![CDATA[<p>#include </p>
<p>#include </p>
<p>struct node</p>
<p>{</p>
<p>  int data;</p>
<p>  struct node* lChild;</p>
<p>  struct node* rChild;</p>
<p>};</p>
<p>typedef struct node *BSTNODE;</p>
<p>struct nodeQueue</p>
<p>{</p>
<p>  BSTNODE bstNodePtr;</p>
<p>  struct nodeQueue *link;</p>
<p>};</p>
<p>typedef struct nodeQueue *nodeQ;</p>
<p>nodeQ createQNode(BSTNODE bstNodePtr)</p>
<p>{</p>
<p>  nodeQ temp = (nodeQ)malloc(sizeof(nodeQ));</p>
<p>  if (temp == NULL)</p>
<p>  {</p>
<p>    printf(&#8220;Not enough memoryn&#8221;);</p>
<p>    return NULL;</p>
<p>  }</p>
<p>  temp-&gt;bstNodePtr = bstNodePtr;</p>
<p>  temp-&gt;link       = NULL;</p>
<p>  return temp;</p>
<p>}</p>
<p>void EnqueueNode(nodeQ *front, nodeQ *rear, BSTNODE bstNodePtr)</p>
<p>{</p>
<p>  nodeQ temp = NULL;</p>
<p>  if ((*front == NULL) &amp;&amp; (*rear == NULL))</p>
<p>  {</p>
<p>    temp  = createQNode(bstNodePtr);</p>
<p>    *rear = *front = temp;</p>
<p>    return;</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>    temp = createQNode(bstNodePtr);</p>
<p>    (*rear)-&gt;link = temp;</p>
<p>    *rear         = temp;</p>
<p>  }</p>
<p>  return;</p>
<p>}</p>
<p>BSTNODE DequeueNode(nodeQ *front, nodeQ *rear)</p>
<p>{</p>
<p>  nodeQ temp = NULL;</p>
<p>  BSTNODE bstNodePtr = NULL;</p>
<p>  if ((*front == NULL) &amp;&amp; (*rear == NULL))</p>
<p>  {</p>
<p>    printf(&#8220;Empty queuen&#8221;);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>    temp = *front;</p>
<p>    *front = (*front)-&gt;link;</p>
<p>    *rear = ((*front == NULL) ? NULL : *rear);</p>
<p>    bstNodePtr = temp-&gt;bstNodePtr;</p>
<p>    free(temp);</p>
<p>    temp = NULL;</p>
<p>  }</p>
<p>  return bstNodePtr;</p>
<p>}</p>
<p>BSTNODE newNode(int data)</p>
<p>{</p>
<p>  BSTNODE temp = (BSTNODE)malloc(sizeof(BSTNODE));</p>
<p>  if (temp == NULL)</p>
<p>  {</p>
<p>    printf(&#8220;In-sufficient memoryn&#8221;);</p>
<p>    return 0;</p>
<p>  }</p>
<p>  temp-&gt;data   = data;</p>
<p>  temp-&gt;lChild = NULL;</p>
<p>  temp-&gt;rChild = NULL;</p>
<p>  return temp;</p>
<p>}</p>
<p>void insert(BSTNODE *root, int data)</p>
<p>{</p>
<p>  BSTNODE rootNode = *root;</p>
<p>  if (rootNode == NULL)</p>
<p>  {</p>
<p>    rootNode = newNode(data);</p>
<p>    *root    = rootNode;</p>
<p>    return;</p>
<p>  }</p>
<p>  else if (data data)</p>
<p>  {</p>
<p>    insert(&amp;rootNode-&gt;lChild,data);</p>
<p>  }</p>
<p>  else</p>
<p>  {</p>
<p>    insert(&amp;rootNode-&gt;rChild,data);</p>
<p>  }</p>
<p> return;</p>
<p>}</p>
<p>void treeLevelCount(nodeQ *front, nodeQ *rear, int *width, int *max_width)</p>
<p>{</p>
<p>  int local_wd = *width;</p>
<p>  *width       = 0;</p>
<p>  if ((*front == NULL) &amp;&amp; (*rear == NULL)) </p>
<p>   return;</p>
<p>  if ((*front != NULL) &amp;&amp; (*rear != NULL))</p>
<p>  {</p>
<p>    while (local_wd != 0)</p>
<p>    {</p>
<p>      BSTNODE temp = DequeueNode(front, rear);</p>
<p>      if ((temp != NULL) &amp;&amp; (temp-&gt;lChild))</p>
<p>      {</p>
<p>        EnqueueNode(front, rear, temp-&gt;lChild);</p>
<p>        (*width)++;</p>
<p>      }</p>
<p>      if ((temp != NULL) &amp;&amp; (temp-&gt;rChild))</p>
<p>      {</p>
<p>        EnqueueNode(front, rear, temp-&gt;rChild);</p>
<p>        (*width)++;</p>
<p>      }</p>
<p>      local_wd&#8211;;</p>
<p>    }</p>
<p>   } </p>
<p>  if (*max_width &lt; *width)</p>
<p>  {</p>
<p>    *max_width = *width;</p>
<p>  }</p>
<p>  treeLevelCount(front, rear, width, max_width);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  BSTNODE root = NULL;</p>
<p>  nodeQ front  = NULL;</p>
<p>  nodeQ rear   = NULL;</p>
<p>  int width    = 1;</p>
<p>  int tree_width = 1;</p>
<p>  insert(&amp;root,6);</p>
<p>  insert(&amp;root,4);</p>
<p>  insert(&amp;root,8);</p>
<p>  insert(&amp;root,3);</p>
<p>  insert(&amp;root,5);</p>
<p>  insert(&amp;root,7);</p>
<p>  insert(&amp;root,9);</p>
<p>  /* Enqueue root node */</p>
<p>  EnqueueNode(&amp;front, &amp;rear, root);</p>
<p>  treeLevelCount(&amp;front, &amp;rear, &amp;width, &amp;tree_width);</p>
<p>  printf(&quot;Width of Tree:%dn&quot;,tree_width);</p>
<p>  return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:03:50 -->

<!-- Compression = gzip -->