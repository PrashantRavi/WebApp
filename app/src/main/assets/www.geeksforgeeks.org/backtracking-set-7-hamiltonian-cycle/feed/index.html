<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Backtracking &#124; Set 6 (Hamiltonian Cycle)</title>
	<atom:link href="http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: arjomanD</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-35860</link>
		<dc:creator><![CDATA[arjomanD]]></dc:creator>
		<pubDate>Sat, 10 May 2014 07:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-35860</guid>
		<description><![CDATA[i think my code is much simpler 

http://paste.ubuntu.com/7432194/]]></description>
		<content:encoded><![CDATA[<p>i think my code is much simpler </p>
<p><a href="http://paste.ubuntu.com/7432194/" rel="nofollow">http://paste.ubuntu.com/7432194/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: arjomanD</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-35859</link>
		<dc:creator><![CDATA[arjomanD]]></dc:creator>
		<pubDate>Sat, 10 May 2014 07:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-35859</guid>
		<description><![CDATA[I had a question . (or maybe im wrong cuz i havn&#039;t still read the code) does this program find 
Hamiltonian path ?]]></description>
		<content:encoded><![CDATA[<p>I had a question . (or maybe im wrong cuz i havn&#8217;t still read the code) does this program find<br />
Hamiltonian path ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: hxgxs1</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-35211</link>
		<dc:creator><![CDATA[hxgxs1]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 01:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-35211</guid>
		<description><![CDATA[time complexity should be O(N!)..there id a for loop in a recursive call so...
T(N)=N*(T(N-1) + O(1)) or
T(N)=N*(N-1)*(N-2)...=O(N!)]]></description>
		<content:encoded><![CDATA[<p>time complexity should be O(N!)..there id a for loop in a recursive call so&#8230;<br />
T(N)=N*(T(N-1) + O(1)) or<br />
T(N)=N*(N-1)*(N-2)&#8230;=O(N!)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-35010</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Wed, 23 Apr 2014 03:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-35010</guid>
		<description><![CDATA[What would be the time complexity for this problem? Wikipedia says it can not be solved in Polynomial time as its a NP-Complete problem]]></description>
		<content:encoded><![CDATA[<p>What would be the time complexity for this problem? Wikipedia says it can not be solved in Polynomial time as its a NP-Complete problem</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-30321</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 11:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-30321</guid>
		<description><![CDATA[# include 
  #include 
// Number of vertices in the graph
#define V 5
 
void printSolution(int path[]);
 
int stack[V];
int top;
bool hamCycle(bool graph[V][V],bool*seen,int vertex)

{
    int i;
 for(i=0;i&#060;V;i++)
 {
    if(graph[vertex][i]==1 &#038;&#038; seen[i]==false)
    {
        seen[i]=true;
        stack[++top]=i;
        if(hamCycle(graph,seen,i))
            return true;
        else
            top--;

    }
 }
 return false;
 
 
}
 

 
// driver program to test above function
int main()
{
   /* Let us create the following graph
      (0)--(1)--(2)
       &#124;   /    &#124;
       &#124;  /     &#124;
       &#124; /      &#124;
      (3)-------(4)    */
   bool graph1[V][V] = {{0, 1, 0, 1, 0},
                      {1, 0, 1, 1, 1},
                      {0, 1, 0, 0, 1},
                      {1, 1, 0, 0, 1},
                      {0, 1, 1, 1, 0},
                     };
 
    // Print the solution
                       bool seen[V]={false};
  seen[0]=true;
  stack[0]=0;
    hamCycle(graph1,seen,0)
       
       if(top==V)
        printf(&#034;there exists hamcyclen&#034;);
 
int i;

 for(i=0;i &quot;,stack[i] );
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p># include<br />
  #include<br />
// Number of vertices in the graph<br />
#define V 5</p>
<p>void printSolution(int path[]);</p>
<p>int stack[V];<br />
int top;<br />
bool hamCycle(bool graph[V][V],bool*seen,int vertex)</p>
<p>{<br />
    int i;<br />
 for(i=0;i&lt;V;i++)<br />
 {<br />
    if(graph[vertex][i]==1 &amp;&amp; seen[i]==false)<br />
    {<br />
        seen[i]=true;<br />
        stack[++top]=i;<br />
        if(hamCycle(graph,seen,i))<br />
            return true;<br />
        else<br />
            top&#8211;;</p>
<p>    }<br />
 }<br />
 return false;</p>
<p>}</p>
<p>// driver program to test above function<br />
int main()<br />
{<br />
   /* Let us create the following graph<br />
      (0)&#8211;(1)&#8211;(2)<br />
       |   /    |<br />
       |  /     |<br />
       | /      |<br />
      (3)&#8212;&#8212;-(4)    */<br />
   bool graph1[V][V] = {{0, 1, 0, 1, 0},<br />
                      {1, 0, 1, 1, 1},<br />
                      {0, 1, 0, 0, 1},<br />
                      {1, 1, 0, 0, 1},<br />
                      {0, 1, 1, 1, 0},<br />
                     };</p>
<p>    // Print the solution<br />
                       bool seen[V]={false};<br />
  seen[0]=true;<br />
  stack[0]=0;<br />
    hamCycle(graph1,seen,0)</p>
<p>       if(top==V)<br />
        printf(&quot;there exists hamcyclen&quot;);</p>
<p>int i;</p>
<p> for(i=0;i &#8220;,stack[i] );<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-30322</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 11:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-30322</guid>
		<description><![CDATA[bool hamCycle(bool graph[V][V],bool*seen,int vertex)

{
    int i;
 for(i=0;i&#060;V;i++)
 {
    if(graph[vertex][i]==1 &#038;&#038; seen[i]==false)
    {
        seen[i]=true;
        stack[++top]=i;
        if(hamCycle(graph,seen,i))
            return true;
        else
            top--;

    }
 }
 return false;
 
 
}]]></description>
		<content:encoded><![CDATA[<p>bool hamCycle(bool graph[V][V],bool*seen,int vertex)</p>
<p>{<br />
    int i;<br />
 for(i=0;i&lt;V;i++)<br />
 {<br />
    if(graph[vertex][i]==1 &amp;&amp; seen[i]==false)<br />
    {<br />
        seen[i]=true;<br />
        stack[++top]=i;<br />
        if(hamCycle(graph,seen,i))<br />
            return true;<br />
        else<br />
            top&#8211;;</p>
<p>    }<br />
 }<br />
 return false;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sriharsha g.r.v</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-30272</link>
		<dc:creator><![CDATA[Sriharsha g.r.v]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 20:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-30272</guid>
		<description><![CDATA[hi can u pls elaborate and explain with example..]]></description>
		<content:encoded><![CDATA[<p>hi can u pls elaborate and explain with example..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: da3m0n</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-29953</link>
		<dc:creator><![CDATA[da3m0n]]></dc:creator>
		<pubDate>Mon, 18 Nov 2013 14:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-29953</guid>
		<description><![CDATA[Time Complexity please..]]></description>
		<content:encoded><![CDATA[<p>Time Complexity please..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: begfairouz</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-29204</link>
		<dc:creator><![CDATA[begfairouz]]></dc:creator>
		<pubDate>Tue, 22 Oct 2013 14:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-29204</guid>
		<description><![CDATA[Hi,

In the beggining i have to thank you for your program, it works well.
But i tried to use it for a graph[V][V] with V=120 but the program doesn&#039;t return result ( neither positive or negative). Did you try it for big matrices?]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>In the beggining i have to thank you for your program, it works well.<br />
But i tried to use it for a graph[V][V] with V=120 but the program doesn&#8217;t return result ( neither positive or negative). Did you try it for big matrices?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pavansrinivas</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-28954</link>
		<dc:creator><![CDATA[pavansrinivas]]></dc:creator>
		<pubDate>Wed, 16 Oct 2013 11:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-28954</guid>
		<description><![CDATA[Algorithm for finding  whether a graph is Hamiltonian or not: 
Do DFS &#038;maintain count of the adjacent unvisited vertices
If ( there is no adjacent unvisited vertex){
if the count is  equal to the num of vertices
    return true;
else 
return false;
}]]></description>
		<content:encoded><![CDATA[<p>Algorithm for finding  whether a graph is Hamiltonian or not:<br />
Do DFS &amp;maintain count of the adjacent unvisited vertices<br />
If ( there is no adjacent unvisited vertex){<br />
if the count is  equal to the num of vertices<br />
    return true;<br />
else<br />
return false;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Born Actor</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/#comment-20108</link>
		<dc:creator><![CDATA[Born Actor]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 15:12:49 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19092#comment-20108</guid>
		<description><![CDATA[[sourcecode language=&quot;C++&quot;]
/* #include &#060;iostream&#062;
#include&#060;string&#062;
#include&#060;sstream&#062;
#include&#060;iomanip&#062;
# include &#060;stdio.h&#062;
# include &#060;math.h&#062;
#include &#060;vector&#062;
#include &#060;stdlib.h&#062;
using namespace std;
int a[50][50];
int n;

std::vector &#060; pair &#060;int, int &#062; &#062;edges;
int visited[50];
int cycle(int node);
void print();
int main()
{
	int i,j;
	cout&#060;&#060;&#034;enter the size&#034;&#060;&#060;endl;
	cin&#062;&#062;n;
	for(i=0;i&#060;n;i++)
		for(j=0;j&#060;n;j++)
			cin&#062;&#062;a[i][j];
	for(i=0;i&#060;n;i++)
		visited[i]=0;
	for(i=0;i&#060;n;i++)
	{
		for(j=0;j&#060;n;j++)
		{
			if(a[i][j]==1)
				a[j][i]=1;
		}
	}
	cout&#060;&#060;cycle(0)&#060;&#060;endl;
	print();
}
int cycle(int node)
{
	visited[node]=1;
	int flag=0;
	int j;
	for(j=0;j&#060;n;j++)
	{
		if(a[node][j]==1 &#038;&#038; visited[j]==0)
		{
			if(cycle(j)==1)
			{
				edges.push_back(make_pair(node,j));		
				return 1;
		
			}
			visited[j]=0;
		}

	}
	for(j=0;j&#060;n;j++)
	{
		if(visited[j]==0)
		{
			flag=1;
			break;
		}
	}
	if(flag==0)
	{
		if(a[node][0]==1)
		{
			edges.push_back(make_pair(node,0));
			return 1;
		}
	}
	visited[node]=0;
	return 0;
}
void print()
{
	int i;
	cout&#060;&#060;endl&#060;&#060;&#034;The edges between these nodes form the Hamiltonian cycle&#034;&#060;&#060;endl;
	for(i=edges.size()-1;i&#062;=0;i--)
		cout&#060;&#060;edges[i].first&#060;&#060;&#034;  &#034;&#060;&#060;edges[i].second&#060;&#060;&#034;  &#034;&#060;&#060;endl;
}



 */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>/* #include &lt;iostream&gt;<br />
#include&lt;string&gt;<br />
#include&lt;sstream&gt;<br />
#include&lt;iomanip&gt;<br />
# include &lt;stdio.h&gt;<br />
# include &lt;math.h&gt;<br />
#include &lt;vector&gt;<br />
#include &lt;stdlib.h&gt;<br />
using namespace std;<br />
int a[50][50];<br />
int n;</p>
<p>std::vector &lt; pair &lt;int, int &gt; &gt;edges;<br />
int visited[50];<br />
int cycle(int node);<br />
void print();<br />
int main()<br />
{<br />
	int i,j;<br />
	cout&lt;&lt;&quot;enter the size&quot;&lt;&lt;endl;<br />
	cin&gt;&gt;n;<br />
	for(i=0;i&lt;n;i++)<br />
		for(j=0;j&lt;n;j++)<br />
			cin&gt;&gt;a[i][j];<br />
	for(i=0;i&lt;n;i++)<br />
		visited[i]=0;<br />
	for(i=0;i&lt;n;i++)<br />
	{<br />
		for(j=0;j&lt;n;j++)<br />
		{<br />
			if(a[i][j]==1)<br />
				a[j][i]=1;<br />
		}<br />
	}<br />
	cout&lt;&lt;cycle(0)&lt;&lt;endl;<br />
	print();<br />
}<br />
int cycle(int node)<br />
{<br />
	visited[node]=1;<br />
	int flag=0;<br />
	int j;<br />
	for(j=0;j&lt;n;j++)<br />
	{<br />
		if(a[node][j]==1 &amp;&amp; visited[j]==0)<br />
		{<br />
			if(cycle(j)==1)<br />
			{<br />
				edges.push_back(make_pair(node,j));<br />
				return 1;</p>
<p>			}<br />
			visited[j]=0;<br />
		}</p>
<p>	}<br />
	for(j=0;j&lt;n;j++)<br />
	{<br />
		if(visited[j]==0)<br />
		{<br />
			flag=1;<br />
			break;<br />
		}<br />
	}<br />
	if(flag==0)<br />
	{<br />
		if(a[node][0]==1)<br />
		{<br />
			edges.push_back(make_pair(node,0));<br />
			return 1;<br />
		}<br />
	}<br />
	visited[node]=0;<br />
	return 0;<br />
}<br />
void print()<br />
{<br />
	int i;<br />
	cout&lt;&lt;endl&lt;&lt;&quot;The edges between these nodes form the Hamiltonian cycle&quot;&lt;&lt;endl;<br />
	for(i=edges.size()-1;i&gt;=0;i&#8211;)<br />
		cout&lt;&lt;edges[i].first&lt;&lt;&quot;  &quot;&lt;&lt;edges[i].second&lt;&lt;&quot;  &quot;&lt;&lt;endl;<br />
}</p>
<p> */</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:12:04 -->

<!-- Compression = gzip -->