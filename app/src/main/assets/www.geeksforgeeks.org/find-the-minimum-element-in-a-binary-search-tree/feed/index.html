<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find the node with minimum value in a Binary Search Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Deepesh Panjabi</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-39252</link>
		<dc:creator><![CDATA[Deepesh Panjabi]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 13:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-39252</guid>
		<description><![CDATA[http://ideone.com/Nehz7B]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/Nehz7B" rel="nofollow">http://ideone.com/Nehz7B</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lloyd Chakandinakira</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-36918</link>
		<dc:creator><![CDATA[Lloyd Chakandinakira]]></dc:creator>
		<pubDate>Tue, 27 May 2014 15:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-36918</guid>
		<description><![CDATA[why would you want to search the left child, when the objective is to find the maximum value in a binary SEARCH tree. Any data elements to the left child are less than the root node, and all the elements on the right side are greater than the node, so we are simply looking for the right most child.]]></description>
		<content:encoded><![CDATA[<p>why would you want to search the left child, when the objective is to find the maximum value in a binary SEARCH tree. Any data elements to the left child are less than the root node, and all the elements on the right side are greater than the node, so we are simply looking for the right most child.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pranav</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-30850</link>
		<dc:creator><![CDATA[Pranav]]></dc:creator>
		<pubDate>Thu, 19 Dec 2013 06:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-30850</guid>
		<description><![CDATA[I think for binary tree you need to traverse the tree(in any of your choice manner), and keep track of the minimum found so far.

int minValue(struct node* node) {
return minValueUtil(node, INT_MAX);
}

int minValueUtil(struct node* node, int min)
{
if(!node) return;

// Check left subtree first
return minValueUtil(node-&#062;left, node-&#062;data);

//Check current node
if(node-&#062;data data;

// Check right subtree 
return minValueUtil(node-&#062;right, node-&#062;data);
}]]></description>
		<content:encoded><![CDATA[<p>I think for binary tree you need to traverse the tree(in any of your choice manner), and keep track of the minimum found so far.</p>
<p>int minValue(struct node* node) {<br />
return minValueUtil(node, INT_MAX);<br />
}</p>
<p>int minValueUtil(struct node* node, int min)<br />
{<br />
if(!node) return;</p>
<p>// Check left subtree first<br />
return minValueUtil(node-&gt;left, node-&gt;data);</p>
<p>//Check current node<br />
if(node-&gt;data data;</p>
<p>// Check right subtree<br />
return minValueUtil(node-&gt;right, node-&gt;data);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GuruSimhe</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-30555</link>
		<dc:creator><![CDATA[GuruSimhe]]></dc:creator>
		<pubDate>Sun, 08 Dec 2013 19:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-30555</guid>
		<description><![CDATA[It is actually O(h), but in case of Left skewed tree it will be O(n) and that is our worst case.]]></description>
		<content:encoded><![CDATA[<p>It is actually O(h), but in case of Left skewed tree it will be O(n) and that is our worst case.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: DarkProtocol</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-28669</link>
		<dc:creator><![CDATA[DarkProtocol]]></dc:creator>
		<pubDate>Thu, 10 Oct 2013 17:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-28669</guid>
		<description><![CDATA[is it O(n) or O(h) where h is height of the tree.. Pls explain,,,]]></description>
		<content:encoded><![CDATA[<p>is it O(n) or O(h) where h is height of the tree.. Pls explain,,,</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wannaC</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-22264</link>
		<dc:creator><![CDATA[wannaC]]></dc:creator>
		<pubDate>Tue, 16 Jul 2013 22:40:01 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-22264</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int minVal(struct node *root){
if(!root)
   return -1;
if(root-&#062;left==NULL)
{
   return root-&#062;data;
}
else
   minVal (root-&#062;left);
return -1;
}
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
int minVal(struct node *root){
if(!root)
   return -1;
if(root-&gt;left==NULL)
{
   return root-&gt;data;
}
else
   minVal (root-&gt;left);
return -1;
}
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-21044</link>
		<dc:creator><![CDATA[Himanshu]]></dc:creator>
		<pubDate>Tue, 02 Jul 2013 10:33:28 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-21044</guid>
		<description><![CDATA[/* here is recursive method*/
int minValue(struct node* node) {
  
  if(node==NULL)
  {
      printf(&quot;emptry tree&quot;);
      return -1;
  }
        
     if(node-&#062;left==NULL)
     {
       return node-&#062;data;
     }
     else
      return minValue(node-&#062;left);
 
}]]></description>
		<content:encoded><![CDATA[<p>/* here is recursive method*/<br />
int minValue(struct node* node) {</p>
<p>  if(node==NULL)<br />
  {<br />
      printf(&#8220;emptry tree&#8221;);<br />
      return -1;<br />
  }</p>
<p>     if(node-&gt;left==NULL)<br />
     {<br />
       return node-&gt;data;<br />
     }<br />
     else<br />
      return minValue(node-&gt;left);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: amit</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-18770</link>
		<dc:creator><![CDATA[amit]]></dc:creator>
		<pubDate>Tue, 28 May 2013 04:44:11 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-18770</guid>
		<description><![CDATA[won&#039;t work for empty binary tree..no NULL check


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>won&#8217;t work for empty binary tree..no NULL check</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-18046</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Thu, 09 May 2013 16:11:39 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-18046</guid>
		<description><![CDATA[C++ code: extended from my post on: http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;iostream&#062;
#include &#060;stdlib.h&#062;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&#062;data=data;
    }
    int get_data() {
      return this-&#062;data;
    }
    void set_left(tree_node * left) {
      this-&#062;left=left;
    }
    tree_node * get_left() {
      return this-&#062;left;
    }
    void set_right(tree_node * right) {
      this-&#062;right=right;
    }
    tree_node * get_right() {
      return this-&#062;right;
    }
    tree_node ** get_left_ref() {
      return &#038;(this-&#062;left);
    }
    tree_node ** get_right_ref() {
      return &#038;(this-&#062;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&#062;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&#062;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&#062;set_data(value);
    while(current!=NULL) {
      if(value&#060;=current-&#062;get_data()) {
        parent=current;
        current=current-&#062;get_left();
      } else {
        parent=current;
        current=current-&#062;get_right();
      }
    }
    if(value&#060;=parent-&#062;get_data() &#038;&#038; parent-&#062;get_left()==NULL) {
      parent-&#062;set_left(new_node);
    } else if(value&#062;parent-&#062;get_data() &#038;&#038; parent-&#062;get_right()==NULL) {
      parent-&#062;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&#038;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&#062;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&#060;=(*root_ref)-&#062;get_data()) {
      _recursive_insert((*root_ref)-&#062;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&#062;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
  if(root-&#062;get_left()!=NULL)
    _print_preorder(root-&#062;get_left());
  if(root-&#062;get_right()!=NULL)
    _print_preorder(root-&#062;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&#062;get_left()!=NULL)
    _print_inorder(root-&#062;get_left());
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
  if(root-&#062;get_right()!=NULL)
    _print_inorder(root-&#062;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&#060;&#060;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&#062;get_left()!=NULL)
    _print_postorder(root-&#062;get_left());
  if(root-&#062;get_right()!=NULL)
    _print_postorder(root-&#062;get_right());
  cout&#060;&#060;root-&#062;get_data()&#060;&#060;&#034; &#034;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&#062;get_left())+_find_size(root-&#062;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&#062;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &#038;&#038; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &#038;&#038; tn2!=NULL) &#124;&#124; (tn1!=NULL &#038;&#038; tn2==NULL) &#124;&#124; (tn1-&#062;get_data()!=tn2-&#062;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&#062;get_left(), tn2-&#062;get_left()) &#038;&#038; _are_identical(tn1-&#062;get_right(), tn2-&#062;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&#062;get_left()), _find_height(root-&#062;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&#038;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&#062;get_left()!=NULL) {
      _delete_tree((*root)-&#062;get_left_ref());
    }
    if((*root)-&#062;get_right()!=NULL) {
      _delete_tree((*root)-&#062;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&#062;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&#062;get_left();
      _delete_tree(&#038;left_ref);
    }
    if((*root)-&#062;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&#062;get_right();
      _delete_tree(&#038;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&#062;get_left();
  root-&#062;set_left(root-&#062;get_right());
  root-&#062;set_right(temp);
  _mirror(root-&#062;get_left());
  _mirror(root-&#062;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&#062;get_left()==NULL &#038;&#038; root-&#062;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&#062;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&#062;get_data();
    _print_paths(root-&#062;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&#062;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&#060;=len; i++) {
    cout&#060;&#060;*(array+i)&#060;&#060;&#034; &#034;;
  }
  cout&#060;&#060;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL &#124;&#124; root-&#062;get_data()==value) {
    return root;
  } else if(value&#060;=root-&#062;get_data()) {
    _find_node(root-&#062;get_left(), value);
  } else {
    _find_node(root-&#062;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&#062;get_data()==a &#038;&#038; (root-&#062;get_left()-&#062;get_data()==b &#124;&#124; root-&#062;get_right()-&#062;get_data()==b))
             &#124;&#124; (root-&#062;get_data()==b &#038;&#038; (root-&#062;get_left()-&#062;get_data()==a &#124;&#124; root-&#062;get_right()-&#062;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&#062;get_left(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), b)!=NULL)
        &#124;&#124; (_find_node(root-&#062;get_left(), b)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&#062;get_left(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&#062;get_left(), a, b);
  } else if(_find_node(root-&#062;get_right(), a)!=NULL &#038;&#038; _find_node(root-&#062;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&#062;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL &#124;&#124; root-&#062;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&#062;get_left());
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);

  cout&#060;&#060;&#034;Inorder Traversal&#034;&#060;&#060;endl;
  t1.print_inorder();

  tree_node * min_node=t1.min_node();
  if(min_node!=NULL) {
    cout&#060;&#060;&#034;Minimum node value: &#034;&#060;&#060;min_node-&#062;get_data()&#060;&#060;endl;
  } else {
    cout&#060;&#060;&#034;Tree is empty&#034;&#060;&#060;endl;
  }

  return 0;
}
&lt;/code&gt; &lt;/pre&gt;

Inorder Traversal
3 5 6 7 10 50 
Minimum node value: 3]]></description>
		<content:encoded><![CDATA[<p>C++ code: extended from my post on: <a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/" rel="nofollow">http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/</a></p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;
 
class tree_node {
  private:
    int data;
    tree_node * left;
    tree_node * right;
  public:
    tree_node() {
      left=NULL;
      right=NULL;
    }
    void set_data(int data) {
      this-&gt;data=data;
    }
    int get_data() {
      return this-&gt;data;
    }
    void set_left(tree_node * left) {
      this-&gt;left=left;
    }
    tree_node * get_left() {
      return this-&gt;left;
    }
    void set_right(tree_node * right) {
      this-&gt;right=right;
    }
    tree_node * get_right() {
      return this-&gt;right;
    }
    tree_node ** get_left_ref() {
      return &amp;(this-&gt;left);
    }
    tree_node ** get_right_ref() {
      return &amp;(this-&gt;right);
    }
};
 
class tree {
  private:
    tree_node * root;
    int size;
    void _recursive_insert(tree_node ** root_ref, int value);
    void _print_preorder(tree_node * root);
    void _print_inorder(tree_node * root);
    void _print_postorder(tree_node * root);
    int _find_size(tree_node * root);
    int _are_identical(tree_node * tn1, tree_node * tn2);
    int _find_height(tree_node * root);
    void _delete_tree(tree_node ** root);
    void _mirror(tree_node * root);
    void _print_paths(tree_node * root, int * path_nodes, int next_vacant_position);
    void _print_array(int * array, int len);
    tree_node * _lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b);
    tree_node * _find_node(tree_node * root, int value);
    tree_node * _min_node(tree_node * root);
  public:
    tree() {
      root=NULL;
      size=0;
    }
    void insert(int value);
    void recursive_insert(int value);
    void print_preorder();
    void print_inorder();
    void print_postorder();
    int find_size();
    int get_size() {
      return this-&gt;size;
    }
    int are_identical(tree t);
    int find_height();
    void delete_tree();
    void mirror();
    void print_paths();
    tree_node * lowest_common_ancestor(int a, int b);
    tree_node * find_node(int value);
    tree_node * min_node();
};
 
void tree::insert(int value) {
  if(root==NULL) {
    root=new tree_node;
    root-&gt;set_data(value);
  } else {
    tree_node * parent=NULL;
    tree_node * current=root;
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    while(current!=NULL) {
      if(value&lt;=current-&gt;get_data()) {
        parent=current;
        current=current-&gt;get_left();
      } else {
        parent=current;
        current=current-&gt;get_right();
      }
    }
    if(value&lt;=parent-&gt;get_data() &amp;&amp; parent-&gt;get_left()==NULL) {
      parent-&gt;set_left(new_node);
    } else if(value&gt;parent-&gt;get_data() &amp;&amp; parent-&gt;get_right()==NULL) {
      parent-&gt;set_right(new_node);
    }
  }
  size++;
}
 
void tree::recursive_insert(int value) {
  _recursive_insert(&amp;root, value);
  size++;
}
 
void tree::_recursive_insert(tree_node ** root_ref, int value) {
  if(*root_ref==NULL) {
    tree_node * new_node=new tree_node;
    new_node-&gt;set_data(value);
    *root_ref=new_node;   
  } else {
    if(value&lt;=(*root_ref)-&gt;get_data()) {
      _recursive_insert((*root_ref)-&gt;get_left_ref(), value);
    } else {
      _recursive_insert((*root_ref)-&gt;get_right_ref(), value);
    }
  }
}
 
void tree::print_preorder() {
  if(root==NULL) {
    return;
  }
  _print_preorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_preorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_left()!=NULL)
    _print_preorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_preorder(root-&gt;get_right());
}
 
void tree::print_inorder() {
  if(root==NULL) {
    return;
  }
  _print_inorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_inorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_inorder(root-&gt;get_left());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
  if(root-&gt;get_right()!=NULL)
    _print_inorder(root-&gt;get_right());
}
 
void tree::print_postorder() {
  if(root==NULL) {
    return;
  }
  _print_postorder(root);
  cout&lt;&lt;endl;
}
 
void tree::_print_postorder(tree_node * root) {
  if(root==NULL) {
    return;
  }
  if(root-&gt;get_left()!=NULL)
    _print_postorder(root-&gt;get_left());
  if(root-&gt;get_right()!=NULL)
    _print_postorder(root-&gt;get_right());
  cout&lt;&lt;root-&gt;get_data()&lt;&lt;&quot; &quot;;
}

int tree::find_size() {
  return _find_size(root);
}

int tree::_find_size(tree_node * root) {
  if(root==NULL) {
    return 0;
  } else {
    return 1+_find_size(root-&gt;get_left())+_find_size(root-&gt;get_right());
  }
}

int tree::are_identical(tree t) {
  return _are_identical(this-&gt;root, t.root);
}

int tree::_are_identical(tree_node * tn1, tree_node * tn2) {
  if(tn1==NULL &amp;&amp; tn2==NULL) {
    return 1;
  } else if((tn1==NULL &amp;&amp; tn2!=NULL) || (tn1!=NULL &amp;&amp; tn2==NULL) || (tn1-&gt;get_data()!=tn2-&gt;get_data())) {
    return 0;
  } else {
    return _are_identical(tn1-&gt;get_left(), tn2-&gt;get_left()) &amp;&amp; _are_identical(tn1-&gt;get_right(), tn2-&gt;get_right());
  }
}

int tree::find_height() {
  return _find_height(root);
}

int tree::_find_height(tree_node * root) {
  if(root==NULL) {
    return 0;
  }
  else {
    return 1+max(_find_height(root-&gt;get_left()), _find_height(root-&gt;get_right()));
  }
}

void tree::delete_tree() {
  _delete_tree(&amp;root);
  size=0;
}

void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      _delete_tree((*root)-&gt;get_left_ref());
    }
    if((*root)-&gt;get_right()!=NULL) {
      _delete_tree((*root)-&gt;get_right_ref());
    }
    delete(*root);
    *root=NULL;
  }
}

/* alternate _delete_tree */
/*
void tree::_delete_tree(tree_node ** root) {
  if(*root==NULL) {
    return;
  } else {
    if((*root)-&gt;get_left()!=NULL) {
      tree_node * left_ref=(*root)-&gt;get_left();
      _delete_tree(&amp;left_ref);
    }
    if((*root)-&gt;get_right()!=NULL) {
      tree_node * right_ref=(*root)-&gt;get_right();
      _delete_tree(&amp;right_ref);
    }
    delete(*root);
    *root=NULL;
  }
}
*/

void tree::mirror() {
  _mirror(root);
}

void tree::_mirror(tree_node * root) {
  if(root==NULL) {
    return;
  }

  tree_node * temp=root-&gt;get_left();
  root-&gt;set_left(root-&gt;get_right());
  root-&gt;set_right(temp);
  _mirror(root-&gt;get_left());
  _mirror(root-&gt;get_right());
}

void tree::print_paths(){
   int max_path_length=find_height();
   int * path_nodes=(int *)calloc(sizeof(int), max_path_length);
  _print_paths(root, path_nodes, 0);
}

void tree::_print_paths(tree_node * root, int * path_nodes, int next_vacant_position){
  if(root==NULL) {
    return;
  } else if(root-&gt;get_left()==NULL &amp;&amp; root-&gt;get_right()==NULL) {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_array(path_nodes, next_vacant_position);
  } else {
    *(path_nodes+next_vacant_position)=root-&gt;get_data();
    _print_paths(root-&gt;get_left(), path_nodes, next_vacant_position+1);
    _print_paths(root-&gt;get_right(), path_nodes, next_vacant_position+1);
  }
}

void tree::_print_array(int * array, int len) {
  int i;
  for(i=0; i&lt;=len; i++) {
    cout&lt;&lt;*(array+i)&lt;&lt;&quot; &quot;;
  }
  cout&lt;&lt;endl;
}

tree_node * tree::find_node(int value) {
  return _find_node(root, value);
}

tree_node * tree::_find_node(tree_node * root, int value) {
  if(root==NULL || root-&gt;get_data()==value) {
    return root;
  } else if(value&lt;=root-&gt;get_data()) {
    _find_node(root-&gt;get_left(), value);
  } else {
    _find_node(root-&gt;get_right(), value);
  }
}

tree_node * tree::lowest_common_ancestor(int a, int b) {
  return _lowest_common_ancestor(NULL, root, a, b);
}

tree_node * tree::_lowest_common_ancestor(tree_node * parent, tree_node * root, int a, int b) {
  if(root==NULL) {
    return root;
  } else if((root-&gt;get_data()==a &amp;&amp; (root-&gt;get_left()-&gt;get_data()==b || root-&gt;get_right()-&gt;get_data()==b))
             || (root-&gt;get_data()==b &amp;&amp; (root-&gt;get_left()-&gt;get_data()==a || root-&gt;get_right()-&gt;get_data()==a))) {
    return parent;
  } else if((_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL)
        || (_find_node(root-&gt;get_left(), b)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), a)!=NULL)) {
    return root; 
  } else if(_find_node(root-&gt;get_left(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_left(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_left(), a, b);
  } else if(_find_node(root-&gt;get_right(), a)!=NULL &amp;&amp; _find_node(root-&gt;get_right(), b)!=NULL) {
    return _lowest_common_ancestor(root, root-&gt;get_right(), a, b);
  } else {
    return NULL;
  }
}

tree_node * tree::min_node() {
  return _min_node(root);
}

tree_node * tree::_min_node(tree_node * root) {
  if(root==NULL || root-&gt;get_left()==NULL) {
    return root;
  } else {
    return _min_node(root-&gt;get_left());
  }
}

int main() {
  tree t1;

  t1.recursive_insert(5);
  t1.recursive_insert(3);
  t1.insert(10);
  t1.insert(7);
  t1.recursive_insert(50);
  t1.recursive_insert(6);

  cout&lt;&lt;&quot;Inorder Traversal&quot;&lt;&lt;endl;
  t1.print_inorder();

  tree_node * min_node=t1.min_node();
  if(min_node!=NULL) {
    cout&lt;&lt;&quot;Minimum node value: &quot;&lt;&lt;min_node-&gt;get_data()&lt;&lt;endl;
  } else {
    cout&lt;&lt;&quot;Tree is empty&quot;&lt;&lt;endl;
  }

  return 0;
}
</code> </pre>
<p>Inorder Traversal<br />
3 5 6 7 10 50<br />
Minimum node value: 3</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: shailraj</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-16667</link>
		<dc:creator><![CDATA[shailraj]]></dc:creator>
		<pubDate>Sun, 24 Mar 2013 21:36:09 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-16667</guid>
		<description><![CDATA[What will happen if tree is empty ?]]></description>
		<content:encoded><![CDATA[<p>What will happen if tree is empty ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rohit</title>
		<link>http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/#comment-16367</link>
		<dc:creator><![CDATA[rohit]]></dc:creator>
		<pubDate>Fri, 15 Mar 2013 05:08:18 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1333#comment-16367</guid>
		<description><![CDATA[but now current also points where root point if the bst is empty then then root is null implies current is also null so null-&#062;left again leads to crash .how taking current ensures that tree dont crash..plss explain..]]></description>
		<content:encoded><![CDATA[<p>but now current also points where root point if the bst is empty then then root is null implies current is also null so null-&gt;left again leads to crash .how taking current ensures that tree dont crash..plss explain..</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:04:18 -->

<!-- Compression = gzip -->