<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Count all possible paths from top left to bottom right of a mXn matrix</title>
	<atom:link href="http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: MANAS KUMAR</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-40093</link>
		<dc:creator><![CDATA[MANAS KUMAR]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 17:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-40093</guid>
		<description><![CDATA[You can also use one dimensional array(Code in JAVA)

public static int numberSteps(int[][] a,int r,int c){

		int r1 = a.length;

		int c1 = a[0].length;

		int[] f=new int[100];

		if(r&#062;r1)

			return 0;

		if(c&#062;c1)

			return 0;

		if(f[r1*c1]!=0) return f[r1*c1];

		if((r==r1)&#038;&#038;(c==c1))

			return 1;

		return f[r1*c1]=numberSteps(a,r+1,c)+numberSteps(a,r,c+1);

		

		//return ((numberSteps(a,r+1,c))+(numberSteps(a,r,c+1)));

	}]]></description>
		<content:encoded><![CDATA[<p>You can also use one dimensional array(Code in JAVA)</p>
<p>public static int numberSteps(int[][] a,int r,int c){</p>
<p>		int r1 = a.length;</p>
<p>		int c1 = a[0].length;</p>
<p>		int[] f=new int[100];</p>
<p>		if(r&gt;r1)</p>
<p>			return 0;</p>
<p>		if(c&gt;c1)</p>
<p>			return 0;</p>
<p>		if(f[r1*c1]!=0) return f[r1*c1];</p>
<p>		if((r==r1)&amp;&amp;(c==c1))</p>
<p>			return 1;</p>
<p>		return f[r1*c1]=numberSteps(a,r+1,c)+numberSteps(a,r,c+1);</p>
<p>		//return ((numberSteps(a,r+1,c))+(numberSteps(a,r,c+1)));</p>
<p>	}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Programmer</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-36070</link>
		<dc:creator><![CDATA[Programmer]]></dc:creator>
		<pubDate>Thu, 15 May 2014 09:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-36070</guid>
		<description><![CDATA[you can either move only to right or down]]></description>
		<content:encoded><![CDATA[<p>you can either move only to right or down</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vinod Prabhu</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34690</link>
		<dc:creator><![CDATA[Vinod Prabhu]]></dc:creator>
		<pubDate>Tue, 15 Apr 2014 06:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34690</guid>
		<description><![CDATA[assuming that I have a 2 rows and 3 columns matrix.

then the number of paths according to this program is 3. but if ai draw paths it is 4.

[0,0]-&#062;[0,1]-&#062;[0,2] -&#062;[1,2]

[0,0]-&#062;[0,1]-&#062;[1,1] -&#062;[1,2]

[0,0]-&#062;[1,0]-&#062;[1,1] -&#062;[1,2]

[0,0]-&#062;[1,0]-&#062;[1,1] -&#062;[0,1]-&#062;[0,2]-&#062;[1,2]]]></description>
		<content:encoded><![CDATA[<p>assuming that I have a 2 rows and 3 columns matrix.</p>
<p>then the number of paths according to this program is 3. but if ai draw paths it is 4.</p>
<p>[0,0]-&gt;[0,1]-&gt;[0,2] -&gt;[1,2]</p>
<p>[0,0]-&gt;[0,1]-&gt;[1,1] -&gt;[1,2]</p>
<p>[0,0]-&gt;[1,0]-&gt;[1,1] -&gt;[1,2]</p>
<p>[0,0]-&gt;[1,0]-&gt;[1,1] -&gt;[0,1]-&gt;[0,2]-&gt;[1,2]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vinod</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34686</link>
		<dc:creator><![CDATA[Vinod]]></dc:creator>
		<pubDate>Tue, 15 Apr 2014 02:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34686</guid>
		<description><![CDATA[assuming that I have a 2 rows and 3 columns matrix.

then the number of paths according to this program is 3. but if ai draw paths it is 4. 

[0,0]-&#062;[0,1]-&#062;[0,2] -&#062;[1,2]

[0,0]-&#062;[0,1]-&#062;[1,1] -&#062;[1,2]

[0,0]-&#062;[1,0]-&#062;[1,1] -&#062;[1,2]

[0,0]-&#062;[1,0]-&#062;[1,1] -&#062;[0,1]-&#062;[0,2]-&#062;[1,2]]]></description>
		<content:encoded><![CDATA[<p>assuming that I have a 2 rows and 3 columns matrix.</p>
<p>then the number of paths according to this program is 3. but if ai draw paths it is 4. </p>
<p>[0,0]-&gt;[0,1]-&gt;[0,2] -&gt;[1,2]</p>
<p>[0,0]-&gt;[0,1]-&gt;[1,1] -&gt;[1,2]</p>
<p>[0,0]-&gt;[1,0]-&gt;[1,1] -&gt;[1,2]</p>
<p>[0,0]-&gt;[1,0]-&gt;[1,1] -&gt;[0,1]-&gt;[0,2]-&gt;[1,2]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sujeet singh</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34667</link>
		<dc:creator><![CDATA[sujeet singh]]></dc:creator>
		<pubDate>Mon, 14 Apr 2014 12:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34667</guid>
		<description><![CDATA[#define ROW 5
#define COLUMN 5

using namespace std;

int get_count_paths(int* matrix,int m,int n)
{
    return *(matrix+((m-1)*COLUMN)+n-1);
}

void set_count_paths(int* matrix)
{

          for(int i =0 ;i &#060; ROW;i++)
             for(int j=0;j&#060; COLUMN;j++)
             {
                   if(i==0 &#124;&#124;j ==0)
                         *(matrix+(i*COLUMN)+j)=1;
                   else
                          *(matrix+(i*COLUMN)+j)= *(matrix+((i-1)*COLUMN)+j)+ *(matrix+(i*COLUMN)+(j-1));
}
}]]></description>
		<content:encoded><![CDATA[<p>#define ROW 5<br />
#define COLUMN 5</p>
<p>using namespace std;</p>
<p>int get_count_paths(int* matrix,int m,int n)<br />
{<br />
    return *(matrix+((m-1)*COLUMN)+n-1);<br />
}</p>
<p>void set_count_paths(int* matrix)<br />
{</p>
<p>          for(int i =0 ;i &lt; ROW;i++)<br />
             for(int j=0;j&lt; COLUMN;j++)<br />
             {<br />
                   if(i==0 ||j ==0)<br />
                         *(matrix+(i*COLUMN)+j)=1;<br />
                   else<br />
                          *(matrix+(i*COLUMN)+j)= *(matrix+((i-1)*COLUMN)+j)+ *(matrix+(i*COLUMN)+(j-1));<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: proton</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34456</link>
		<dc:creator><![CDATA[proton]]></dc:creator>
		<pubDate>Tue, 08 Apr 2014 05:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34456</guid>
		<description><![CDATA[// Count of paths to reach any cell in first column is 1
    for (int i = 0; i &#060; m; i++)
        count[i][0] = 1;
We&#039;re starting from top-left with one column at a time...How then to reach any cell in first column is 1 ???]]></description>
		<content:encoded><![CDATA[<p>// Count of paths to reach any cell in first column is 1<br />
    for (int i = 0; i &lt; m; i++)<br />
        count[i][0] = 1;<br />
We&#039;re starting from top-left with one column at a time&#8230;How then to reach any cell in first column is 1 ???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gnanodharan Madhavan</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34442</link>
		<dc:creator><![CDATA[Gnanodharan Madhavan]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 19:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34442</guid>
		<description><![CDATA[Simple recursion to print all the paths.


import java.awt.Point;

import java.util.List;

import java.util.ArrayList;

public class printpathofmxmatrix{

  private static int TARGET = 100;

  private void printPathABofMatrix(int arr[][],int m, int n, List list){

    if(m&#062;=arr.length &#124;&#124; n&#062;=arr[0].length)

     return;

    Point point = new Point(m,n);

    list.add(point);

    if(arr[m][n] == TARGET){

      for (Point p : list)

      System.out.println(&quot;point x: &quot; + p.x +&quot;, point y: &quot; + p.y);

      System.out.println(&quot;nnnn&quot;);

      list.remove(new Point(m,n));

      return;

    }

    printPathABofMatrix(arr,m+1,n,list);

    printPathABofMatrix(arr,m,n+1,list);

    list.remove(new Point(m,n));

  }

  private void printPathABofMatrix(int arr[][]){

    printPathABofMatrix(arr, 0, 0,new ArrayList());

  }

  public static void main (String args[]){

    int m = 4, n =4;

    int arr[][] = new int[m][n];

    arr[m-1][n-1] = TARGET;

    printpathofmxmatrix matrix = new printpathofmxmatrix();

    matrix.printPathABofMatrix(arr);

  }

}]]></description>
		<content:encoded><![CDATA[<p>Simple recursion to print all the paths.</p>
<p>import java.awt.Point;</p>
<p>import java.util.List;</p>
<p>import java.util.ArrayList;</p>
<p>public class printpathofmxmatrix{</p>
<p>  private static int TARGET = 100;</p>
<p>  private void printPathABofMatrix(int arr[][],int m, int n, List list){</p>
<p>    if(m&gt;=arr.length || n&gt;=arr[0].length)</p>
<p>     return;</p>
<p>    Point point = new Point(m,n);</p>
<p>    list.add(point);</p>
<p>    if(arr[m][n] == TARGET){</p>
<p>      for (Point p : list)</p>
<p>      System.out.println(&#8220;point x: &#8221; + p.x +&#8221;, point y: &#8221; + p.y);</p>
<p>      System.out.println(&#8220;nnnn&#8221;);</p>
<p>      list.remove(new Point(m,n));</p>
<p>      return;</p>
<p>    }</p>
<p>    printPathABofMatrix(arr,m+1,n,list);</p>
<p>    printPathABofMatrix(arr,m,n+1,list);</p>
<p>    list.remove(new Point(m,n));</p>
<p>  }</p>
<p>  private void printPathABofMatrix(int arr[][]){</p>
<p>    printPathABofMatrix(arr, 0, 0,new ArrayList());</p>
<p>  }</p>
<p>  public static void main (String args[]){</p>
<p>    int m = 4, n =4;</p>
<p>    int arr[][] = new int[m][n];</p>
<p>    arr[m-1][n-1] = TARGET;</p>
<p>    printpathofmxmatrix matrix = new printpathofmxmatrix();</p>
<p>    matrix.printPathABofMatrix(arr);</p>
<p>  }</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Alok Kumar</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-34133</link>
		<dc:creator><![CDATA[Alok Kumar]]></dc:creator>
		<pubDate>Mon, 31 Mar 2014 19:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-34133</guid>
		<description><![CDATA[The time complexity of O(m*n) is OK, but we can improve the space complexity as O(min(m,n)).

#include
#include
int ans(int m,int n)
{
    if(m&#060;=0&#124;&#124;nn) return ans(n,m);
    int dp1[m];
    int loop1,loop2;
    for(loop1=0;loop1&#060;m;loop1++) dp1[loop1]=1;
    for(loop1=0;loop1=0;loop2--)
            {
                    dp1[loop2]=dp1[loop2]+dp1[loop2+1];
            }
    }
    return dp1[0];
}
int main()
{
    printf(&quot;%dn&quot;,ans(5,8));
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>The time complexity of O(m*n) is OK, but we can improve the space complexity as O(min(m,n)).</p>
<p>#include<br />
#include<br />
int ans(int m,int n)<br />
{<br />
    if(m&lt;=0||nn) return ans(n,m);<br />
    int dp1[m];<br />
    int loop1,loop2;<br />
    for(loop1=0;loop1&lt;m;loop1++) dp1[loop1]=1;<br />
    for(loop1=0;loop1=0;loop2&#8211;)<br />
            {<br />
                    dp1[loop2]=dp1[loop2]+dp1[loop2+1];<br />
            }<br />
    }<br />
    return dp1[0];<br />
}<br />
int main()<br />
{<br />
    printf(&#8220;%dn&#8221;,ans(5,8));<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ritesh Mahato</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-33018</link>
		<dc:creator><![CDATA[Ritesh Mahato]]></dc:creator>
		<pubDate>Wed, 26 Feb 2014 17:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-33018</guid>
		<description><![CDATA[@GeeksForGeeks : In second example, the comment should be &#039;row&#039; and not &#039;column&#039;. Pl correct.
// Count of paths to reach any cell in first &#039;column&#039; is 1
    for (int j = 0; j &#060; n; j++)
        count[0][j] = 1;]]></description>
		<content:encoded><![CDATA[<p>@GeeksForGeeks : In second example, the comment should be &#8216;row&#8217; and not &#8216;column&#8217;. Pl correct.<br />
// Count of paths to reach any cell in first &#8216;column&#8217; is 1<br />
    for (int j = 0; j &lt; n; j++)<br />
        count[0][j] = 1;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sekhar</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-32632</link>
		<dc:creator><![CDATA[Sekhar]]></dc:creator>
		<pubDate>Mon, 17 Feb 2014 04:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-32632</guid>
		<description><![CDATA[static int printAllPaths(int[][] a, int rowCount, int colCount, int currX, int currY) {

        if (currX == rowCount - 1) {
            return 1;
        }

        if (currY == colCount - 1) {
            return 1;
        }

        return printAllPaths(a, rowCount, colCount, currX + 1, currY)
                + printAllPaths(a, rowCount, colCount, currX, currY + 1);
    }]]></description>
		<content:encoded><![CDATA[<p>static int printAllPaths(int[][] a, int rowCount, int colCount, int currX, int currY) {</p>
<p>        if (currX == rowCount &#8211; 1) {<br />
            return 1;<br />
        }</p>
<p>        if (currY == colCount &#8211; 1) {<br />
            return 1;<br />
        }</p>
<p>        return printAllPaths(a, rowCount, colCount, currX + 1, currY)<br />
                + printAllPaths(a, rowCount, colCount, currX, currY + 1);<br />
    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Subrahmanyan Sankar</title>
		<link>http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/#comment-32252</link>
		<dc:creator><![CDATA[Subrahmanyan Sankar]]></dc:creator>
		<pubDate>Thu, 06 Feb 2014 10:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=125069#comment-32252</guid>
		<description><![CDATA[Thank you for sharing this]]></description>
		<content:encoded><![CDATA[<p>Thank you for sharing this</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:52:49 -->

<!-- Compression = gzip -->