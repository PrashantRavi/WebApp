<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Iterative Preorder Traversal</title>
	<atom:link href="http://www.geeksforgeeks.org/iterative-preorder-traversal/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-37676</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 13:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-37676</guid>
		<description><![CDATA[void iterativePreorder(btnode *t)
{
    if(t==NULL)
    return;
    
    stack  s;
    btnode *current=t;
    while(current!=NULL&#124;&#124;!s.empty())
    {
        if(current!=NULL)
        {
            cout&#060;data&#060;lchild;
        }
        else
        {    current=s.top();
            s.pop();
            current=current-&#062;rchild;
        }
    }
    
}]]></description>
		<content:encoded><![CDATA[<p>void iterativePreorder(btnode *t)<br />
{<br />
    if(t==NULL)<br />
    return;</p>
<p>    stack  s;<br />
    btnode *current=t;<br />
    while(current!=NULL||!s.empty())<br />
    {<br />
        if(current!=NULL)<br />
        {<br />
            cout&lt;data&lt;lchild;<br />
        }<br />
        else<br />
        {    current=s.top();<br />
            s.pop();<br />
            current=current-&gt;rchild;<br />
        }<br />
    }</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: carmen cojocaru</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-32053</link>
		<dc:creator><![CDATA[carmen cojocaru]]></dc:creator>
		<pubDate>Sat, 01 Feb 2014 09:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-32053</guid>
		<description><![CDATA[Can you post an implementation for the post-order also? I&#039;ve seen some versions over the Internet but they&#039;re pretty complicated. Yours is so clean.  Thank you.]]></description>
		<content:encoded><![CDATA[<p>Can you post an implementation for the post-order also? I&#8217;ve seen some versions over the Internet but they&#8217;re pretty complicated. Yours is so clean.  Thank you.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-29334</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Sun, 27 Oct 2013 02:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-29334</guid>
		<description><![CDATA[no need to push the right child into the stack

&lt;code&gt;

void preOrderIterative(struct node *root)

{

	struct stknode *st=NULL;

	while(!empty(st) &#124;&#124; root)

	{

		while(root)

		{

			printf(&quot;%d &quot;,root-&#062;data);

			push(&#038;st,root);

			root=root-&#062;left;

		}

		root=pop(&#038;st);

		root=root-&#062;right;

	}

}



&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>no need to push the right child into the stack</p>
<p><code></p>
<p>void preOrderIterative(struct node *root)</p>
<p>{</p>
<p>	struct stknode *st=NULL;</p>
<p>	while(!empty(st) || root)</p>
<p>	{</p>
<p>		while(root)</p>
<p>		{</p>
<p>			printf("%d ",root-&gt;data);</p>
<p>			push(&amp;st,root);</p>
<p>			root=root-&gt;left;</p>
<p>		}</p>
<p>		root=pop(&amp;st);</p>
<p>		root=root-&gt;right;</p>
<p>	}</p>
<p>}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Bgl</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-25130</link>
		<dc:creator><![CDATA[Amit Bgl]]></dc:creator>
		<pubDate>Sat, 17 Aug 2013 18:05:08 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-25130</guid>
		<description><![CDATA[wow code :D]]></description>
		<content:encoded><![CDATA[<p>wow code ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dex</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-22771</link>
		<dc:creator><![CDATA[dex]]></dc:creator>
		<pubDate>Sat, 27 Jul 2013 19:41:12 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-22771</guid>
		<description><![CDATA[debugged!,

 I constructed the tree itself wrong while checking p-&gt;data and n .]]></description>
		<content:encoded><![CDATA[<p>debugged!,</p>
<p> I constructed the tree itself wrong while checking p->data and n .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dex</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-22705</link>
		<dc:creator><![CDATA[dex]]></dc:creator>
		<pubDate>Fri, 26 Jul 2013 14:05:27 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-22705</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/*
iterative preorder of bst using explicit stack
*/

#include&#060;stdio.h&#062;
#include&#060;stdlib.h&#062;

struct tree
{
	int data;
	struct tree *left;
	struct tree *right;
};
typedef struct tree node;
void addnode(node *,int);


struct llist
{
	struct tree *tp;
	struct llist *next;
};
typedef struct llist stack;
stack *createStack(stack *);
int stackIsEmpty(stack *);
void push(stack **,node *);
node *pop(stack **top);


int main()
{
	int i,n,a;
	printf(&#034;enter the number of elements in the tree \n&#034;);
	scanf(&#034;%d&#034;,&#038;a);
	node *head=(node *)malloc(sizeof(node));
	node *treehead=head;
	head-&#062;left=NULL;
	head-&#062;right=NULL;
	printf(&#034;enter numbers \n&#034;);
	scanf(&#034;%d&#034;,&#038;head-&#062;data);
	for(i=0;i&#060;a-1;i++)
	{
		scanf(&#034;%d&#034;,&#038;n);
		addnode(head,n);
	}

	stack st;
	stack *top=createStack(&#038;st);
	push(&#038;top,treehead); // push the root node&#039;s address on to stack top
	printf(&#034;preorder is \n\n&#034;);
	
	
	while(stackIsEmpty(top))
	{
		treehead=pop(&#038;top);
		if(treehead!=NULL)
		{		
			printf(&#034;%d\t&#034;,treehead-&#062;data); // printing the data after popping
			printf(&#034;-&#062;&#034;);
			push(&#038;top,treehead-&#062;right);  // push left one last so that it gets operated first
			push(&#038;top,treehead-&#062;left); // I&#039;m getting correct answer if i exchange this statement wid above one but it doesnt make sense w.r.t stack&#039;s LIFO property
	
		}

	}
	
	
	printf(&#034;preorder traversal is completed successfully\n&#034;);
	
	return 0;
}

void addnode(node *p,int n)
{
	if(p-&#062;data&#062;n)
	{
		if(p-&#062;right!=NULL)
		{
			addnode(p-&#062;right,n);
	
		}
		else
		{
			p-&#062;right=(node *)malloc(sizeof(node));
			p=p-&#062;right;
			p-&#062;data=n;
			p-&#062;left=NULL;
			p-&#062;right=NULL;
		}		
		
	}

	else
	{

		if(p-&#062;left!=NULL)
		{
			addnode(p-&#062;left,n);
	
		}
		else
		{
			p-&#062;left=(node *)malloc(sizeof(node));
			p=p-&#062;left;
			p-&#062;data=n;
			p-&#062;left=NULL;
			p-&#062;right=NULL;
		}		


	}

}

stack *createStack(stack *top)
{
	top=NULL;
	return top;
}

int stackIsEmpty(stack *top)
{
	if(top==NULL)
	return 0;

	else 
	return 1;

}

void push(stack **top,node *t) // tell me if my stack implementation is wrong somewhere
{
	stack *temp=(stack *)malloc(sizeof(stack));
	if(temp==NULL)
	{
		printf(&#034;memory error\n&#034;);
		return;
	}	
	temp-&#062;tp=t;
	temp-&#062;next=*top;
	*top=temp;

}

node *pop(stack **top)
{
	if(top==NULL)
	{
		printf(&#034;stack is empty\n&#034;);
		return (node *)0;
	}

	stack *temp=*top;
	*top=(*top)-&#062;next;
	node *t=temp-&#062;tp;
	free(temp);
	return t;

}



&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/*
iterative preorder of bst using explicit stack
*/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct tree
{
	int data;
	struct tree *left;
	struct tree *right;
};
typedef struct tree node;
void addnode(node *,int);


struct llist
{
	struct tree *tp;
	struct llist *next;
};
typedef struct llist stack;
stack *createStack(stack *);
int stackIsEmpty(stack *);
void push(stack **,node *);
node *pop(stack **top);


int main()
{
	int i,n,a;
	printf(&quot;enter the number of elements in the tree \n&quot;);
	scanf(&quot;%d&quot;,&amp;a);
	node *head=(node *)malloc(sizeof(node));
	node *treehead=head;
	head-&gt;left=NULL;
	head-&gt;right=NULL;
	printf(&quot;enter numbers \n&quot;);
	scanf(&quot;%d&quot;,&amp;head-&gt;data);
	for(i=0;i&lt;a-1;i++)
	{
		scanf(&quot;%d&quot;,&amp;n);
		addnode(head,n);
	}

	stack st;
	stack *top=createStack(&amp;st);
	push(&amp;top,treehead); // push the root node's address on to stack top
	printf(&quot;preorder is \n\n&quot;);
	
	
	while(stackIsEmpty(top))
	{
		treehead=pop(&amp;top);
		if(treehead!=NULL)
		{		
			printf(&quot;%d\t&quot;,treehead-&gt;data); // printing the data after popping
			printf(&quot;-&gt;&quot;);
			push(&amp;top,treehead-&gt;right);  // push left one last so that it gets operated first
			push(&amp;top,treehead-&gt;left); // I'm getting correct answer if i exchange this statement wid above one but it doesnt make sense w.r.t stack's LIFO property
	
		}

	}
	
	
	printf(&quot;preorder traversal is completed successfully\n&quot;);
	
	return 0;
}

void addnode(node *p,int n)
{
	if(p-&gt;data&gt;n)
	{
		if(p-&gt;right!=NULL)
		{
			addnode(p-&gt;right,n);
	
		}
		else
		{
			p-&gt;right=(node *)malloc(sizeof(node));
			p=p-&gt;right;
			p-&gt;data=n;
			p-&gt;left=NULL;
			p-&gt;right=NULL;
		}		
		
	}

	else
	{

		if(p-&gt;left!=NULL)
		{
			addnode(p-&gt;left,n);
	
		}
		else
		{
			p-&gt;left=(node *)malloc(sizeof(node));
			p=p-&gt;left;
			p-&gt;data=n;
			p-&gt;left=NULL;
			p-&gt;right=NULL;
		}		


	}

}

stack *createStack(stack *top)
{
	top=NULL;
	return top;
}

int stackIsEmpty(stack *top)
{
	if(top==NULL)
	return 0;

	else 
	return 1;

}

void push(stack **top,node *t) // tell me if my stack implementation is wrong somewhere
{
	stack *temp=(stack *)malloc(sizeof(stack));
	if(temp==NULL)
	{
		printf(&quot;memory error\n&quot;);
		return;
	}	
	temp-&gt;tp=t;
	temp-&gt;next=*top;
	*top=temp;

}

node *pop(stack **top)
{
	if(top==NULL)
	{
		printf(&quot;stack is empty\n&quot;);
		return (node *)0;
	}

	stack *temp=*top;
	*top=(*top)-&gt;next;
	node *t=temp-&gt;tp;
	free(temp);
	return t;

}



</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: dex</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-22704</link>
		<dc:creator><![CDATA[dex]]></dc:creator>
		<pubDate>Fri, 26 Jul 2013 14:03:05 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-22704</guid>
		<description><![CDATA[/*
iterative preorder of bst using explicit stack
*/

#include
#include

struct tree
{
	int data;
	struct tree *left;
	struct tree *right;
};
typedef struct tree node;
void addnode(node *,int);


struct llist
{
	struct tree *tp;
	struct llist *next;
};
typedef struct llist stack;
stack *createStack(stack *);
int stackIsEmpty(stack *);
void push(stack **,node *);
node *pop(stack **top);


int main()
{
	int i,n,a;
	printf(&quot;enter the number of elements in the tree \n&quot;);
	scanf(&quot;%d&quot;,&#038;a);
	node *head=(node *)malloc(sizeof(node));
	node *treehead=head;
	head-&#062;left=NULL;
	head-&#062;right=NULL;
	printf(&quot;enter numbers \n&quot;);
	scanf(&quot;%d&quot;,&#038;head-&#062;data);
	for(i=0;i&lt;a&gt;data); // printing the data after popping
			printf(&quot;-&#062;&quot;);
			push(&#038;top,treehead-&#062;right);  // push left one last so that it gets operated first
			push(&#038;top,treehead-&#062;left); // I&#039;m getting correct answer if i exchange this statement wid above one but it doesnt make sense w.r.t stack&#039;s LIFO property
	
		}

	}
	
	
	printf(&quot;preorder traversal is completed successfully\n&quot;);
	
	return 0;
}

void addnode(node *p,int n)
{
	if(p-&#062;data&#062;n)
	{
		if(p-&#062;right!=NULL)
		{
			addnode(p-&#062;right,n);
	
		}
		else
		{
			p-&#062;right=(node *)malloc(sizeof(node));
			p=p-&#062;right;
			p-&#062;data=n;
			p-&#062;left=NULL;
			p-&#062;right=NULL;
		}		
		
	}

	else
	{

		if(p-&#062;left!=NULL)
		{
			addnode(p-&#062;left,n);
	
		}
		else
		{
			p-&#062;left=(node *)malloc(sizeof(node));
			p=p-&#062;left;
			p-&#062;data=n;
			p-&#062;left=NULL;
			p-&#062;right=NULL;
		}		


	}

}

stack *createStack(stack *top)
{
	top=NULL;
	return top;
}

int stackIsEmpty(stack *top)
{
	if(top==NULL)
	return 0;

	else 
	return 1;

}

void push(stack **top,node *t) // tell me if my stack implementation is wrong somewhere
{
	stack *temp=(stack *)malloc(sizeof(stack));
	if(temp==NULL)
	{
		printf(&quot;memory error\n&quot;);
		return;
	}	
	temp-&#062;tp=t;
	temp-&#062;next=*top;
	*top=temp;

}

node *pop(stack **top)
{
	if(top==NULL)
	{
		printf(&quot;stack is empty\n&quot;);
		return (node *)0;
	}

	stack *temp=*top;
	*top=(*top)-&#062;next;
	node *t=temp-&#062;tp;
	free(temp);
	return t;

}]]></description>
		<content:encoded><![CDATA[<p>/*<br />
iterative preorder of bst using explicit stack<br />
*/</p>
<p>#include<br />
#include</p>
<p>struct tree<br />
{<br />
	int data;<br />
	struct tree *left;<br />
	struct tree *right;<br />
};<br />
typedef struct tree node;<br />
void addnode(node *,int);</p>
<p>struct llist<br />
{<br />
	struct tree *tp;<br />
	struct llist *next;<br />
};<br />
typedef struct llist stack;<br />
stack *createStack(stack *);<br />
int stackIsEmpty(stack *);<br />
void push(stack **,node *);<br />
node *pop(stack **top);</p>
<p>int main()<br />
{<br />
	int i,n,a;<br />
	printf(&#8220;enter the number of elements in the tree \n&#8221;);<br />
	scanf(&#8220;%d&#8221;,&amp;a);<br />
	node *head=(node *)malloc(sizeof(node));<br />
	node *treehead=head;<br />
	head-&gt;left=NULL;<br />
	head-&gt;right=NULL;<br />
	printf(&#8220;enter numbers \n&#8221;);<br />
	scanf(&#8220;%d&#8221;,&amp;head-&gt;data);<br />
	for(i=0;i<a>data); // printing the data after popping<br />
			printf(&#8220;-&gt;&#8221;);<br />
			push(&amp;top,treehead-&gt;right);  // push left one last so that it gets operated first<br />
			push(&amp;top,treehead-&gt;left); // I&#8217;m getting correct answer if i exchange this statement wid above one but it doesnt make sense w.r.t stack&#8217;s LIFO property</p>
<p>		}</p>
<p>	}</p>
<p>	printf(&#8220;preorder traversal is completed successfully\n&#8221;);</p>
<p>	return 0;<br />
}</p>
<p>void addnode(node *p,int n)<br />
{<br />
	if(p-&gt;data&gt;n)<br />
	{<br />
		if(p-&gt;right!=NULL)<br />
		{<br />
			addnode(p-&gt;right,n);</p>
<p>		}<br />
		else<br />
		{<br />
			p-&gt;right=(node *)malloc(sizeof(node));<br />
			p=p-&gt;right;<br />
			p-&gt;data=n;<br />
			p-&gt;left=NULL;<br />
			p-&gt;right=NULL;<br />
		}		</p>
<p>	}</p>
<p>	else<br />
	{</p>
<p>		if(p-&gt;left!=NULL)<br />
		{<br />
			addnode(p-&gt;left,n);</p>
<p>		}<br />
		else<br />
		{<br />
			p-&gt;left=(node *)malloc(sizeof(node));<br />
			p=p-&gt;left;<br />
			p-&gt;data=n;<br />
			p-&gt;left=NULL;<br />
			p-&gt;right=NULL;<br />
		}		</p>
<p>	}</p>
<p>}</p>
<p>stack *createStack(stack *top)<br />
{<br />
	top=NULL;<br />
	return top;<br />
}</p>
<p>int stackIsEmpty(stack *top)<br />
{<br />
	if(top==NULL)<br />
	return 0;</p>
<p>	else<br />
	return 1;</p>
<p>}</p>
<p>void push(stack **top,node *t) // tell me if my stack implementation is wrong somewhere<br />
{<br />
	stack *temp=(stack *)malloc(sizeof(stack));<br />
	if(temp==NULL)<br />
	{<br />
		printf(&#8220;memory error\n&#8221;);<br />
		return;<br />
	}<br />
	temp-&gt;tp=t;<br />
	temp-&gt;next=*top;<br />
	*top=temp;</p>
<p>}</p>
<p>node *pop(stack **top)<br />
{<br />
	if(top==NULL)<br />
	{<br />
		printf(&#8220;stack is empty\n&#8221;);<br />
		return (node *)0;<br />
	}</p>
<p>	stack *temp=*top;<br />
	*top=(*top)-&gt;next;<br />
	node *t=temp-&gt;tp;<br />
	free(temp);<br />
	return t;</p>
<p>}</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: zyzz</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-20711</link>
		<dc:creator><![CDATA[zyzz]]></dc:creator>
		<pubDate>Thu, 27 Jun 2013 03:56:24 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-20711</guid>
		<description><![CDATA[i think this one is easy 

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/void preorder(struct node *temp){
int top=0;
struct node *s[20];
s[0]=NULL;
printf(&#034;preorder : \n&#034;);
while(temp!=NULL){
    printf(&#034;%d \t&#034;,temp-&#062;data);

    if(temp-&#062;right!=NULL){

        s[++top]=temp-&#062;right;
    }



    if(temp-&#062;left!=NULL){

        temp=temp-&#062;left;
    } else{

      temp=s[top--];
    }


}

}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>i think this one is easy </p>
<pre> <code language="C">
/void preorder(struct node *temp){
int top=0;
struct node *s[20];
s[0]=NULL;
printf(&quot;preorder : \n&quot;);
while(temp!=NULL){
    printf(&quot;%d \t&quot;,temp-&gt;data);

    if(temp-&gt;right!=NULL){

        s[++top]=temp-&gt;right;
    }



    if(temp-&gt;left!=NULL){

        temp=temp-&gt;left;
    } else{

      temp=s[top--];
    }


}

}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-18473</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Wed, 22 May 2013 18:28:47 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-18473</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: SHASHI KUMAR</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-14626</link>
		<dc:creator><![CDATA[SHASHI KUMAR]]></dc:creator>
		<pubDate>Mon, 21 Jan 2013 16:55:20 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-14626</guid>
		<description><![CDATA[#include
#include
struct node
{
  int data;
  struct node *right;
  struct node *left;
}*root,*S[10];
int i=0;
void Push(struct node *p)
{
  S[i++]=p;
}
struct node *Pop()
{
  return S[--i];
}
void preorder()
{
  //int j=1;
  struct node *ptr=root;
  struct node *popped;
  while(ptr!=NULL)
  {
    struct node *psh=ptr;
    while(psh!=NULL)
    {
      Push(psh);
      printf(&quot;%d &quot;,psh-&#062;data);
      psh=psh-&#062;left;
    }
   while(i&#062;0)
    {
      popped=Pop();
      //if(j==k)
	//rslt=popped-&#062;data;
     // printf(&quot;%d &quot;,popped-&#062;data);
      //j++;
      if(popped-&#062;right!=NULL)
	break;
    }
    ptr=popped-&#062;right;
  }
  printf(&quot;\n&quot;);
  
}
struct node *createnode(int k)
{
  struct node *nwnode=malloc(sizeof(struct node));
  nwnode-&#062;data=k;
  nwnode-&#062;left=NULL;
  nwnode-&#062;right=NULL;
  return nwnode;
}
int main(int args,char *argv[])
{
  root=createnode(11);
  root-&#062;left=createnode(4);
  root-&#062;right=createnode(15);
  root-&#062;left-&#062;left=createnode(3);
  root-&#062;left-&#062;right=createnode(8);
  root-&#062;left-&#062;right-&#062;left=createnode(7);
  root-&#062;right-&#062;left=createnode(13);
  root-&#062;right-&#062;right=createnode(17);
  root-&#062;right-&#062;right-&#062;right=createnode(19)    ;                              
 printf(&quot;the preorder traversal of the given graph is &quot;); preorder();
 
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
struct node<br />
{<br />
  int data;<br />
  struct node *right;<br />
  struct node *left;<br />
}*root,*S[10];<br />
int i=0;<br />
void Push(struct node *p)<br />
{<br />
  S[i++]=p;<br />
}<br />
struct node *Pop()<br />
{<br />
  return S[&#8211;i];<br />
}<br />
void preorder()<br />
{<br />
  //int j=1;<br />
  struct node *ptr=root;<br />
  struct node *popped;<br />
  while(ptr!=NULL)<br />
  {<br />
    struct node *psh=ptr;<br />
    while(psh!=NULL)<br />
    {<br />
      Push(psh);<br />
      printf(&#8220;%d &#8220;,psh-&gt;data);<br />
      psh=psh-&gt;left;<br />
    }<br />
   while(i&gt;0)<br />
    {<br />
      popped=Pop();<br />
      //if(j==k)<br />
	//rslt=popped-&gt;data;<br />
     // printf(&#8220;%d &#8220;,popped-&gt;data);<br />
      //j++;<br />
      if(popped-&gt;right!=NULL)<br />
	break;<br />
    }<br />
    ptr=popped-&gt;right;<br />
  }<br />
  printf(&#8220;\n&#8221;);</p>
<p>}<br />
struct node *createnode(int k)<br />
{<br />
  struct node *nwnode=malloc(sizeof(struct node));<br />
  nwnode-&gt;data=k;<br />
  nwnode-&gt;left=NULL;<br />
  nwnode-&gt;right=NULL;<br />
  return nwnode;<br />
}<br />
int main(int args,char *argv[])<br />
{<br />
  root=createnode(11);<br />
  root-&gt;left=createnode(4);<br />
  root-&gt;right=createnode(15);<br />
  root-&gt;left-&gt;left=createnode(3);<br />
  root-&gt;left-&gt;right=createnode(8);<br />
  root-&gt;left-&gt;right-&gt;left=createnode(7);<br />
  root-&gt;right-&gt;left=createnode(13);<br />
  root-&gt;right-&gt;right=createnode(17);<br />
  root-&gt;right-&gt;right-&gt;right=createnode(19)    ;<br />
 printf(&#8220;the preorder traversal of the given graph is &#8220;); preorder();</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Veer Verma</title>
		<link>http://www.geeksforgeeks.org/iterative-preorder-traversal/#comment-12631</link>
		<dc:creator><![CDATA[Veer Verma]]></dc:creator>
		<pubDate>Sat, 17 Nov 2012 11:09:51 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26086#comment-12631</guid>
		<description><![CDATA[Is modified version of Morris Traversal possible for PreOrder??]]></description>
		<content:encoded><![CDATA[<p>Is modified version of Morris Traversal possible for PreOrder??</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.045 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:16:56 -->

<!-- Compression = gzip -->