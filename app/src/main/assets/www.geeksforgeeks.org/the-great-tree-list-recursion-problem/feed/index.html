<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: The Great Tree-List Recursion Problem.</title>
	<atom:link href="http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-38127</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 17:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-38127</guid>
		<description><![CDATA[https://ideone.com/NQgZoS]]></description>
		<content:encoded><![CDATA[<p><a href="https://ideone.com/NQgZoS" rel="nofollow">https://ideone.com/NQgZoS</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-37663</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 09:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-37663</guid>
		<description><![CDATA[made DLL out of the tree..
it can be easily converted into circular one by findin tail and making it to point to the head..
void treeToList(bstnode *t,bstnode * &#038;head)
{
    static bstnode *predecessor=NULL;
    if(t!=NULL)
    {
        treeToList(t-&#062;lchild,head);
    
        t-&#062;lchild=predecessor;
        if(predecessor)
        predecessor-&#062;rchild=t;
        else
        head=t;
        
        predecessor=t;
        treeToList(t-&#062;rchild,head);
    }
}]]></description>
		<content:encoded><![CDATA[<p>made DLL out of the tree..<br />
it can be easily converted into circular one by findin tail and making it to point to the head..<br />
void treeToList(bstnode *t,bstnode * &amp;head)<br />
{<br />
    static bstnode *predecessor=NULL;<br />
    if(t!=NULL)<br />
    {<br />
        treeToList(t-&gt;lchild,head);</p>
<p>        t-&gt;lchild=predecessor;<br />
        if(predecessor)<br />
        predecessor-&gt;rchild=t;<br />
        else<br />
        head=t;</p>
<p>        predecessor=t;<br />
        treeToList(t-&gt;rchild,head);<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Karshit Jaiswal</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-37596</link>
		<dc:creator><![CDATA[Karshit Jaiswal]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 11:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-37596</guid>
		<description><![CDATA[@geeksforgeeks:disqus nothing as such is explained in the link only the code.
Please make a nice tutorial on this with proper Algorithm as it is a very important problem.]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus nothing as such is explained in the link only the code.<br />
Please make a nice tutorial on this with proper Algorithm as it is a very important problem.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Emmanuel Livingstone</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-36906</link>
		<dc:creator><![CDATA[Emmanuel Livingstone]]></dc:creator>
		<pubDate>Tue, 27 May 2014 08:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-36906</guid>
		<description><![CDATA[Can&#039;t we use the approach in http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/. They use inorder traversal with a prev pointer that they use to connect the prev node with the current node. Additionally we can store the head and last element and connect them after the traversal. head would the node which is visited when the prev is null and last element will be the node in prev when the traversal is complete.]]></description>
		<content:encoded><![CDATA[<p>Can&#8217;t we use the approach in <a href="http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/" rel="nofollow">http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/</a>. They use inorder traversal with a prev pointer that they use to connect the prev node with the current node. Additionally we can store the head and last element and connect them after the traversal. head would the node which is visited when the prev is null and last element will be the node in prev when the traversal is complete.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-36165</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 17 May 2014 11:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-36165</guid>
		<description><![CDATA[Your solution using O(n) auxiliary space. It can be done with O(1) auxiliary space.]]></description>
		<content:encoded><![CDATA[<p>Your solution using O(n) auxiliary space. It can be done with O(1) auxiliary space.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-35066</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Thu, 24 Apr 2014 12:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-35066</guid>
		<description><![CDATA[How could you write well-formatted code here ?]]></description>
		<content:encoded><![CDATA[<p>How could you write well-formatted code here ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bhopu</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-32457</link>
		<dc:creator><![CDATA[bhopu]]></dc:creator>
		<pubDate>Tue, 11 Feb 2014 17:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-32457</guid>
		<description><![CDATA[sorry... it&#039;s using in order traversal...]]></description>
		<content:encoded><![CDATA[<p>sorry&#8230; it&#8217;s using in order traversal&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bhopu</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-32456</link>
		<dc:creator><![CDATA[bhopu]]></dc:creator>
		<pubDate>Tue, 11 Feb 2014 17:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-32456</guid>
		<description><![CDATA[we can use preserve the current node and it&#039;s previous node during post order traversal  and make  DDL..!!

#include

struct tree {

       int data;

       struct  tree *next,*prv;

    };

    /* function to create tree */

    struct tree *insert(struct tree *root,int key){

        struct tree *ptr;

        if(root==NULL){

            ptr=(struct tree *)malloc(sizeof(struct tree));

            ptr-&#062;data=key;

            ptr-&#062;next=NULL;

            ptr-&#062;prv=NULL;

            return ptr;

        }else if(root-&#062;data&#062;key)

           root-&#062;prv=insert(root-&#062;prv,key);

           else if(root-&#062;datanext=insert(root-&#062;next,key);

           else

           printf(&quot;duplicate&quot;);

           

           return root;

    }

    

    /*traversing og tree*/

    traverse_tree(struct tree *root){

      if(root==NULL)

      return 0;

      

      traverse_tree(root-&#062;prv);

      printf(&quot; %d-&#062;&quot;,root-&#062;data);

     

      traverse_tree(root-&#062;next);

      

      return 0;

    }

    

    /* traversing in DDL*/

    traverse_DDL(struct tree *head,struct tree *tail){

        struct tree *q=head;

        printf(&quot; %d-&#062;&quot;,head-&#062;data);

        q=head-&#062;next;

      

        while(q!=head){

            printf(&quot; %d-&#062;&quot;,q-&#062;data);

            q=q-&#062;next;

        }

    }

    /* function to make doubly linked list **DDL_head stro the head of list.

       *root is root of tree ,*par store parent,**ppreviose stores the previouse

       node that used to connect with current root node

    */

    struct tree *make_DDL(struct tree *root,struct tree **DDL_head,struct tree *par,struct tree **previous){

        static int i=0;

        

        if(root==NULL){

            if(i==0)

            {

                *DDL_head=par;

                i=1;

            }

        return root;

        

        }

        

        make_DDL(root-&#062;prv,DDL_head,root,previous);

       

         if((*previous)!=NULL){

       

         (*previous)-&#062;next=root;

         root-&#062;prv=*previous;

         }

         *previous=root;    

        make_DDL(root-&#062;next,DDL_head,root,previous);

        

        return root;

    }

    

    main(){

        struct tree *root=NULL,*DDL_head,*previous=NULL,*tail;

          

        root=insert(root,353);

        root=insert(root,5);

        root=insert(root,35);

        

         traverse_tree(root);

         printf(&quot; n&quot;);

         tail=make_DDL(root,&#038;DDL_head,NULL,&#038;previous);

         printf(&quot; nn&quot;);

         /*make circular */

         DDL_head-&#062;prv=tail;

         tail-&#062;next=DDL_head;

        // printf(&quot;nn %d   %d&quot;,DDL_head-&#062;prv-&#062;data,tail-&#062;next-&#062;data);

         traverse_DDL(DDL_head,tail);

         

      

    }]]></description>
		<content:encoded><![CDATA[<p>we can use preserve the current node and it&#8217;s previous node during post order traversal  and make  DDL..!!</p>
<p>#include</p>
<p>struct tree {</p>
<p>       int data;</p>
<p>       struct  tree *next,*prv;</p>
<p>    };</p>
<p>    /* function to create tree */</p>
<p>    struct tree *insert(struct tree *root,int key){</p>
<p>        struct tree *ptr;</p>
<p>        if(root==NULL){</p>
<p>            ptr=(struct tree *)malloc(sizeof(struct tree));</p>
<p>            ptr-&gt;data=key;</p>
<p>            ptr-&gt;next=NULL;</p>
<p>            ptr-&gt;prv=NULL;</p>
<p>            return ptr;</p>
<p>        }else if(root-&gt;data&gt;key)</p>
<p>           root-&gt;prv=insert(root-&gt;prv,key);</p>
<p>           else if(root-&gt;datanext=insert(root-&gt;next,key);</p>
<p>           else</p>
<p>           printf(&#8220;duplicate&#8221;);</p>
<p>           return root;</p>
<p>    }</p>
<p>    /*traversing og tree*/</p>
<p>    traverse_tree(struct tree *root){</p>
<p>      if(root==NULL)</p>
<p>      return 0;</p>
<p>      traverse_tree(root-&gt;prv);</p>
<p>      printf(&#8221; %d-&gt;&#8221;,root-&gt;data);</p>
<p>      traverse_tree(root-&gt;next);</p>
<p>      return 0;</p>
<p>    }</p>
<p>    /* traversing in DDL*/</p>
<p>    traverse_DDL(struct tree *head,struct tree *tail){</p>
<p>        struct tree *q=head;</p>
<p>        printf(&#8221; %d-&gt;&#8221;,head-&gt;data);</p>
<p>        q=head-&gt;next;</p>
<p>        while(q!=head){</p>
<p>            printf(&#8221; %d-&gt;&#8221;,q-&gt;data);</p>
<p>            q=q-&gt;next;</p>
<p>        }</p>
<p>    }</p>
<p>    /* function to make doubly linked list **DDL_head stro the head of list.</p>
<p>       *root is root of tree ,*par store parent,**ppreviose stores the previouse</p>
<p>       node that used to connect with current root node</p>
<p>    */</p>
<p>    struct tree *make_DDL(struct tree *root,struct tree **DDL_head,struct tree *par,struct tree **previous){</p>
<p>        static int i=0;</p>
<p>        if(root==NULL){</p>
<p>            if(i==0)</p>
<p>            {</p>
<p>                *DDL_head=par;</p>
<p>                i=1;</p>
<p>            }</p>
<p>        return root;</p>
<p>        }</p>
<p>        make_DDL(root-&gt;prv,DDL_head,root,previous);</p>
<p>         if((*previous)!=NULL){</p>
<p>         (*previous)-&gt;next=root;</p>
<p>         root-&gt;prv=*previous;</p>
<p>         }</p>
<p>         *previous=root;    </p>
<p>        make_DDL(root-&gt;next,DDL_head,root,previous);</p>
<p>        return root;</p>
<p>    }</p>
<p>    main(){</p>
<p>        struct tree *root=NULL,*DDL_head,*previous=NULL,*tail;</p>
<p>        root=insert(root,353);</p>
<p>        root=insert(root,5);</p>
<p>        root=insert(root,35);</p>
<p>         traverse_tree(root);</p>
<p>         printf(&#8221; n&#8221;);</p>
<p>         tail=make_DDL(root,&amp;DDL_head,NULL,&amp;previous);</p>
<p>         printf(&#8221; nn&#8221;);</p>
<p>         /*make circular */</p>
<p>         DDL_head-&gt;prv=tail;</p>
<p>         tail-&gt;next=DDL_head;</p>
<p>        // printf(&#8220;nn %d   %d&#8221;,DDL_head-&gt;prv-&gt;data,tail-&gt;next-&gt;data);</p>
<p>         traverse_DDL(DDL_head,tail);</p>
<p>    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: manish kumar</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-32336</link>
		<dc:creator><![CDATA[manish kumar]]></dc:creator>
		<pubDate>Sat, 08 Feb 2014 09:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-32336</guid>
		<description><![CDATA[we can easily do same via making separate doubly link list  via in-order traversal and delete current tree.]]></description>
		<content:encoded><![CDATA[<p>we can easily do same via making separate doubly link list  via in-order traversal and delete current tree.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Yash Girdhar</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-28948</link>
		<dc:creator><![CDATA[Yash Girdhar]]></dc:creator>
		<pubDate>Wed, 16 Oct 2013 10:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-28948</guid>
		<description><![CDATA[Following is the code : The convert function takes a tree and 2 null pointers and sets the first pointer to the head and the second to the tail.

&lt;code&gt;

node* convert(node *start, node** tail, node** head){
    printf(&quot;for %dn&quot;,start-&#062;data);
    if(!start-&#062;left &#038;&#038; !start-&#062;right){
        printf(&quot;leafn&quot;);
        if((*tail)){
            printf(&quot;tail now= %dn&quot;,(*tail)-&#062;data);
            (*tail)-&#062;right = start;
            start-&#062;left = (*tail);
            (*tail)=start; 
            printf(&quot;new tail=%dn&quot;,(*tail)-&#062;data );
        }
        else{
            printf(&quot;no tailn&quot;);
            (*tail) = start;
            (*tail)-&#062;right = (*tail)-&#062;left = NULL;
            (*head) = start;
            (*head)-&#062;right = (*head)-&#062;left = NULL;
            printf(&quot;new tail=%dn&quot;,(*tail)-&#062;data );
        }
        return (*tail);
    }

    if(start-&#062;left){
        convert(start-&#062;left,tail,head);
        if(start-&#062;left==(*tail)){
            (*tail)-&#062;right = start;
            (*tail) = start;
        }
        else if(start-&#062;left-&#062;right == (*tail)){
            (*tail)-&#062;right = start;
            start-&#062;left = (*tail);
            (*tail) = start;
        }
    }
    if(start-&#062;right){
        convert(start-&#062;right,tail,head);
        // if(start-&#062;right==(*tail))
            // (*tail)-&#062;left = start;
    }

    return (*tail);
}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>Following is the code : The convert function takes a tree and 2 null pointers and sets the first pointer to the head and the second to the tail.</p>
<p><code></p>
<p>node* convert(node *start, node** tail, node** head){<br />
    printf("for %dn",start-&gt;data);<br />
    if(!start-&gt;left &amp;&amp; !start-&gt;right){<br />
        printf("leafn");<br />
        if((*tail)){<br />
            printf("tail now= %dn",(*tail)-&gt;data);<br />
            (*tail)-&gt;right = start;<br />
            start-&gt;left = (*tail);<br />
            (*tail)=start;<br />
            printf("new tail=%dn",(*tail)-&gt;data );<br />
        }<br />
        else{<br />
            printf("no tailn");<br />
            (*tail) = start;<br />
            (*tail)-&gt;right = (*tail)-&gt;left = NULL;<br />
            (*head) = start;<br />
            (*head)-&gt;right = (*head)-&gt;left = NULL;<br />
            printf("new tail=%dn",(*tail)-&gt;data );<br />
        }<br />
        return (*tail);<br />
    }</p>
<p>    if(start-&gt;left){<br />
        convert(start-&gt;left,tail,head);<br />
        if(start-&gt;left==(*tail)){<br />
            (*tail)-&gt;right = start;<br />
            (*tail) = start;<br />
        }<br />
        else if(start-&gt;left-&gt;right == (*tail)){<br />
            (*tail)-&gt;right = start;<br />
            start-&gt;left = (*tail);<br />
            (*tail) = start;<br />
        }<br />
    }<br />
    if(start-&gt;right){<br />
        convert(start-&gt;right,tail,head);<br />
        // if(start-&gt;right==(*tail))<br />
            // (*tail)-&gt;left = start;<br />
    }</p>
<p>    return (*tail);<br />
}<br />
</code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/#comment-28113</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Wed, 25 Sep 2013 18:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1148#comment-28113</guid>
		<description><![CDATA[struct node { int data; struct node * small; struct node * large; };
// converts ordered tree to dll.
void TreetoList(struct node *root, struct node **sml)
{
  
  if(root)
   {
      TreetoList(((root)-&#062;small),sml);
       
        if(*sml)
           {
                (*sml)-&#062;large= root; 
                 (root)-&#062;small = *sml;
                  *sml= root;
          }
        
       else
             {
                 (root)-&#062;small= *sml;
                  *sml = root;
            }

      TreetoList(((root)-&#062;large), sml);
   }
                  
}  
// converts dll into circular dll.
struct node *tree_to_circdll(struct node **root)
{
     struct node *temp=NULL, *t;

       TreetoList(*root,&#038;temp);
        while(*root)
           {
                    t=*root;
               (*root)=(*root)-&#062;small;
           }
     temp-&#062;large=t;
      t-&#062;small = temp;
      return t;
}]]></description>
		<content:encoded><![CDATA[<p>struct node { int data; struct node * small; struct node * large; };<br />
// converts ordered tree to dll.<br />
void TreetoList(struct node *root, struct node **sml)<br />
{</p>
<p>  if(root)<br />
   {<br />
      TreetoList(((root)-&gt;small),sml);</p>
<p>        if(*sml)<br />
           {<br />
                (*sml)-&gt;large= root;<br />
                 (root)-&gt;small = *sml;<br />
                  *sml= root;<br />
          }</p>
<p>       else<br />
             {<br />
                 (root)-&gt;small= *sml;<br />
                  *sml = root;<br />
            }</p>
<p>      TreetoList(((root)-&gt;large), sml);<br />
   }</p>
<p>}<br />
// converts dll into circular dll.<br />
struct node *tree_to_circdll(struct node **root)<br />
{<br />
     struct node *temp=NULL, *t;</p>
<p>       TreetoList(*root,&amp;temp);<br />
        while(*root)<br />
           {<br />
                    t=*root;<br />
               (*root)=(*root)-&gt;small;<br />
           }<br />
     temp-&gt;large=t;<br />
      t-&gt;small = temp;<br />
      return t;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.053 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:01:01 -->

<!-- Compression = gzip -->