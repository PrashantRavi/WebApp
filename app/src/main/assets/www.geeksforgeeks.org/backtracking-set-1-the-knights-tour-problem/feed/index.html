<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Backtracking &#124; Set 1 (The Knight&#8217;s tour problem)</title>
	<atom:link href="http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: theCuriosityEnthusiast</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-40080</link>
		<dc:creator><![CDATA[theCuriosityEnthusiast]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 15:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-40080</guid>
		<description><![CDATA[Because you&#039;re points aren&#039;t in a circular fashion.. They are abrupt, so you&#039;re checking the incorrect points before the correct ones... In such algorithms which have high time complexities these things can make a big difference.. The first sequence will also solve it cause we are going through all possible options and the solution does exist...]]></description>
		<content:encoded><![CDATA[<p>Because you&#8217;re points aren&#8217;t in a circular fashion.. They are abrupt, so you&#8217;re checking the incorrect points before the correct ones&#8230; In such algorithms which have high time complexities these things can make a big difference.. The first sequence will also solve it cause we are going through all possible options and the solution does exist&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: theCuriosityEnthusiast</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-40077</link>
		<dc:creator><![CDATA[theCuriosityEnthusiast]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 15:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-40077</guid>
		<description><![CDATA[I agree with Guest, the 1st configuration is clearly circular and hence faster, the 2nd is quite abrupt and so should take more time. By circular I mean if you plot the 1st vector, the 2nd vector will be in clockwise or anticlockwise direction and so will be the 3rd, 4th, 5th so on..]]></description>
		<content:encoded><![CDATA[<p>I agree with Guest, the 1st configuration is clearly circular and hence faster, the 2nd is quite abrupt and so should take more time. By circular I mean if you plot the 1st vector, the 2nd vector will be in clockwise or anticlockwise direction and so will be the 3rd, 4th, 5th so on..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: theCuriosityEnthusiast</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-40071</link>
		<dc:creator><![CDATA[theCuriosityEnthusiast]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 15:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-40071</guid>
		<description><![CDATA[You are using recursion here as well only thing is if we find a path which doesn&#039;t lead to solution, we immediately return back (backtracking) to the nearest node from which other unexplored paths are available. In recursion we only stop at the base-cases, hence lots of useless computations are done..]]></description>
		<content:encoded><![CDATA[<p>You are using recursion here as well only thing is if we find a path which doesn&#8217;t lead to solution, we immediately return back (backtracking) to the nearest node from which other unexplored paths are available. In recursion we only stop at the base-cases, hence lots of useless computations are done..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Stéphane</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-39271</link>
		<dc:creator><![CDATA[Stéphane]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 16:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-39271</guid>
		<description><![CDATA[Has anyone tried to start from others positions than [0][0] ?]]></description>
		<content:encoded><![CDATA[<p>Has anyone tried to start from others positions than [0][0] ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: arjomanD</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-35836</link>
		<dc:creator><![CDATA[arjomanD]]></dc:creator>
		<pubDate>Fri, 09 May 2014 08:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-35836</guid>
		<description><![CDATA[Hello Every1 . I had a question . i have my code BUT it works very very Slow for N=8 (in fact i havn&#039;t still got the answer !

Would you Plz help me make my code and algorithm better ?

http://paste.ubuntu.com/7420193/



Thanks !]]></description>
		<content:encoded><![CDATA[<p>Hello Every1 . I had a question . i have my code BUT it works very very Slow for N=8 (in fact i havn&#8217;t still got the answer !</p>
<p>Would you Plz help me make my code and algorithm better ?</p>
<p><a href="http://paste.ubuntu.com/7420193/" rel="nofollow">http://paste.ubuntu.com/7420193/</a></p>
<p>Thanks !</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-31406</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 09 Jan 2014 18:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-31406</guid>
		<description><![CDATA[There is a reason why geekforgeeks folks chose
xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 }
yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 }

Only for this configuration of steps by knight, the recursion runs faster because it backtracks quite quickly in later stages.

For any other configuration like
xMove[8] = { 2,  2,  1,  1,  -2, -2, -1, -1 }
yMove[8] = { 1, -1,  2, -2,  1, -1,  2, -2 }

it&#039;s much much slower. 


But the 2nd configuration is correct too. It&#039;s just that it takes more time]]></description>
		<content:encoded><![CDATA[<p>There is a reason why geekforgeeks folks chose<br />
xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 }<br />
yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 }</p>
<p>Only for this configuration of steps by knight, the recursion runs faster because it backtracks quite quickly in later stages.</p>
<p>For any other configuration like<br />
xMove[8] = { 2,  2,  1,  1,  -2, -2, -1, -1 }<br />
yMove[8] = { 1, -1,  2, -2,  1, -1,  2, -2 }</p>
<p>it&#8217;s much much slower. </p>
<p>But the 2nd configuration is correct too. It&#8217;s just that it takes more time</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: KC</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-30130</link>
		<dc:creator><![CDATA[KC]]></dc:creator>
		<pubDate>Mon, 25 Nov 2013 20:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-30130</guid>
		<description><![CDATA[Knight moves 2 squares in the direction of one of the axes of the board, and then 1 square in an orthogonal direction. This definition can then be generalized to obtain an (a, b) knight. If the numbers a+b and a-b are coprime, tour is also possible in non 8x8 board using this similar algorithm.]]></description>
		<content:encoded><![CDATA[<p>Knight moves 2 squares in the direction of one of the axes of the board, and then 1 square in an orthogonal direction. This definition can then be generalized to obtain an (a, b) knight. If the numbers a+b and a-b are coprime, tour is also possible in non 8&#215;8 board using this similar algorithm.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Probe</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-28970</link>
		<dc:creator><![CDATA[Probe]]></dc:creator>
		<pubDate>Wed, 16 Oct 2013 19:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-28970</guid>
		<description><![CDATA[Here is also my implementation of the above algorithm for java:

[code]public class HorseTraversing{
    
    public static void printBoard(int[][] board){
        for (int i=0; i&#038;lt;board.length; i++){
            for (int y=0; y&#038;lt;board.length; y++){
                if (board[i][y] &#038;gt; 9){
                    System.out.print(board[i][y] + &#038;quot;  &#038;quot;);
                }else {
                    System.out.print(&#038;quot; &#038;quot; + board[i][y] + &#038;quot;  &#038;quot;);
                }
            }
            System.out.println();
        }
    }
    
    public static boolean isSafeMove(int moveX, int moveY, int[][] board){
        int maxPosition = (board.length - 1);
        
        if (moveX &#038;lt;= maxPosition &#038;amp;&#038;amp; moveY &#038;lt;= maxPosition &#038;amp;&#038;amp; moveX &#038;gt;= 0
                &#038;amp;&#038;amp; moveY &#038;gt;= 0 &#038;amp;&#038;amp; board[moveX][moveY] == 0){
            return true;
        }else
            return false;
    }
    
    public static void traverse(int[][] board, int startX, int startY){
     
        int xMove[] = {  2, 1, -1, -2, -2, -1,  1,  2 };
        int yMove[] = {  1, 2,  2,  1, -1, -2, -2, -1 };
     
        // Since the Knight is initially at the first block
        board[startX][startY]  = 1;
     
        if(traverseUtil(startX, startY, 2, board, xMove, yMove) == false)
        {
            System.out.print(&#038;quot;There is no solution!&#038;quot;);
        }
        else
            printBoard(board);
    }
    
    public static boolean traverseUtil(int startX, int startY, int moveNumber, 
            int[][] board, int[] xMoves, int[] yMoves){
        
        int nextX; 
        int nextY;
        
           if (moveNumber == (board.length * board.length) + 1){
               return true;
           }
               
           /* Try all next moves from the current coordinate x, y */
           for (int i = 0; i &#038;lt; 8; i++){
               
               nextX = startX + xMoves[i];
               nextY = startY + yMoves[i];
               
               if (isSafeMove(nextX, nextY, board))
               {
                 board[nextX][nextY] = moveNumber;
                 if (traverseUtil(nextX, nextY, moveNumber + 1,
                         board, xMoves, yMoves) == true)
                     return true;
                 else
                     board[nextX][nextY] = 0;// backtracking
               }
           }
         
           return false;
    }

    
    public static void main(String[] args) {
        
        int[][] board = new int[4][4];
        
        System.out.println(&#038;quot;Board before traversing:&#038;quot;);
        printBoard(board);
        System.out.println(&#038;quot;Board after traversing:&#038;quot;);
        traverse(board, 0, 0);

    }

}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Here is also my implementation of the above algorithm for java:</p>
<pre class="brush: plain; title: ; notranslate">public class HorseTraversing{
    
    public static void printBoard(int[][] board){
        for (int i=0; i&amp;lt;board.length; i++){
            for (int y=0; y&amp;lt;board.length; y++){
                if (board[i][y] &amp;gt; 9){
                    System.out.print(board[i][y] + &amp;quot;  &amp;quot;);
                }else {
                    System.out.print(&amp;quot; &amp;quot; + board[i][y] + &amp;quot;  &amp;quot;);
                }
            }
            System.out.println();
        }
    }
    
    public static boolean isSafeMove(int moveX, int moveY, int[][] board){
        int maxPosition = (board.length - 1);
        
        if (moveX &amp;lt;= maxPosition &amp;amp;&amp;amp; moveY &amp;lt;= maxPosition &amp;amp;&amp;amp; moveX &amp;gt;= 0
                &amp;amp;&amp;amp; moveY &amp;gt;= 0 &amp;amp;&amp;amp; board[moveX][moveY] == 0){
            return true;
        }else
            return false;
    }
    
    public static void traverse(int[][] board, int startX, int startY){
     
        int xMove[] = {  2, 1, -1, -2, -2, -1,  1,  2 };
        int yMove[] = {  1, 2,  2,  1, -1, -2, -2, -1 };
     
        // Since the Knight is initially at the first block
        board[startX][startY]  = 1;
     
        if(traverseUtil(startX, startY, 2, board, xMove, yMove) == false)
        {
            System.out.print(&amp;quot;There is no solution!&amp;quot;);
        }
        else
            printBoard(board);
    }
    
    public static boolean traverseUtil(int startX, int startY, int moveNumber, 
            int[][] board, int[] xMoves, int[] yMoves){
        
        int nextX; 
        int nextY;
        
           if (moveNumber == (board.length * board.length) + 1){
               return true;
           }
               
           /* Try all next moves from the current coordinate x, y */
           for (int i = 0; i &amp;lt; 8; i++){
               
               nextX = startX + xMoves[i];
               nextY = startY + yMoves[i];
               
               if (isSafeMove(nextX, nextY, board))
               {
                 board[nextX][nextY] = moveNumber;
                 if (traverseUtil(nextX, nextY, moveNumber + 1,
                         board, xMoves, yMoves) == true)
                     return true;
                 else
                     board[nextX][nextY] = 0;// backtracking
               }
           }
         
           return false;
    }

    
    public static void main(String[] args) {
        
        int[][] board = new int[4][4];
        
        System.out.println(&amp;quot;Board before traversing:&amp;quot;);
        printBoard(board);
        System.out.println(&amp;quot;Board after traversing:&amp;quot;);
        traverse(board, 0, 0);

    }

}
</pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dev Khanna</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-27374</link>
		<dc:creator><![CDATA[Dev Khanna]]></dc:creator>
		<pubDate>Thu, 05 Sep 2013 15:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-27374</guid>
		<description><![CDATA[They are the contents of the possible moves from any given square. For instance, one possible move is to go left one and up two. The corresponding &quot;vector&quot; would be (1, 2)]]></description>
		<content:encoded><![CDATA[<p>They are the contents of the possible moves from any given square. For instance, one possible move is to go left one and up two. The corresponding &#8220;vector&#8221; would be (1, 2)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dark_night</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-26653</link>
		<dc:creator><![CDATA[dark_night]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 19:41:28 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-26653</guid>
		<description><![CDATA[I am still not getting the difference between backtracking and recursion.. especially for this problem

Here also we are using every possible move and in recursion too we do the same , so how does backtracking is more efficient than recursion.]]></description>
		<content:encoded><![CDATA[<p>I am still not getting the difference between backtracking and recursion.. especially for this problem</p>
<p>Here also we are using every possible move and in recursion too we do the same , so how does backtracking is more efficient than recursion.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Let's Make a New India</title>
		<link>http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/#comment-24432</link>
		<dc:creator><![CDATA[Let's Make a New India]]></dc:creator>
		<pubDate>Mon, 05 Aug 2013 03:52:17 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12916#comment-24432</guid>
		<description><![CDATA[Muhammad Barrima thanks s a lot 4 this kind of help 4 geek like me]]></description>
		<content:encoded><![CDATA[<p>Muhammad Barrima thanks s a lot 4 this kind of help 4 geek like me</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:11:55 -->

<!-- Compression = gzip -->