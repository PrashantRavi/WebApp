<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Given a binary tree, print all root-to-leaf paths</title>
	<atom:link href="http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Tapan Anand</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-38410</link>
		<dc:creator><![CDATA[Tapan Anand]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 11:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-38410</guid>
		<description><![CDATA[Shouldn&#039;t the complexity of this code be O(nlogn). Cosider the case of a complete binary tree.]]></description>
		<content:encoded><![CDATA[<p>Shouldn&#8217;t the complexity of this code be O(nlogn). Cosider the case of a complete binary tree.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gaurav Nara</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-38348</link>
		<dc:creator><![CDATA[Gaurav Nara]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 19:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-38348</guid>
		<description><![CDATA[@geeksforgeeks:disqus i don&#039;t why is your code so big?? you just need to use a string and that&#039;s it.. 
check this out .. http://ideone.com/V9xoJ3]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus i don&#8217;t why is your code so big?? you just need to use a string and that&#8217;s it..<br />
check this out .. <a href="http://ideone.com/V9xoJ3" rel="nofollow">http://ideone.com/V9xoJ3</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vpr</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-37633</link>
		<dc:creator><![CDATA[vpr]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 00:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-37633</guid>
		<description><![CDATA[Hi GeeksforGeeks, please comment on following Pseudo Code for non recursive version i came up with.

void Path(struct node *root)
{
    if(root==NULL) return;
    S=Create-stack();
    Push(S,root);
    while(!IsEmpty(S))
    {
        while(root!=NULL)
        { root=root-&#062;left;
          if(root) Push(S,root);
        }
        root=top(S);
        root=root-&#062;right;
        if(root==NULL) //a leaf is encountered
        { Print the stack in reverse order;
          Pop(S);
          root=top(S);
        }
        Push(S,root);
    }
}]]></description>
		<content:encoded><![CDATA[<p>Hi GeeksforGeeks, please comment on following Pseudo Code for non recursive version i came up with.</p>
<p>void Path(struct node *root)<br />
{<br />
    if(root==NULL) return;<br />
    S=Create-stack();<br />
    Push(S,root);<br />
    while(!IsEmpty(S))<br />
    {<br />
        while(root!=NULL)<br />
        { root=root-&gt;left;<br />
          if(root) Push(S,root);<br />
        }<br />
        root=top(S);<br />
        root=root-&gt;right;<br />
        if(root==NULL) //a leaf is encountered<br />
        { Print the stack in reverse order;<br />
          Pop(S);<br />
          root=top(S);<br />
        }<br />
        Push(S,root);<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: govind</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-37632</link>
		<dc:creator><![CDATA[govind]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 22:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-37632</guid>
		<description><![CDATA[Vivek, in the root_leaf function, you have not written
&quot;if(root==NULL) return;&quot;
how is just &quot;if(root){..}&quot; enough? I guess else return must be present?
please explain.]]></description>
		<content:encoded><![CDATA[<p>Vivek, in the root_leaf function, you have not written<br />
&#8220;if(root==NULL) return;&#8221;<br />
how is just &#8220;if(root){..}&#8221; enough? I guess else return must be present?<br />
please explain.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-36202</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sun, 18 May 2014 10:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-36202</guid>
		<description><![CDATA[Here is an iterative version. But it is not good as it needs to add one field in node structure(Please let me know is any issue is there in the code)

#include

typedef struct node_t
{
    int data;
    struct node_t *left;
    struct node_t *right;
    int visited;
}node_t;

typedef struct 
{
    node_t a[100];
    int top;
}stack_t;

void print_stack(stack_t *sp)
{
    int index = 0;
    while(indextop)
    {
        printf(&quot;%d -&#062; &quot;,sp-&#062;a[index].data);
        index++;
    }
    printf(&quot;%dn&quot;,sp-&#062;a[index].data);
}

void stack_push(stack_t *sp,node_t e)
{
    sp-&#062;a[++(sp-&#062;top)] = e;
}

node_t* stack_pop(stack_t *sp)
{
    if(sp-&#062;top==-1)
    {
        return NULL;
    }
    return &#038;(sp-&#062;a[sp-&#062;top--]);
}

stack_t sp;
void list_all_path(node_t *root)
{
    int finished = 0;
    while(1)
    {
        if(finished)
        {
            break;
        }
        finished = 1;
        if(root-&#062;left!=NULL&#038;&#038;!(root-&#062;left-&#062;visited&#038;0x02))
        {
            stack_push(&#038;sp,*(root-&#062;left));
            root = root-&#062;left;
            root-&#062;visited = root-&#062;visited&#124;0x02;
            finished=0;
        }
        if(root-&#062;right!=NULL&#038;&#038;!(root-&#062;right-&#062;visited&#038;0x01))
        {
            stack_push(&#038;sp,*(root-&#062;right));
            root = root-&#062;right;
            if(root==NULL)
            {
                print_stack(&#038;sp);
                return;
            }
            root-&#062;visited = root-&#062;visited&#124;0x01;
            finished = 0;
        }
        if(root-&#062;left==NULL&#038;&#038;root-&#062;right==NULL)
        {
            print_stack(&#038;sp);
            root = stack_pop(&#038;sp);
            finished = 0;
            while(root-&#062;right==NULL)
            {
                root = stack_pop(&#038;sp);
                if(root==NULL)
                {
                    return;
                }
            }
            if(!(root-&#062;right-&#062;visited&#038;0x01))
            {
                stack_push(&#038;sp,*root);
            }
        }        
    }
}

int main()
{
    node_t one;
    node_t two;
    node_t three;
    node_t four;
    node_t five;
    node_t *root = NULL;

    root = &#038;one;
    

    one.data = 1;
    one.left = NULL;
    one.right = &#038;two;
    one.visited = 0;

    two.data = 2;
    two.left = &#038;five;
    two.right = &#038;three;
    two.visited = 0;

    three.data = 3;
    three.left = NULL;
    three.right = &#038;four;
    three.visited = 0;

    four.data = 4;
    four.left = NULL;
    four.right = NULL;
    four.visited = 0;
    
    five.data = 5;
    five.left = NULL;
    five.right = NULL;
    five.visited = 0;

    sp.top = -1;
    stack_push(&#038;sp,*root);
    list_all_path(root);
}
]]></description>
		<content:encoded><![CDATA[<p>Here is an iterative version. But it is not good as it needs to add one field in node structure(Please let me know is any issue is there in the code)</p>
<p>#include</p>
<p>typedef struct node_t<br />
{<br />
    int data;<br />
    struct node_t *left;<br />
    struct node_t *right;<br />
    int visited;<br />
}node_t;</p>
<p>typedef struct<br />
{<br />
    node_t a[100];<br />
    int top;<br />
}stack_t;</p>
<p>void print_stack(stack_t *sp)<br />
{<br />
    int index = 0;<br />
    while(indextop)<br />
    {<br />
        printf(&#8220;%d -&gt; &#8220;,sp-&gt;a[index].data);<br />
        index++;<br />
    }<br />
    printf(&#8220;%dn&#8221;,sp-&gt;a[index].data);<br />
}</p>
<p>void stack_push(stack_t *sp,node_t e)<br />
{<br />
    sp-&gt;a[++(sp-&gt;top)] = e;<br />
}</p>
<p>node_t* stack_pop(stack_t *sp)<br />
{<br />
    if(sp-&gt;top==-1)<br />
    {<br />
        return NULL;<br />
    }<br />
    return &amp;(sp-&gt;a[sp-&gt;top&#8211;]);<br />
}</p>
<p>stack_t sp;<br />
void list_all_path(node_t *root)<br />
{<br />
    int finished = 0;<br />
    while(1)<br />
    {<br />
        if(finished)<br />
        {<br />
            break;<br />
        }<br />
        finished = 1;<br />
        if(root-&gt;left!=NULL&amp;&amp;!(root-&gt;left-&gt;visited&amp;0x02))<br />
        {<br />
            stack_push(&amp;sp,*(root-&gt;left));<br />
            root = root-&gt;left;<br />
            root-&gt;visited = root-&gt;visited|0x02;<br />
            finished=0;<br />
        }<br />
        if(root-&gt;right!=NULL&amp;&amp;!(root-&gt;right-&gt;visited&amp;0x01))<br />
        {<br />
            stack_push(&amp;sp,*(root-&gt;right));<br />
            root = root-&gt;right;<br />
            if(root==NULL)<br />
            {<br />
                print_stack(&amp;sp);<br />
                return;<br />
            }<br />
            root-&gt;visited = root-&gt;visited|0x01;<br />
            finished = 0;<br />
        }<br />
        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)<br />
        {<br />
            print_stack(&amp;sp);<br />
            root = stack_pop(&amp;sp);<br />
            finished = 0;<br />
            while(root-&gt;right==NULL)<br />
            {<br />
                root = stack_pop(&amp;sp);<br />
                if(root==NULL)<br />
                {<br />
                    return;<br />
                }<br />
            }<br />
            if(!(root-&gt;right-&gt;visited&amp;0x01))<br />
            {<br />
                stack_push(&amp;sp,*root);<br />
            }<br />
        }<br />
    }<br />
}</p>
<p>int main()<br />
{<br />
    node_t one;<br />
    node_t two;<br />
    node_t three;<br />
    node_t four;<br />
    node_t five;<br />
    node_t *root = NULL;</p>
<p>    root = &amp;one;</p>
<p>    one.data = 1;<br />
    one.left = NULL;<br />
    one.right = &amp;two;<br />
    one.visited = 0;</p>
<p>    two.data = 2;<br />
    two.left = &amp;five;<br />
    two.right = &amp;three;<br />
    two.visited = 0;</p>
<p>    three.data = 3;<br />
    three.left = NULL;<br />
    three.right = &amp;four;<br />
    three.visited = 0;</p>
<p>    four.data = 4;<br />
    four.left = NULL;<br />
    four.right = NULL;<br />
    four.visited = 0;</p>
<p>    five.data = 5;<br />
    five.left = NULL;<br />
    five.right = NULL;<br />
    five.visited = 0;</p>
<p>    sp.top = -1;<br />
    stack_push(&amp;sp,*root);<br />
    list_all_path(root);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Klaus</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-36150</link>
		<dc:creator><![CDATA[Klaus]]></dc:creator>
		<pubDate>Sat, 17 May 2014 04:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-36150</guid>
		<description><![CDATA[Nice Suggestion]]></description>
		<content:encoded><![CDATA[<p>Nice Suggestion</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mahda</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-35183</link>
		<dc:creator><![CDATA[Mahda]]></dc:creator>
		<pubDate>Sun, 27 Apr 2014 07:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-35183</guid>
		<description><![CDATA[Hi geeks, what must I do if I want to add the averages from each path?]]></description>
		<content:encoded><![CDATA[<p>Hi geeks, what must I do if I want to add the averages from each path?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jonathan</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-34384</link>
		<dc:creator><![CDATA[Jonathan]]></dc:creator>
		<pubDate>Sun, 06 Apr 2014 18:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-34384</guid>
		<description><![CDATA[Each node is traversed only once throughout the tree.


O(n*h) would occur only when nodes traversed multiple times.]]></description>
		<content:encoded><![CDATA[<p>Each node is traversed only once throughout the tree.</p>
<p>O(n*h) would occur only when nodes traversed multiple times.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-33424</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Wed, 12 Mar 2014 10:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-33424</guid>
		<description><![CDATA[use recursion and  vector for path here is my code 
http://ideone.com/idIpnx]]></description>
		<content:encoded><![CDATA[<p>use recursion and  vector for path here is my code<br />
<a href="http://ideone.com/idIpnx" rel="nofollow">http://ideone.com/idIpnx</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sabitaa Bhabhi</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-32837</link>
		<dc:creator><![CDATA[Sabitaa Bhabhi]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 10:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-32837</guid>
		<description><![CDATA[why we are not using dynamic array 

void printPaths(struct node* node) 
{
  int path[]={0};
  printPathsRecur(node, path, 0);
}]]></description>
		<content:encoded><![CDATA[<p>why we are not using dynamic array </p>
<p>void printPaths(struct node* node)<br />
{<br />
  int path[]={0};<br />
  printPathsRecur(node, path, 0);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Babajj</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/#comment-32766</link>
		<dc:creator><![CDATA[Babajj]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 19:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=6719#comment-32766</guid>
		<description><![CDATA[Just use a stack having a print function.

-Push current node is not null
-Print stack if its a leaf node
-Recurse left
-Recurse right
-Pop stack]]></description>
		<content:encoded><![CDATA[<p>Just use a stack having a print function.</p>
<p>-Push current node is not null<br />
-Print stack if its a leaf node<br />
-Recurse left<br />
-Recurse right<br />
-Pop stack</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:36 -->

<!-- Compression = gzip -->