<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Generate n-bit Gray Codes</title>
	<atom:link href="http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Madan Ram</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-35997</link>
		<dc:creator><![CDATA[Madan Ram]]></dc:creator>
		<pubDate>Tue, 13 May 2014 18:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-35997</guid>
		<description><![CDATA[        if n==0:
            return [0]
        if n==1:
            return [0,1]
        else:
            return grayCode(n-1)+[(2**(n-1)+x) for x in grayCode(n-1)[::-1] ]]]></description>
		<content:encoded><![CDATA[<p>        if n==0:<br />
            return [0]<br />
        if n==1:<br />
            return [0,1]<br />
        else:<br />
            return grayCode(n-1)+[(2**(n-1)+x) for x in grayCode(n-1)[::-1] ]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bikash</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-31486</link>
		<dc:creator><![CDATA[bikash]]></dc:creator>
		<pubDate>Sun, 12 Jan 2014 23:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-31486</guid>
		<description><![CDATA[The comments in the solution code should say &quot;prepend&quot; 0 and 1. Not &quot;append&quot;]]></description>
		<content:encoded><![CDATA[<p>The comments in the solution code should say &#8220;prepend&#8221; 0 and 1. Not &#8220;append&#8221;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hari Prasad</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-30332</link>
		<dc:creator><![CDATA[Hari Prasad]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 14:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-30332</guid>
		<description><![CDATA[The Algorithm to generate the Gray code by Gideon Ehrlich the fastest that i am aware of.




Note this is the pseudo code that resembles c i have not tested this any one who is willing to write the complete code is most welcome.


LoopLessGrayCodeGeneration(int n)
{
   int fp[100];
   int g[100];
   for(int i = 0; i &#060; n;i++)
   {
        g[i] = 0;
        fp[i] = i;
   }
  fp[n] = n;
  while(true)
   {
       //visit g (you can print the gray code here
       j = fp[0];
       fp[0] = 0;
       if(j ==n)break;
       fp[j] = fp[j+1];
       fp[j+1] = j+1;
       g[j] = 1 - g[j];
   }
}]]></description>
		<content:encoded><![CDATA[<p>The Algorithm to generate the Gray code by Gideon Ehrlich the fastest that i am aware of.</p>
<p>Note this is the pseudo code that resembles c i have not tested this any one who is willing to write the complete code is most welcome.</p>
<p>LoopLessGrayCodeGeneration(int n)<br />
{<br />
   int fp[100];<br />
   int g[100];<br />
   for(int i = 0; i &lt; n;i++)<br />
   {<br />
        g[i] = 0;<br />
        fp[i] = i;<br />
   }<br />
  fp[n] = n;<br />
  while(true)<br />
   {<br />
       //visit g (you can print the gray code here<br />
       j = fp[0];<br />
       fp[0] = 0;<br />
       if(j ==n)break;<br />
       fp[j] = fp[j+1];<br />
       fp[j+1] = j+1;<br />
       g[j] = 1 &#8211; g[j];<br />
   }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Akhilesh Pandey</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15786</link>
		<dc:creator><![CDATA[Akhilesh Pandey]]></dc:creator>
		<pubDate>Thu, 28 Feb 2013 14:57:14 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15786</guid>
		<description><![CDATA[Iterative code in C to generate n-bit Gray Codes


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;
#include&#060;string.h&#062;

void graycode(int n);

//Driver Program
int main()
{
int b=4;
graycode(b);
return 0;
}


void graycode(int n)
{
char gray[32];
int max=(1&#060;&#060;n) - 1;     //maximum number that can be formed with n bits
int g, i, j;
gray[n]=&#039;&#092;&#048;&#039;;
for(i=0; i&#060;=max; i++)
{
memset(gray, &#039;0&#039;, n);
g=(i&#062;&#062;1)^i;             //Equivalent gray code
j=0;
while(g&#062;0)              //Calculating the equivalent binary code of g and storing it in array gray
{
gray[n-j-1]=g%2+&#039;0&#039;;
g=g/2;
j++;
}
printf(&#034;%s\n&#034;, gray);
}
}

Output:
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Iterative code in C to generate n-bit Gray Codes</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

void graycode(int n);

//Driver Program
int main()
{
int b=4;
graycode(b);
return 0;
}


void graycode(int n)
{
char gray[32];
int max=(1&lt;&lt;n) - 1;     //maximum number that can be formed with n bits
int g, i, j;
gray[n]='&#092;&#048;';
for(i=0; i&lt;=max; i++)
{
memset(gray, '0', n);
g=(i&gt;&gt;1)^i;             //Equivalent gray code
j=0;
while(g&gt;0)              //Calculating the equivalent binary code of g and storing it in array gray
{
gray[n-j-1]=g%2+'0';
g=g/2;
j++;
}
printf(&quot;%s\n&quot;, gray);
}
}

Output:
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: naresh.singhmar</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15770</link>
		<dc:creator><![CDATA[naresh.singhmar]]></dc:creator>
		<pubDate>Thu, 28 Feb 2013 08:12:15 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15770</guid>
		<description><![CDATA[Code in C using recursion 

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#034;stdio.h&#034;
#include &#034;stdlib.h&#034;

#define MAX 100

void printD(char data[MAX], int co)
{

  int i = 0;
  printf(&#034;\n Data: &#034;);
  for (i=MAX-co; i &#060;= (MAX-1); i++)
  {
      printf (&#034; %d &#034;,data[i]);
  }
}
void GrayCodes (char data[MAX], int co, int size)
{
   if (co == 1)
   {
       data [MAX-co] = 0;
       printD(data, size);
       data [MAX-co] = 1;
       printD(data, size);
   }
   else
   {
       data[MAX-co] = 0;
       GrayCodes (data,co-1, size);
       data[MAX-co] = 1;
       GrayCodes (data,co-1, size);
   }
}
void GrayCodesN (int size)
{
   if ((size &#060;= 0) &#124;&#124; (size &#062;= MAX)) return;
   char data[MAX] = { 0};
   GrayCodes (data, size, size);

}
main ()
{
   int size = 1;
   printf (&#034;Enter size  &#034;);
   scanf (&#034;%d&#034;, &#038;size);
   GrayCodesN  (size);
}
:~ # ./a.out
Enter size  3

 Data:  0  0  0
 Data:  0  0  1
 Data:  0  1  0
 Data:  0  1  1
 Data:  1  0  0
 Data:  1  0  1
 Data:  1  1  0
 Data:  1  1  1 
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Code in C using recursion </p>
<pre> <code language="C">
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;

#define MAX 100

void printD(char data[MAX], int co)
{

  int i = 0;
  printf(&quot;\n Data: &quot;);
  for (i=MAX-co; i &lt;= (MAX-1); i++)
  {
      printf (&quot; %d &quot;,data[i]);
  }
}
void GrayCodes (char data[MAX], int co, int size)
{
   if (co == 1)
   {
       data [MAX-co] = 0;
       printD(data, size);
       data [MAX-co] = 1;
       printD(data, size);
   }
   else
   {
       data[MAX-co] = 0;
       GrayCodes (data,co-1, size);
       data[MAX-co] = 1;
       GrayCodes (data,co-1, size);
   }
}
void GrayCodesN (int size)
{
   if ((size &lt;= 0) || (size &gt;= MAX)) return;
   char data[MAX] = { 0};
   GrayCodes (data, size, size);

}
main ()
{
   int size = 1;
   printf (&quot;Enter size  &quot;);
   scanf (&quot;%d&quot;, &amp;size);
   GrayCodesN  (size);
}
:~ # ./a.out
Enter size  3

 Data:  0  0  0
 Data:  0  0  1
 Data:  0  1  0
 Data:  0  1  1
 Data:  1  0  0
 Data:  1  0  1
 Data:  1  1  0
 Data:  1  1  1 
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: kartik</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15767</link>
		<dc:creator><![CDATA[kartik]]></dc:creator>
		<pubDate>Thu, 28 Feb 2013 05:37:31 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15767</guid>
		<description><![CDATA[@Hitesh &#038; @Akhilesh Pandey:

Thanks for suggesting a new approach.  We will check it and add it to the original post.]]></description>
		<content:encoded><![CDATA[<p>@Hitesh &amp; @Akhilesh Pandey:</p>
<p>Thanks for suggesting a new approach.  We will check it and add it to the original post.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Akhilesh Pandey</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15705</link>
		<dc:creator><![CDATA[Akhilesh Pandey]]></dc:creator>
		<pubDate>Tue, 26 Feb 2013 14:08:48 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15705</guid>
		<description><![CDATA[Hi,

Bit magic to generate gray code.

For an unsigned integer n, the equivalent Gray code can be obtained by the operation (n&#062;&#062;1)^n.

So to print n bit Gray codes, we can loop a variable, say i, through 0 to 2^n - 1 and print the corresponding Gray code, which will be (i&#062;&#062;1)^i, just padding the result with required number of 0&#039;s is required to make the final result.


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>Bit magic to generate gray code.</p>
<p>For an unsigned integer n, the equivalent Gray code can be obtained by the operation (n&gt;&gt;1)^n.</p>
<p>So to print n bit Gray codes, we can loop a variable, say i, through 0 to 2^n &#8211; 1 and print the corresponding Gray code, which will be (i&gt;&gt;1)^i, just padding the result with required number of 0&#8217;s is required to make the final result.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hitesh</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15702</link>
		<dc:creator><![CDATA[Hitesh]]></dc:creator>
		<pubDate>Tue, 26 Feb 2013 13:41:26 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15702</guid>
		<description><![CDATA[Here is a simple implementation in java :

[sourcecode language=&quot;java&quot;]
public class GrayToBinaryConversion {
	public static final int N = 4;

	public static void main(String args[]) {
		for(int i=0; i&#060;Math.pow(2,N); i++) {
			System.out.println(lpad(Integer.toBinaryString(i ^ i&#062;&#062;1)));
		}
	}

	// Optional method for left padding by 0&#039;s
	public static String lpad(String input) {
		StringBuffer output = new StringBuffer(N);
		// Pad output string with 0&#039;s
		for(int i=0; i&#060;N-input.length(); i++) {
			output.append(&#039;0&#039;);
		}
		// Append input string
		return output.append(input).toString();
	}
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Here is a simple implementation in java :</p>
<p>public class GrayToBinaryConversion {<br />
	public static final int N = 4;</p>
<p>	public static void main(String args[]) {<br />
		for(int i=0; i&lt;Math.pow(2,N); i++) {<br />
			System.out.println(lpad(Integer.toBinaryString(i ^ i&gt;&gt;1)));<br />
		}<br />
	}</p>
<p>	// Optional method for left padding by 0&#8217;s<br />
	public static String lpad(String input) {<br />
		StringBuffer output = new StringBuffer(N);<br />
		// Pad output string with 0&#8217;s<br />
		for(int i=0; i&lt;N-input.length(); i++) {<br />
			output.append(&#8216;0&#8217;);<br />
		}<br />
		// Append input string<br />
		return output.append(input).toString();<br />
	}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Venki</title>
		<link>http://www.geeksforgeeks.org/given-a-number-n-generate-bit-patterns-from-0-to-2n-1-so-that-successive-patterns-differ-by-one-bit/#comment-15668</link>
		<dc:creator><![CDATA[Venki]]></dc:creator>
		<pubDate>Tue, 26 Feb 2013 00:45:51 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114953#comment-15668</guid>
		<description><![CDATA[Great contribution from the readers. I have the same logic on Gray code in my work book, thought of sharing it.

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;iostream&#062;
#include &#060;string&#062;
#include &#060;vector&#062;
#include &#060;algorithm&#062;
using namespace std;

vector&#060;string&#062; RecursiveGrayCode(int size) {
    static string ZERO(&#034;0&#034;);
    static string ONE(&#034;1&#034;);

    // Generate gray code of size one
    if( size == 1 ) {
        vector&#060;string&#062; v;

        v.push_back(ZERO);
        v.push_back(ONE);

        return v;
    } else {
        // Generate smaller instance
        vector&#060;string&#062; vo = RecursiveGrayCode(size-1);
        vector&#060;string&#062; vr = vo;
        int size = vo.size();

        // Reverse the smaller instance (mirror reflection)
        reverse(vr.begin(), vr.end());

        // Insert zero and one
        for(int i = 0; i &#060; size; i++)
            vo[i] = ZERO + vo[i];
        for(int i = 0; i &#060; size; i++)
            vr[i] = ONE + vr[i];

        // Combine both
        vo.insert(vo.end(), vr.begin(), vr.end());

        return vo;
    }
}

void TestCase_01(void) {
    int size  = 5;
    vector&#060;string&#062; v = RecursiveGrayCode(size);
    copy(v.begin(), v.end(), ostream_iterator&#060;string&#062;(cout, &#034; &#034;)), cout &#060;&#060; endl;
}

int main() {
    TestCase_01();

    return 0;
}
&lt;/code&gt; &lt;/pre&gt;

It is interesting to use bit magic to generate Gray code. Hope someone will comment, otherwise I will cover later.]]></description>
		<content:encoded><![CDATA[<p>Great contribution from the readers. I have the same logic on Gray code in my work book, thought of sharing it.</p>
<pre> <code language="C">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;string&gt; RecursiveGrayCode(int size) {
    static string ZERO(&quot;0&quot;);
    static string ONE(&quot;1&quot;);

    // Generate gray code of size one
    if( size == 1 ) {
        vector&lt;string&gt; v;

        v.push_back(ZERO);
        v.push_back(ONE);

        return v;
    } else {
        // Generate smaller instance
        vector&lt;string&gt; vo = RecursiveGrayCode(size-1);
        vector&lt;string&gt; vr = vo;
        int size = vo.size();

        // Reverse the smaller instance (mirror reflection)
        reverse(vr.begin(), vr.end());

        // Insert zero and one
        for(int i = 0; i &lt; size; i++)
            vo[i] = ZERO + vo[i];
        for(int i = 0; i &lt; size; i++)
            vr[i] = ONE + vr[i];

        // Combine both
        vo.insert(vo.end(), vr.begin(), vr.end());

        return vo;
    }
}

void TestCase_01(void) {
    int size  = 5;
    vector&lt;string&gt; v = RecursiveGrayCode(size);
    copy(v.begin(), v.end(), ostream_iterator&lt;string&gt;(cout, &quot; &quot;)), cout &lt;&lt; endl;
}

int main() {
    TestCase_01();

    return 0;
}
</code> </pre>
<p>It is interesting to use bit magic to generate Gray code. Hope someone will comment, otherwise I will cover later.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:21:54 -->

<!-- Compression = gzip -->