<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Little and Big Endian Mystery</title>
	<atom:link href="http://www.geeksforgeeks.org/little-and-big-endian-mystery/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: bonnyswan</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-34583</link>
		<dc:creator><![CDATA[bonnyswan]]></dc:creator>
		<pubDate>Fri, 11 Apr 2014 10:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-34583</guid>
		<description><![CDATA[Thanks for sharing. I was looking to find some clear explanation with examples and I found it here. That was useful!]]></description>
		<content:encoded><![CDATA[<p>Thanks for sharing. I was looking to find some clear explanation with examples and I found it here. That was useful!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: akshay</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-23086</link>
		<dc:creator><![CDATA[akshay]]></dc:creator>
		<pubDate>Fri, 02 Aug 2013 06:14:35 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-23086</guid>
		<description><![CDATA[Thank you. Nicely explained the concept of Endianness.]]></description>
		<content:encoded><![CDATA[<p>Thank you. Nicely explained the concept of Endianness.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ravi Kumar</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-25531</link>
		<dc:creator><![CDATA[Ravi Kumar]]></dc:creator>
		<pubDate>Thu, 09 May 2013 09:38:27 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-25531</guid>
		<description><![CDATA[thank u for the info guys................]]></description>
		<content:encoded><![CDATA[<p>thank u for the info guys&#8230;&#8230;&#8230;&#8230;&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: BackBencher</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-16599</link>
		<dc:creator><![CDATA[BackBencher]]></dc:creator>
		<pubDate>Sat, 23 Mar 2013 04:08:51 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-16599</guid>
		<description><![CDATA[@All:
if i take num = 256
it will print Big Endian, Please explain me why this, i am bit confuse to endiness of machine]]></description>
		<content:encoded><![CDATA[<p>@All:<br />
if i take num = 256<br />
it will print Big Endian, Please explain me why this, i am bit confuse to endiness of machine</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-16595</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Sat, 23 Mar 2013 02:23:27 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-16595</guid>
		<description><![CDATA[@abhishek08aug and @amitp49: Thanks for pointing this out. We have fixed the explanation.]]></description>
		<content:encoded><![CDATA[<p>@abhishek08aug and @amitp49: Thanks for pointing this out. We have fixed the explanation.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-16593</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Fri, 22 Mar 2013 22:16:09 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-16593</guid>
		<description><![CDATA[Are not the definitions here for both big and little endian exactly same?

In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored last.

Please fix it as below:

In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored &quot;first&quot;.



&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Are not the definitions here for both big and little endian exactly same?</p>
<p>In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored last.</p>
<p>Please fix it as below:</p>
<p>In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored &#8220;first&#8221;.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Patil</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-14972</link>
		<dc:creator><![CDATA[Patil]]></dc:creator>
		<pubDate>Sat, 02 Feb 2013 07:28:46 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-14972</guid>
		<description><![CDATA[@Algoseeker : 
   if i take num = 256
  it will print Big Endian, Please explain me why this, i am bit confuse to endiness of machine

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>@Algoseeker :<br />
   if i take num = 256<br />
  it will print Big Endian, Please explain me why this, i am bit confuse to endiness of machine</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: amitp49</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-7448</link>
		<dc:creator><![CDATA[amitp49]]></dc:creator>
		<pubDate>Fri, 10 Feb 2012 17:18:34 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-7448</guid>
		<description><![CDATA[I think there is typo error in definition...

&quot;Little and big endian are two ways of storing multibyte data-types ( int, float, etc). In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored last.&quot;

It should be..

&quot;Little and big endian are two ways of storing multibyte data-types ( int, float, etc). In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, last byte of binary representation of the multibyte data-type is stored last.&quot;

Correct me if i am wrong...]]></description>
		<content:encoded><![CDATA[<p>I think there is typo error in definition&#8230;</p>
<p>&#8220;Little and big endian are two ways of storing multibyte data-types ( int, float, etc). In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored last.&#8221;</p>
<p>It should be..</p>
<p>&#8220;Little and big endian are two ways of storing multibyte data-types ( int, float, etc). In little endian machines, last byte of binary representation of the multibyte data-type is stored first. On the other hand, in big endian machines, last byte of binary representation of the multibyte data-type is stored last.&#8221;</p>
<p>Correct me if i am wrong&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Felipe Pena</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-4852</link>
		<dc:creator><![CDATA[Felipe Pena]]></dc:creator>
		<pubDate>Mon, 08 Aug 2011 00:49:54 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-4852</guid>
		<description><![CDATA[A bit late, but see http://unixpapa.com/incnote/byteorder.html :)]]></description>
		<content:encoded><![CDATA[<p>A bit late, but see <a href="http://unixpapa.com/incnote/byteorder.html" rel="nofollow">http://unixpapa.com/incnote/byteorder.html</a> ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: KK123</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-4539</link>
		<dc:creator><![CDATA[KK123]]></dc:creator>
		<pubDate>Wed, 06 Jul 2011 10:40:33 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-4539</guid>
		<description><![CDATA[Thats not called as typo ha ha... anyway thats bearable as compared to quality and maintainance of ur site :)]]></description>
		<content:encoded><![CDATA[<p>Thats not called as typo ha ha&#8230; anyway thats bearable as compared to quality and maintainance of ur site ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Algoseekar</title>
		<link>http://www.geeksforgeeks.org/little-and-big-endian-mystery/#comment-3792</link>
		<dc:creator><![CDATA[Algoseekar]]></dc:creator>
		<pubDate>Thu, 14 Apr 2011 13:14:40 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=801#comment-3792</guid>
		<description><![CDATA[What Little-Endian and Big-Endian? How can I determine whether a machine&#039;s byte order is big-endian or little endian? How can we convert from one to a
First of all, Do you know what Little-Endian and Big-Endian mean?

Little Endian means that the lower order byte of the number is stored in memory at the lowest address, and the higher order byte is stored at the highest address. That is, the little end comes first.

For example, a 4 byte, 32-bit integer


Byte3 Byte2 Byte1 Byte0


will be arranged in memory as follows:


Base_Address+0 Byte0
Base_Address+1 Byte1
Base_Address+2 Byte2
Base_Address+3 Byte3


Intel processors use &quot;Little Endian&quot; byte order.


&quot;Big Endian&quot; means that the higher order byte of the number is stored in memory at the lowest address, and the lower order byte at the highest address. The big end comes first.


Base_Address+0 Byte3
Base_Address+1 Byte2
Base_Address+2 Byte1
Base_Address+3 Byte0


Motorola, Solaris processors use &quot;Big Endian&quot; byte order.

In &quot;Little Endian&quot; form, code which picks up a 1, 2, 4, or longer byte number proceed in the same way for all formats. They first pick up the lowest order byte at offset 0 and proceed from there. Also, because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision mathematic routines are easy to code. In &quot;Big Endian&quot; form, since the high-order byte comes first, the code can test whether the number is positive or negative by looking at the byte at offset zero. Its not required to know how long the number is, nor does the code have to skip over any bytes to find the byte containing the sign information. The numbers are also stored in the order in which they are printed out, so binary to decimal routines are particularly efficient.


Here is some code to determine what is the type of your machine

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int num = 1;
if(*(char *)&#038;amp;num == 1)
{
  printf(&#038;quot;nLittle-Endiann&#038;quot;);
}
else
{
  printf(&#038;quot;Big-Endiann&#038;quot;);
}
&lt;/code&gt; &lt;/pre&gt;


And here is some code to convert from one Endian to another.


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int myreversefunc(int num)
{
int byte0, byte1, byte2, byte3;

byte0 = (num &#038;amp; x000000FF) &#038;gt;&#038;gt; 0 ;
byte1 = (num &#038;amp; x0000FF00) &#038;gt;&#038;gt; 8 ;
byte2 = (num &#038;amp; x00FF0000) &#038;gt;&#038;gt; 16 ;
byte3 = (num &#038;amp; xFF000000) &#038;gt;&#038;gt; 24 ;

return((byte0 &#038;lt;&#038;lt; 24) &#124; (byte1 &#038;lt;&#038;lt; 16) &#124; (byte2 &#038;lt;&#038;lt; 8) &#124; (byte3 &#038;lt;&#038;lt; 0));
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>What Little-Endian and Big-Endian? How can I determine whether a machine&#8217;s byte order is big-endian or little endian? How can we convert from one to a<br />
First of all, Do you know what Little-Endian and Big-Endian mean?</p>
<p>Little Endian means that the lower order byte of the number is stored in memory at the lowest address, and the higher order byte is stored at the highest address. That is, the little end comes first.</p>
<p>For example, a 4 byte, 32-bit integer</p>
<p>Byte3 Byte2 Byte1 Byte0</p>
<p>will be arranged in memory as follows:</p>
<p>Base_Address+0 Byte0<br />
Base_Address+1 Byte1<br />
Base_Address+2 Byte2<br />
Base_Address+3 Byte3</p>
<p>Intel processors use &#8220;Little Endian&#8221; byte order.</p>
<p>&#8220;Big Endian&#8221; means that the higher order byte of the number is stored in memory at the lowest address, and the lower order byte at the highest address. The big end comes first.</p>
<p>Base_Address+0 Byte3<br />
Base_Address+1 Byte2<br />
Base_Address+2 Byte1<br />
Base_Address+3 Byte0</p>
<p>Motorola, Solaris processors use &#8220;Big Endian&#8221; byte order.</p>
<p>In &#8220;Little Endian&#8221; form, code which picks up a 1, 2, 4, or longer byte number proceed in the same way for all formats. They first pick up the lowest order byte at offset 0 and proceed from there. Also, because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision mathematic routines are easy to code. In &#8220;Big Endian&#8221; form, since the high-order byte comes first, the code can test whether the number is positive or negative by looking at the byte at offset zero. Its not required to know how long the number is, nor does the code have to skip over any bytes to find the byte containing the sign information. The numbers are also stored in the order in which they are printed out, so binary to decimal routines are particularly efficient.</p>
<p>Here is some code to determine what is the type of your machine</p>
<pre> <code language="C">
int num = 1;
if(*(char *)&amp;amp;num == 1)
{
  printf(&amp;quot;nLittle-Endiann&amp;quot;);
}
else
{
  printf(&amp;quot;Big-Endiann&amp;quot;);
}
</code> </pre>
<p>And here is some code to convert from one Endian to another.</p>
<pre> <code language="C">
int myreversefunc(int num)
{
int byte0, byte1, byte2, byte3;

byte0 = (num &amp;amp; x000000FF) &amp;gt;&amp;gt; 0 ;
byte1 = (num &amp;amp; x0000FF00) &amp;gt;&amp;gt; 8 ;
byte2 = (num &amp;amp; x00FF0000) &amp;gt;&amp;gt; 16 ;
byte3 = (num &amp;amp; xFF000000) &amp;gt;&amp;gt; 24 ;

return((byte0 &amp;lt;&amp;lt; 24) | (byte1 &amp;lt;&amp;lt; 16) | (byte2 &amp;lt;&amp;lt; 8) | (byte3 &amp;lt;&amp;lt; 0));
}
</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:16:33 -->

<!-- Compression = gzip -->