<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Search in a row wise and column wise sorted matrix</title>
	<atom:link href="http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-38253</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 03:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-38253</guid>
		<description><![CDATA[It will not work. you need to visit every element atleast once to convert 2d to 1d. which means time = o(n*m) and space (n*m)]]></description>
		<content:encoded><![CDATA[<p>It will not work. you need to visit every element atleast once to convert 2d to 1d. which means time = o(n*m) and space (n*m)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-37591</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 09:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-37591</guid>
		<description><![CDATA[If we convert this 2D array into 1D row major array then we can apply binary search on that 1D array as elements are sorted So, the time complexity would be O(log(m)+log(n)) but we require space...
Please correct me if I am wrong or also give your comments if above method works fine...]]></description>
		<content:encoded><![CDATA[<p>If we convert this 2D array into 1D row major array then we can apply binary search on that 1D array as elements are sorted So, the time complexity would be O(log(m)+log(n)) but we require space&#8230;<br />
Please correct me if I am wrong or also give your comments if above method works fine&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-37590</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 09:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-37590</guid>
		<description><![CDATA[If we convert this 2D array into 1D row major array then we can apply binary search on that 1D array as elements are sorted So, the time complexity would be O(log(m+n)) but we require space...
Please correct me if I am wrong or also give your comments if above method works fine...]]></description>
		<content:encoded><![CDATA[<p>If we convert this 2D array into 1D row major array then we can apply binary search on that 1D array as elements are sorted So, the time complexity would be O(log(m+n)) but we require space&#8230;<br />
Please correct me if I am wrong or also give your comments if above method works fine&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Geek</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-36888</link>
		<dc:creator><![CDATA[Geek]]></dc:creator>
		<pubDate>Mon, 26 May 2014 21:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-36888</guid>
		<description><![CDATA[One simplest way many of you aware is, 
If the matrix is n (columns) X m (rows) and n &#062; m. 
Then repeat loop linearly for m (rows) and apply binary search  on n (columns). 
So it would be O(m log n). 
But I heard in net that we can achieve with O (log m x n) or O(log m +n) but couldn&#039;t find the code for the same.]]></description>
		<content:encoded><![CDATA[<p>One simplest way many of you aware is,<br />
If the matrix is n (columns) X m (rows) and n &gt; m.<br />
Then repeat loop linearly for m (rows) and apply binary search  on n (columns).<br />
So it would be O(m log n).<br />
But I heard in net that we can achieve with O (log m x n) or O(log m +n) but couldn&#8217;t find the code for the same.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-36185</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sun, 18 May 2014 01:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-36185</guid>
		<description><![CDATA[Your algorithm is faster than the versions that recurse on 3 quadrants.  At the next level, you eliminate 3/16th with 2 comparisons rather than 3/16ths with 3 comparisons.  I expect this 2/3 computation effort to continue, and you should run in about 2/3rds the runtime of the guys that check all 3 quadrants.  However, it&#039;s still polynomial rather than linear in time.  The original poster&#039;s solution remains the best posted on this thread, other than picking the wrong corner to start from for cache efficiency.]]></description>
		<content:encoded><![CDATA[<p>Your algorithm is faster than the versions that recurse on 3 quadrants.  At the next level, you eliminate 3/16th with 2 comparisons rather than 3/16ths with 3 comparisons.  I expect this 2/3 computation effort to continue, and you should run in about 2/3rds the runtime of the guys that check all 3 quadrants.  However, it&#8217;s still polynomial rather than linear in time.  The original poster&#8217;s solution remains the best posted on this thread, other than picking the wrong corner to start from for cache efficiency.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-36184</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 17 May 2014 23:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-36184</guid>
		<description><![CDATA[Not only is the author of this article&#039;s post optimal in that it&#039;s O(N), but the fact that it takes only 2*N comparisons is also optimal.  Simply imagine the boundary between two halves of the matrix divided by a specific target value.  It might follow the diagonal from the lower left to the upper right, in which case at least N values must be checked.  However, it could also hug the left and top sides, or close to them, being closer to 2*N in length.  This entire boundary must be checked. Therefore, in the limit as N gets large, 2*N elements must be checked.  This answer is as optimal as any we will see, except for mine :-)


My solution is slightly better because for huge matricies, when the whole thing does not fit into cache, I move right when in the same row, rather than left.  In my code, the hardware prefetch circuitry will cause my version (scanning starting in the lower left, moving to the upper right) to run faster, because I will have a better cache hit rate.


I win!]]></description>
		<content:encoded><![CDATA[<p>Not only is the author of this article&#8217;s post optimal in that it&#8217;s O(N), but the fact that it takes only 2*N comparisons is also optimal.  Simply imagine the boundary between two halves of the matrix divided by a specific target value.  It might follow the diagonal from the lower left to the upper right, in which case at least N values must be checked.  However, it could also hug the left and top sides, or close to them, being closer to 2*N in length.  This entire boundary must be checked. Therefore, in the limit as N gets large, 2*N elements must be checked.  This answer is as optimal as any we will see, except for mine ðŸ™‚</p>
<p>My solution is slightly better because for huge matricies, when the whole thing does not fit into cache, I move right when in the same row, rather than left.  In my code, the hardware prefetch circuitry will cause my version (scanning starting in the lower left, moving to the upper right) to run faster, because I will have a better cache hit rate.</p>
<p>I win!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Bill Cox</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-36183</link>
		<dc:creator><![CDATA[Bill Cox]]></dc:creator>
		<pubDate>Sat, 17 May 2014 20:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-36183</guid>
		<description><![CDATA[All the guys posting O(log(m)) or O(log(m) + log(n)) solutions above are wrong!  The original poster has the optimal answer with the O(N) solution!  Consider this matrix:


1 2 3 4 4
2 3 4 4 6
3 4 4 6 7
4 4 6 7 8
4 6 7 8 9


Now do a search for 5.  Any single element of the diagonal could be 5 legally.  Unless you check them all, you can&#039;t prove it&#039;s not there!  Since the diagonal has N elements for an NxN matrix, an optimal algorithm must have at least O(N) comparisons.  Any claim of an O(log(N)) is mistaken.

Further, the next diagonal, containing 6&#039;s are also legal locations for a 5 to exist, so clearly 2*N-1 locations must be searched, meaning that the original algorithm posted is exactly optimal in terms of comparisons.  The only improvement I would make is starting at the lower left instead of the upper right, since I&#039;d have a better chance of a cache hit due to hardware prefetch algorithms while scanning right instead of left.

Also, the posters who asked about using the middle element and searching the remaining 3 quadrants have a clever algorithm, but it&#039;s slow.  You have to compute the number of comparisons for a few matricies to see that picking the middle is a poor choice.  The total comparisons looks like:

1 + 3(1 + 3*(1 + 3(... + 3*(1)))...)

For a 2x2:4
For 4x4: 1 + 3*4 = 13  -- we already know that the 2x2 takes 4
For 8x8: 1 +  3*13 = 40
For 16x16:121, 32x32:364, 64x64:1,093 ...

It&#039;s polynomial, not linear.  It&#039;s growing faster than N^1.65.  This is much slower than the original solution.  In comparison, just doing a binary search on each row takes N*log2(N) comparisons, so the 64x64 would require 64*6 = 384, quite a bit faster than the pick the middle algorithm.

An improvement to the pick the middle algorithm is to do a binary search on the diagonal from the upper left to lower right, and use the two adjacent values spanning the target to eliminate 1/2 of the matrix.  This algorithm takes 1/2*N*log2(N) comparisons, which is twice as fast as binary search on each row, though still far from optimal, and if the matrix doesn&#039;t fit into cache, it will thrash memory much worse than a binary search on each row.

Improvements can be made over the original algorithm to improve cache performance.  For example, storing the matrix diagonal by diagonal rather than row by row increases the odds of a cache hit a lot for random data.  However, by that point, it probably makes more sense to finish sorting the table so that each row contains values greater than the previous rows, and less than the following rows, so you can do the search in O(log(N)).  Also, if you know the typical queries will not be middle-ish values, then you can save some time on average with a binary search along the left and bottom edges to find a better starting point, which is faster than starting in the lower-left corner and then scanning up or right for a significant fraction of the edge, but your worst case will then be 2*N + log2(2*N) - 1 comparisons.]]></description>
		<content:encoded><![CDATA[<p>All the guys posting O(log(m)) or O(log(m) + log(n)) solutions above are wrong!  The original poster has the optimal answer with the O(N) solution!  Consider this matrix:</p>
<p>1 2 3 4 4<br />
2 3 4 4 6<br />
3 4 4 6 7<br />
4 4 6 7 8<br />
4 6 7 8 9</p>
<p>Now do a search for 5.  Any single element of the diagonal could be 5 legally.  Unless you check them all, you can&#8217;t prove it&#8217;s not there!  Since the diagonal has N elements for an NxN matrix, an optimal algorithm must have at least O(N) comparisons.  Any claim of an O(log(N)) is mistaken.</p>
<p>Further, the next diagonal, containing 6&#8217;s are also legal locations for a 5 to exist, so clearly 2*N-1 locations must be searched, meaning that the original algorithm posted is exactly optimal in terms of comparisons.  The only improvement I would make is starting at the lower left instead of the upper right, since I&#8217;d have a better chance of a cache hit due to hardware prefetch algorithms while scanning right instead of left.</p>
<p>Also, the posters who asked about using the middle element and searching the remaining 3 quadrants have a clever algorithm, but it&#8217;s slow.  You have to compute the number of comparisons for a few matricies to see that picking the middle is a poor choice.  The total comparisons looks like:</p>
<p>1 + 3(1 + 3*(1 + 3(&#8230; + 3*(1)))&#8230;)</p>
<p>For a 2&#215;2:4<br />
For 4&#215;4: 1 + 3*4 = 13  &#8212; we already know that the 2&#215;2 takes 4<br />
For 8&#215;8: 1 +  3*13 = 40<br />
For 16&#215;16:121, 32&#215;32:364, 64&#215;64:1,093 &#8230;</p>
<p>It&#8217;s polynomial, not linear.  It&#8217;s growing faster than N^1.65.  This is much slower than the original solution.  In comparison, just doing a binary search on each row takes N*log2(N) comparisons, so the 64&#215;64 would require 64*6 = 384, quite a bit faster than the pick the middle algorithm.</p>
<p>An improvement to the pick the middle algorithm is to do a binary search on the diagonal from the upper left to lower right, and use the two adjacent values spanning the target to eliminate 1/2 of the matrix.  This algorithm takes 1/2*N*log2(N) comparisons, which is twice as fast as binary search on each row, though still far from optimal, and if the matrix doesn&#8217;t fit into cache, it will thrash memory much worse than a binary search on each row.</p>
<p>Improvements can be made over the original algorithm to improve cache performance.  For example, storing the matrix diagonal by diagonal rather than row by row increases the odds of a cache hit a lot for random data.  However, by that point, it probably makes more sense to finish sorting the table so that each row contains values greater than the previous rows, and less than the following rows, so you can do the search in O(log(N)).  Also, if you know the typical queries will not be middle-ish values, then you can save some time on average with a binary search along the left and bottom edges to find a better starting point, which is faster than starting in the lower-left corner and then scanning up or right for a significant fraction of the edge, but your worst case will then be 2*N + log2(2*N) &#8211; 1 comparisons.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-34914</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sun, 20 Apr 2014 09:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-34914</guid>
		<description><![CDATA[I have written divide-and conquer method to search key in n*n matrix where rows and columns both are sorted ascending. 
Algorithm is :-
Go for middle element. 
1) If middle element is same as key return.
2) If middle element is lesser than key then 
2a) search submatrix on lower side of middle element (half of matrix)
2b) Search submatrix on right hand side.of middle element (up-left quarter)
3) If middle element is greater than key then 
3a)  search vertical submatrix on left side of middle element (left vertical half)
3b) search submatrix on right hand side. (up-left quarter)

A picture could help it explain better. But code is also easy to understand.  Find code at 
http://ideone.com/zJ29vW

Can anyone comment is this algo is any better than above simple search; especially for large matrices ?]]></description>
		<content:encoded><![CDATA[<p>I have written divide-and conquer method to search key in n*n matrix where rows and columns both are sorted ascending.<br />
Algorithm is :-<br />
Go for middle element.<br />
1) If middle element is same as key return.<br />
2) If middle element is lesser than key then<br />
2a) search submatrix on lower side of middle element (half of matrix)<br />
2b) Search submatrix on right hand side.of middle element (up-left quarter)<br />
3) If middle element is greater than key then<br />
3a)  search vertical submatrix on left side of middle element (left vertical half)<br />
3b) search submatrix on right hand side. (up-left quarter)</p>
<p>A picture could help it explain better. But code is also easy to understand.  Find code at<br />
<a href="http://ideone.com/zJ29vW" rel="nofollow">http://ideone.com/zJ29vW</a></p>
<p>Can anyone comment is this algo is any better than above simple search; especially for large matrices ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-34854</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 19 Apr 2014 10:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-34854</guid>
		<description><![CDATA[What is the correct code for binary search method ?]]></description>
		<content:encoded><![CDATA[<p>What is the correct code for binary search method ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kartik</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-34694</link>
		<dc:creator><![CDATA[Kartik]]></dc:creator>
		<pubDate>Tue, 15 Apr 2014 08:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-34694</guid>
		<description><![CDATA[No, it is n/2.   



Original matrix size was n*n. The reduced matrix size is n/2*n/2]]></description>
		<content:encoded><![CDATA[<p>No, it is n/2.   </p>
<p>Original matrix size was n*n. The reduced matrix size is n/2*n/2</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kartik</title>
		<link>http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/#comment-34689</link>
		<dc:creator><![CDATA[Kartik]]></dc:creator>
		<pubDate>Tue, 15 Apr 2014 05:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11337#comment-34689</guid>
		<description><![CDATA[This may not work for many examples.  Here the assumption is wrong.  If an element is greater than the middle element, then we can discard half of the matrix, we can only discard, 1/4th of the matrix.]]></description>
		<content:encoded><![CDATA[<p>This may not work for many examples.  Here the assumption is wrong.  If an element is greater than the middle element, then we can discard half of the matrix, we can only discard, 1/4th of the matrix.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:12:44 -->

<!-- Compression = gzip -->