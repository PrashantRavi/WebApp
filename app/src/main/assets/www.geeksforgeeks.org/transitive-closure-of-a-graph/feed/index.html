<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Transitive closure of a graph</title>
	<atom:link href="http://www.geeksforgeeks.org/transitive-closure-of-a-graph/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Shiva Shankar Anumula</title>
		<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/#comment-29083</link>
		<dc:creator><![CDATA[Shiva Shankar Anumula]]></dc:creator>
		<pubDate>Sun, 20 Oct 2013 06:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28099#comment-29083</guid>
		<description><![CDATA[This problm can be solved in O(E *(V+E) Time complexity using DFS.]]></description>
		<content:encoded><![CDATA[<p>This problm can be solved in O(E *(V+E) Time complexity using DFS.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Shiwakant Bharti</title>
		<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/#comment-27804</link>
		<dc:creator><![CDATA[Shiwakant Bharti]]></dc:creator>
		<pubDate>Wed, 18 Sep 2013 09:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28099#comment-27804</guid>
		<description><![CDATA[@b544437281f46882bd567bb1bc30dc19:disqus Use of DFS should be just fine. What we are  looking for is &quot;The reach-ability matrix is called transitive closure of a graph&quot;. Hence we need to build the full matrix. So in whole it should take O(V*(E+V))  which is like O(V^2) for sparse matrix and O(V^3) for a dense one.]]></description>
		<content:encoded><![CDATA[<p>@b544437281f46882bd567bb1bc30dc19:disqus Use of DFS should be just fine. What we are  looking for is &#8220;The reach-ability matrix is called transitive closure of a graph&#8221;. Hence we need to build the full matrix. So in whole it should take O(V*(E+V))  which is like O(V^2) for sparse matrix and O(V^3) for a dense one.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: anonymous</title>
		<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/#comment-19329</link>
		<dc:creator><![CDATA[anonymous]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 16:16:28 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28099#comment-19329</guid>
		<description><![CDATA[@arvind : can u please clarify what actually u r doing here??]]></description>
		<content:encoded><![CDATA[<p>@arvind : can u please clarify what actually u r doing here??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anon</title>
		<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/#comment-16607</link>
		<dc:creator><![CDATA[Anon]]></dc:creator>
		<pubDate>Sat, 23 Mar 2013 08:14:13 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28099#comment-16607</guid>
		<description><![CDATA[Why can&#039;t we use backtracking(DFS) here. it will take O(E+V).]]></description>
		<content:encoded><![CDATA[<p>Why can&#8217;t we use backtracking(DFS) here. it will take O(E+V).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arvind B R</title>
		<link>http://www.geeksforgeeks.org/transitive-closure-of-a-graph/#comment-13142</link>
		<dc:creator><![CDATA[Arvind B R]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 19:33:42 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28099#comment-13142</guid>
		<description><![CDATA[an O(n^2) solution


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
int main()
{   
int a[4][4] = { {1, 1, 0, 1},
                        {0, 1, 1, 0},
                        {0, 0, 1, 1},
                        {0, 0, 0, 1}
                      };

int graph[4];
for(int i =0;i&#060;4;i++)
{
graph[i]= 0;
 for(int j =0;j&#060;4;j++)
 {
   if(a[i][j] == 1)
   {
       graph[i] &#124;= 1&#060;&#060;j;

   }
 }
}      

for(int k=0;k&#060;4;k++)
{
 for(int j=0;j&#060;4;j++)
 {
   if( graph[j]&#062;&#062;k &#038; 1 == 1)
   {
     graph[j] &#124;= graph[k];
   
   }
 
 }
}

for(int k=0;k&#060;4;k++)
{
 for(int j=0;j&#060;4;j++)
 {
 cout&#060;&#060;(graph[k]&#062;&#062;j &#038; 1)&#060;&#060;&#034;  &#034;;
 
 }
 cout&#060;&#060;&#034;\n&#034;;
}                      
                      
return 0;
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>an O(n^2) solution</p>
<pre> <code language="C">
int main()
{   
int a[4][4] = { {1, 1, 0, 1},
                        {0, 1, 1, 0},
                        {0, 0, 1, 1},
                        {0, 0, 0, 1}
                      };

int graph[4];
for(int i =0;i&lt;4;i++)
{
graph[i]= 0;
 for(int j =0;j&lt;4;j++)
 {
   if(a[i][j] == 1)
   {
       graph[i] |= 1&lt;&lt;j;

   }
 }
}      

for(int k=0;k&lt;4;k++)
{
 for(int j=0;j&lt;4;j++)
 {
   if( graph[j]&gt;&gt;k &amp; 1 == 1)
   {
     graph[j] |= graph[k];
   
   }
 
 }
}

for(int k=0;k&lt;4;k++)
{
 for(int j=0;j&lt;4;j++)
 {
 cout&lt;&lt;(graph[k]&gt;&gt;j &amp; 1)&lt;&lt;&quot;  &quot;;
 
 }
 cout&lt;&lt;&quot;\n&quot;;
}                      
                      
return 0;
}
</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.035 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:18:43 -->

<!-- Compression = gzip -->