<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Check for Children Sum Property in a Binary Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: MANAS KUMAR</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-39009</link>
		<dc:creator><![CDATA[MANAS KUMAR]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 06:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-39009</guid>
		<description><![CDATA[You should put condition when root has only one node then you should put it to 0.

if(root-&#062;left==NULL)

   root-&#062;left-&#062;data==0;

if(root-&#062;right==NULL)

   root-&#062;right-&#062;data==0;

if(root)
{
if(root-&#062;data = (root-&#062;left-&#062;data) + (root-&#062;right-&#062;data))
{
printf(&quot;node following check sum property %d--&quot;,root-&#062;data);
}
check_sum_property(root-&#062;left);
check_sum_property(root-&#062;right);
}
}]]></description>
		<content:encoded><![CDATA[<p>You should put condition when root has only one node then you should put it to 0.</p>
<p>if(root-&gt;left==NULL)</p>
<p>   root-&gt;left-&gt;data==0;</p>
<p>if(root-&gt;right==NULL)</p>
<p>   root-&gt;right-&gt;data==0;</p>
<p>if(root)<br />
{<br />
if(root-&gt;data = (root-&gt;left-&gt;data) + (root-&gt;right-&gt;data))<br />
{<br />
printf(&#8220;node following check sum property %d&#8211;&#8220;,root-&gt;data);<br />
}<br />
check_sum_property(root-&gt;left);<br />
check_sum_property(root-&gt;right);<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ThisIsWrong</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-38230</link>
		<dc:creator><![CDATA[ThisIsWrong]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 17:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-38230</guid>
		<description><![CDATA[Ok i missed that it is only for direct children My bad.]]></description>
		<content:encoded><![CDATA[<p>Ok i missed that it is only for direct children My bad.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ThisIsWrong</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-38229</link>
		<dc:creator><![CDATA[ThisIsWrong]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 17:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-38229</guid>
		<description><![CDATA[This is wrong. The left data and right data value can only be 0 or 1. So condition left_data+right_data == node-&#062;data will always be false.]]></description>
		<content:encoded><![CDATA[<p>This is wrong. The left data and right data value can only be 0 or 1. So condition left_data+right_data == node-&gt;data will always be false.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhilash Kumar</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-37385</link>
		<dc:creator><![CDATA[Abhilash Kumar]]></dc:creator>
		<pubDate>Sun, 01 Jun 2014 19:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-37385</guid>
		<description><![CDATA[what about dis code ?
int v=0;
void childSum(struct node *root)
{
if(root==NULL)
{
return;
}
childSum(root-&#062;left);
v+=root-&#062;left-&#062;data;
childSum(root-&#062;right)
v+=root-&#062;right-&#062;data;
if(v==root-&#062;data)
v=0;
else
{
printf(&quot;childsum not valid .&quot;);
exit(0);
}

}]]></description>
		<content:encoded><![CDATA[<p>what about dis code ?<br />
int v=0;<br />
void childSum(struct node *root)<br />
{<br />
if(root==NULL)<br />
{<br />
return;<br />
}<br />
childSum(root-&gt;left);<br />
v+=root-&gt;left-&gt;data;<br />
childSum(root-&gt;right)<br />
v+=root-&gt;right-&gt;data;<br />
if(v==root-&gt;data)<br />
v=0;<br />
else<br />
{<br />
printf(&#8220;childsum not valid .&#8221;);<br />
exit(0);<br />
}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mrigank Dembla</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-36547</link>
		<dc:creator><![CDATA[Mrigank Dembla]]></dc:creator>
		<pubDate>Fri, 23 May 2014 16:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-36547</guid>
		<description><![CDATA[Here is a non recursive way using Queue and level order. Please tell me if you find an error.. ! :)

http://ideone.com/0c05bR]]></description>
		<content:encoded><![CDATA[<p>Here is a non recursive way using Queue and level order. Please tell me if you find an error.. ! ðŸ™‚</p>
<p><a href="http://ideone.com/0c05bR" rel="nofollow">http://ideone.com/0c05bR</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neelabhsingh</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-36347</link>
		<dc:creator><![CDATA[neelabhsingh]]></dc:creator>
		<pubDate>Tue, 20 May 2014 17:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-36347</guid>
		<description><![CDATA[if((node-&#062;data == left_data + right_data)&#038;&#038;
        isSumProperty(node-&#062;left) &#038;&#038;
        isSumProperty(node-&#062;right))
      return 1;


It is possible to write above code as following?
return ((node-&#062;data == left_data + right_data) &#038;&#038; isSumProperty(node-&#062;left) &#038;&#038; isSumProperty(node-&#062;right))]]></description>
		<content:encoded><![CDATA[<p>if((node-&gt;data == left_data + right_data)&amp;&amp;<br />
        isSumProperty(node-&gt;left) &amp;&amp;<br />
        isSumProperty(node-&gt;right))<br />
      return 1;</p>
<p>It is possible to write above code as following?<br />
return ((node-&gt;data == left_data + right_data) &amp;&amp; isSumProperty(node-&gt;left) &amp;&amp; isSumProperty(node-&gt;right))</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-35204</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Sun, 27 Apr 2014 21:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-35204</guid>
		<description><![CDATA[Jave Implementation: Routine returns int value = root.data if the tree satisfies child sum property. else returns -1

static int isChildSumProperty(BTNode root)

	{

		if(root==null)

			return 0;

		

		if(isLeaf(root))

		{

			return root.data;

		}

		

		int l = isChildSumProperty(root.left);

		int r = isChildSumProperty(root.right);

		

		if(l==-1 &#124;&#124; r == -1)

			return -1;

		if(root.data == (l+r))

			return root.data;

		else

			return -1;

	}

	private static boolean isLeaf(BTNode root) {

		if(root.left == null &#038;&#038; root.right == null)

			return true;

		return false;

	}]]></description>
		<content:encoded><![CDATA[<p>Jave Implementation: Routine returns int value = root.data if the tree satisfies child sum property. else returns -1</p>
<p>static int isChildSumProperty(BTNode root)</p>
<p>	{</p>
<p>		if(root==null)</p>
<p>			return 0;</p>
<p>		if(isLeaf(root))</p>
<p>		{</p>
<p>			return root.data;</p>
<p>		}</p>
<p>		int l = isChildSumProperty(root.left);</p>
<p>		int r = isChildSumProperty(root.right);</p>
<p>		if(l==-1 || r == -1)</p>
<p>			return -1;</p>
<p>		if(root.data == (l+r))</p>
<p>			return root.data;</p>
<p>		else</p>
<p>			return -1;</p>
<p>	}</p>
<p>	private static boolean isLeaf(BTNode root) {</p>
<p>		if(root.left == null &amp;&amp; root.right == null)</p>
<p>			return true;</p>
<p>		return false;</p>
<p>	}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-35203</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Sun, 27 Apr 2014 21:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-35203</guid>
		<description><![CDATA[Else is needed. What if the condition is false? what should function return?]]></description>
		<content:encoded><![CDATA[<p>Else is needed. What if the condition is false? what should function return?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neelabhsingh</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-33270</link>
		<dc:creator><![CDATA[neelabhsingh]]></dc:creator>
		<pubDate>Fri, 07 Mar 2014 11:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-33270</guid>
		<description><![CDATA[GeeksforGeeks.  

 if((node-&#062;data == left_data + right_data)&#038;&#038;
        isSumProperty(node-&#062;left) &#038;&#038;
        isSumProperty(node-&#062;right))
      return 1;
    else
      return 0;
  }


Please check it. There is no use of else please remove it..]]></description>
		<content:encoded><![CDATA[<p>GeeksforGeeks.  </p>
<p> if((node-&gt;data == left_data + right_data)&amp;&amp;<br />
        isSumProperty(node-&gt;left) &amp;&amp;<br />
        isSumProperty(node-&gt;right))<br />
      return 1;<br />
    else<br />
      return 0;<br />
  }</p>
<p>Please check it. There is no use of else please remove it..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: NAVEEN PRAJAPATI</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-32874</link>
		<dc:creator><![CDATA[NAVEEN PRAJAPATI]]></dc:creator>
		<pubDate>Sat, 22 Feb 2014 17:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-32874</guid>
		<description><![CDATA[we can also do this by using post order traversal . below is the function given...

void check_sum_property(struct node *root)
{

  if(root)
  {
    if(root-&#062;data = (root-&#062;left-&#062;data) + (root-&#062;right-&#062;data))
    {
      printf(&quot;node following check sum property %d--&quot;,root-&#062;data);
    }
    check_sum_property(root-&#062;left);
    check_sum_property(root-&#062;right);
  }
}]]></description>
		<content:encoded><![CDATA[<p>we can also do this by using post order traversal . below is the function given&#8230;</p>
<p>void check_sum_property(struct node *root)<br />
{</p>
<p>  if(root)<br />
  {<br />
    if(root-&gt;data = (root-&gt;left-&gt;data) + (root-&gt;right-&gt;data))<br />
    {<br />
      printf(&#8220;node following check sum property %d&#8211;&#8220;,root-&gt;data);<br />
    }<br />
    check_sum_property(root-&gt;left);<br />
    check_sum_property(root-&gt;right);<br />
  }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: invince_guitar</title>
		<link>http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/#comment-28641</link>
		<dc:creator><![CDATA[invince_guitar]]></dc:creator>
		<pubDate>Wed, 09 Oct 2013 17:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=4358#comment-28641</guid>
		<description><![CDATA[Similar method..but done in my way. 
//................................................................

#include
#include

struct node 
{
int data;
struct node *l;
struct node *r;
};

struct node* create_node(int num)
{
struct node *temp=(struct node *)malloc(sizeof(struct node));
temp-&#062;data=num;
temp-&#062;l=NULL;
temp-&#062;r=NULL;
return temp;
}

int traverse(struct node *tree)
{
if(tree==NULL)
return 1;

	

if(tree-&#062;l==NULL &#038;&#038; tree-&#062;r!=NULL)
{
if(!(tree-&#062;r-&#062;data==tree-&#062;data))
return 0;
}

	if(tree-&#062;r==NULL &#038;&#038; tree-&#062;l!=NULL)
{
if(!(tree-&#062;l-&#062;data==tree-&#062;data))
return 0;
}

	if(tree-&#062;r!=NULL &#038;&#038; tree-&#062;l!=NULL)
{
if(!(tree-&#062;l-&#062;data+tree-&#062;r-&#062;data==tree-&#062;data))
return 0;
}

traverse(tree-&#062;l);
traverse(tree-&#062;r);
}

int main()

{
struct node *tree=NULL;
tree=create_node(10); 
tree-&#062;l=create_node(6);
tree-&#062;l-&#062;l=create_node(4);
tree-&#062;l-&#062;r=create_node(2);
tree-&#062;r=create_node(4);
tree-&#062;r-&#062;r=create_node(4);
tree-&#062;l-&#062;l-&#062;l=create_node(4);
tree-&#062;r-&#062;r-&#062;r=create_node(2);
tree-&#062;r-&#062;r-&#062;l=create_node(2);

	int ans=traverse(tree);

if(ans==1)
printf(&quot;satisfiedn&quot;);
else
printf(&quot;not satisfiedn&quot;);

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Similar method..but done in my way.<br />
//&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;.</p>
<p>#include<br />
#include</p>
<p>struct node<br />
{<br />
int data;<br />
struct node *l;<br />
struct node *r;<br />
};</p>
<p>struct node* create_node(int num)<br />
{<br />
struct node *temp=(struct node *)malloc(sizeof(struct node));<br />
temp-&gt;data=num;<br />
temp-&gt;l=NULL;<br />
temp-&gt;r=NULL;<br />
return temp;<br />
}</p>
<p>int traverse(struct node *tree)<br />
{<br />
if(tree==NULL)<br />
return 1;</p>
<p>if(tree-&gt;l==NULL &amp;&amp; tree-&gt;r!=NULL)<br />
{<br />
if(!(tree-&gt;r-&gt;data==tree-&gt;data))<br />
return 0;<br />
}</p>
<p>	if(tree-&gt;r==NULL &amp;&amp; tree-&gt;l!=NULL)<br />
{<br />
if(!(tree-&gt;l-&gt;data==tree-&gt;data))<br />
return 0;<br />
}</p>
<p>	if(tree-&gt;r!=NULL &amp;&amp; tree-&gt;l!=NULL)<br />
{<br />
if(!(tree-&gt;l-&gt;data+tree-&gt;r-&gt;data==tree-&gt;data))<br />
return 0;<br />
}</p>
<p>traverse(tree-&gt;l);<br />
traverse(tree-&gt;r);<br />
}</p>
<p>int main()</p>
<p>{<br />
struct node *tree=NULL;<br />
tree=create_node(10);<br />
tree-&gt;l=create_node(6);<br />
tree-&gt;l-&gt;l=create_node(4);<br />
tree-&gt;l-&gt;r=create_node(2);<br />
tree-&gt;r=create_node(4);<br />
tree-&gt;r-&gt;r=create_node(4);<br />
tree-&gt;l-&gt;l-&gt;l=create_node(4);<br />
tree-&gt;r-&gt;r-&gt;r=create_node(2);<br />
tree-&gt;r-&gt;r-&gt;l=create_node(2);</p>
<p>	int ans=traverse(tree);</p>
<p>if(ans==1)<br />
printf(&#8220;satisfiedn&#8221;);<br />
else<br />
printf(&#8220;not satisfiedn&#8221;);</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:32 -->

<!-- Compression = gzip -->