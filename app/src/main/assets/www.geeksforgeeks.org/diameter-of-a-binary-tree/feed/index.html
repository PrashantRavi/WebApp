<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Diameter of a Binary Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Abhi</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-40094</link>
		<dc:creator><![CDATA[Abhi]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 18:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-40094</guid>
		<description><![CDATA[GeeksforGeeks it would be max(lheight+rheight+2) in place of max(1+rheight+lheight)

please run this code and provide solution...

Node* root=NewNode(1);

	root-&#062;left=NewNode(2);

	root-&#062;right=NewNode(3);

	root-&#062;right-&#062;left=NewNode(78);

	root-&#062;left-&#062;left=NewNode(4);

	root-&#062;left-&#062;left-&#062;left=NewNode(5);]]></description>
		<content:encoded><![CDATA[<p>GeeksforGeeks it would be max(lheight+rheight+2) in place of max(1+rheight+lheight)</p>
<p>please run this code and provide solution&#8230;</p>
<p>Node* root=NewNode(1);</p>
<p>	root-&gt;left=NewNode(2);</p>
<p>	root-&gt;right=NewNode(3);</p>
<p>	root-&gt;right-&gt;left=NewNode(78);</p>
<p>	root-&gt;left-&gt;left=NewNode(4);</p>
<p>	root-&gt;left-&gt;left-&gt;left=NewNode(5);</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: shree</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-40029</link>
		<dc:creator><![CDATA[shree]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 09:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-40029</guid>
		<description><![CDATA[//Solution provided above is not working for skewed trees. Check out this solution. 
int postorder(struct node *t,int *h)
{   
    if(t==NULL)
    {
        *h=-1;
        return 0;
    }
    int ld,rd,lh,rh;
    ld=postorder2(t-&#062;left,&#038;lh);
    rd=postorder2(t-&#062;right,&#038;rh);    
    *h=max(lh,rh)+1;
   if(lh!=-1 &#038;&#038; rh !=-1)
        return lh+rh+1;
    else
        return max(ld,rd);
}]]></description>
		<content:encoded><![CDATA[<p>//Solution provided above is not working for skewed trees. Check out this solution.<br />
int postorder(struct node *t,int *h)<br />
{<br />
    if(t==NULL)<br />
    {<br />
        *h=-1;<br />
        return 0;<br />
    }<br />
    int ld,rd,lh,rh;<br />
    ld=postorder2(t-&gt;left,&amp;lh);<br />
    rd=postorder2(t-&gt;right,&amp;rh);<br />
    *h=max(lh,rh)+1;<br />
   if(lh!=-1 &amp;&amp; rh !=-1)<br />
        return lh+rh+1;<br />
    else<br />
        return max(ld,rd);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: 01210121</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-39809</link>
		<dc:creator><![CDATA[01210121]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 17:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-39809</guid>
		<description><![CDATA[nd moreover its giving wrong output for skewed tree .....in case of skewed tree it should be 0...]]></description>
		<content:encoded><![CDATA[<p>nd moreover its giving wrong output for skewed tree &#8230;..in case of skewed tree it should be 0&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: 01210121</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-39805</link>
		<dc:creator><![CDATA[01210121]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 17:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-39805</guid>
		<description><![CDATA[here in case of height y are u taking height of one root node as 1 instead of zero?]]></description>
		<content:encoded><![CDATA[<p>here in case of height y are u taking height of one root node as 1 instead of zero?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tushar</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-39114</link>
		<dc:creator><![CDATA[tushar]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 07:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-39114</guid>
		<description><![CDATA[no need to pass *height pointer or *dia pointer.. 

can be done without just maintain a global variable called max1

here is the code...its basically calculating height of tree and using only this condition max1=max(max(max(lh,rh),lh+rh+1),max1);
we can maintain a max1 variable wich has largest diameter

int max1;

int diameter(struct node* root)

{

	int lh=0,rh=0;

	if(root-&#062;left==NULL&#038;&#038;root-&#062;right==NULL)

	{

		return 1;

	}

	

	if(root-&#062;left)

		 lh=diameter(root-&#062;left);

	if(root-&#062;right)

		rh=diameter(root-&#062;right);

max1=max(max(max(lh,rh),lh+rh+1),max1);

//printf(&quot;n max1 %dn&quot;,max1);

	return max(lh,rh)+1;

}]]></description>
		<content:encoded><![CDATA[<p>no need to pass *height pointer or *dia pointer.. </p>
<p>can be done without just maintain a global variable called max1</p>
<p>here is the code&#8230;its basically calculating height of tree and using only this condition max1=max(max(max(lh,rh),lh+rh+1),max1);<br />
we can maintain a max1 variable wich has largest diameter</p>
<p>int max1;</p>
<p>int diameter(struct node* root)</p>
<p>{</p>
<p>	int lh=0,rh=0;</p>
<p>	if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)</p>
<p>	{</p>
<p>		return 1;</p>
<p>	}</p>
<p>	if(root-&gt;left)</p>
<p>		 lh=diameter(root-&gt;left);</p>
<p>	if(root-&gt;right)</p>
<p>		rh=diameter(root-&gt;right);</p>
<p>max1=max(max(max(lh,rh),lh+rh+1),max1);</p>
<p>//printf(&#8220;n max1 %dn&#8221;,max1);</p>
<p>	return max(lh,rh)+1;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit Kumar</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-38478</link>
		<dc:creator><![CDATA[Rohit Kumar]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 19:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-38478</guid>
		<description><![CDATA[int height(struct node* root)
{
   int i,j;
   if(root==NULL)return 0;
   i=height(root-&#062;prev);
   j=height(root-&#062;next);
   if(i&#062;j)return i+1;
   else return j+1;
}
int diameter(struct node*header)
{
    static int diam;
    int h=0;
    if(header==NULL)return 0;

    h=height(header-&#062;prev)+height(header-&#062;next)+1;
    if(h&#062;diam)diam=h;
    diameter(header-&#062;prev);
    diameter(header-&#062;next);
    return diam;
}]]></description>
		<content:encoded><![CDATA[<p>int height(struct node* root)<br />
{<br />
   int i,j;<br />
   if(root==NULL)return 0;<br />
   i=height(root-&gt;prev);<br />
   j=height(root-&gt;next);<br />
   if(i&gt;j)return i+1;<br />
   else return j+1;<br />
}<br />
int diameter(struct node*header)<br />
{<br />
    static int diam;<br />
    int h=0;<br />
    if(header==NULL)return 0;</p>
<p>    h=height(header-&gt;prev)+height(header-&gt;next)+1;<br />
    if(h&gt;diam)diam=h;<br />
    diameter(header-&gt;prev);<br />
    diameter(header-&gt;next);<br />
    return diam;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-38252</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 03:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-38252</guid>
		<description><![CDATA[It is O(n^2) for the first implementation. The second implementation is O(n) because we are not using a separate recursion in each node for finding height]]></description>
		<content:encoded><![CDATA[<p>It is O(n^2) for the first implementation. The second implementation is O(n) because we are not using a separate recursion in each node for finding height</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Yamini_yadav</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-38235</link>
		<dc:creator><![CDATA[Yamini_yadav]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 18:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-38235</guid>
		<description><![CDATA[You are calculating height for each node. (once left and once right). And you also go to find diameter of the node. Once left and once right, then why is complexity O(n). It will be O(n^2)
Consider a skewed tree 6-&#062;5-&#062;4-&#062;3-&#062;2-&#062;1 where -&#062; means left child
at node 6 , height_l == 1 iteration(go to all subnodes) 5 to 1
at node 5= height_l== 1 iteration (go to all subnodes) 4 to 1
like this the complexity will be (1+ 2+ 3....n-1)= O(n^2)]]></description>
		<content:encoded><![CDATA[<p>You are calculating height for each node. (once left and once right). And you also go to find diameter of the node. Once left and once right, then why is complexity O(n). It will be O(n^2)<br />
Consider a skewed tree 6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1 where -&gt; means left child<br />
at node 6 , height_l == 1 iteration(go to all subnodes) 5 to 1<br />
at node 5= height_l== 1 iteration (go to all subnodes) 4 to 1<br />
like this the complexity will be (1+ 2+ 3&#8230;.n-1)= O(n^2)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-38050</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 04:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-38050</guid>
		<description><![CDATA[This method is inefficient ( O(n^2) ) as mentioned in this post already.]]></description>
		<content:encoded><![CDATA[<p>This method is inefficient ( O(n^2) ) as mentioned in this post already.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-38048</link>
		<dc:creator><![CDATA[Rahul]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 04:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-38048</guid>
		<description><![CDATA[int getdiameter(node* root)

{

    if(root==NULL)
      return 0;

    else return       
       max3(getdiameter(root-&#062;left),getdiameter(root-&#062;right),1+height(root-             &#062;left)+height(root-&#062;right));
}



max3(a,b,c) returns the maximum among three integers]]></description>
		<content:encoded><![CDATA[<p>int getdiameter(node* root)</p>
<p>{</p>
<p>    if(root==NULL)<br />
      return 0;</p>
<p>    else return<br />
       max3(getdiameter(root-&gt;left),getdiameter(root-&gt;right),1+height(root-             &gt;left)+height(root-&gt;right));<br />
}</p>
<p>max3(a,b,c) returns the maximum among three integers</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/diameter-of-a-binary-tree/#comment-37752</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 14:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5687#comment-37752</guid>
		<description><![CDATA[Isn&#039;t it 
height(left) + height(right) +2 ?]]></description>
		<content:encoded><![CDATA[<p>Isn&#8217;t it<br />
height(left) + height(right) +2 ?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:03:32 -->

<!-- Compression = gzip -->