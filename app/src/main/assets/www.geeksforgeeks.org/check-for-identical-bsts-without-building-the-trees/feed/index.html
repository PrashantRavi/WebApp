<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Check for Identical BSTs without building the trees</title>
	<atom:link href="http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-38197</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 11:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-38197</guid>
		<description><![CDATA[int check(int a[],int b[],int min,int max,int i1,int i2,int n)
{
    for(;i1=min &#038;&#038; a[i1]&#060;=max)
        {    break;
        }
    }

        for(;i2=min &#038;&#038; b[i2]&#060;=max)
        {    break;
        }
    }

    if(i1==n &#038;&#038; i2==n)
    return 1;

    if(i1==n &#038;&#038; i2!=n &#124;&#124; i1!=n &#038;&#038; i2==n &#124;&#124; a[i1]!=b[i2])
    return 0;
    
    return check(a,b,min,a[i1]-1,i1+1,i2+1,n)
            &#038;&#038; check(a,b,a[i1]+1,max,i1+1,i2+1,n);
}]]></description>
		<content:encoded><![CDATA[<p>int check(int a[],int b[],int min,int max,int i1,int i2,int n)<br />
{<br />
    for(;i1=min &amp;&amp; a[i1]&lt;=max)<br />
        {    break;<br />
        }<br />
    }</p>
<p>        for(;i2=min &amp;&amp; b[i2]&lt;=max)<br />
        {    break;<br />
        }<br />
    }</p>
<p>    if(i1==n &amp;&amp; i2==n)<br />
    return 1;</p>
<p>    if(i1==n &amp;&amp; i2!=n || i1!=n &amp;&amp; i2==n || a[i1]!=b[i2])<br />
    return 0;</p>
<p>    return check(a,b,min,a[i1]-1,i1+1,i2+1,n)<br />
            &amp;&amp; check(a,b,a[i1]+1,max,i1+1,i2+1,n);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-38196</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 11:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-38196</guid>
		<description><![CDATA[time complexity will not be O(n) as 
each next element in the range is found in O(n) time complexty
and each array element will be visted once so it will be O(n2)]]></description>
		<content:encoded><![CDATA[<p>time complexity will not be O(n) as<br />
each next element in the range is found in O(n) time complexty<br />
and each array element will be visted once so it will be O(n2)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: superman</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-38167</link>
		<dc:creator><![CDATA[superman]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 05:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-38167</guid>
		<description><![CDATA[Time complexity will be O(n)
as in each iteration we will find element in time like 1,2,4,...,log(n) time
ie- in first iteration only one element compared, next time 2 and so on.. 
so T(n)=T(n-1)+C
C will be some of above series that is logarithm in complexity!]]></description>
		<content:encoded><![CDATA[<p>Time complexity will be O(n)<br />
as in each iteration we will find element in time like 1,2,4,&#8230;,log(n) time<br />
ie- in first iteration only one element compared, next time 2 and so on..<br />
so T(n)=T(n-1)+C<br />
C will be some of above series that is logarithm in complexity!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sagar Davasam</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-38137</link>
		<dc:creator><![CDATA[Sagar Davasam]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 18:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-38137</guid>
		<description><![CDATA[what are the values of INT_MIN and INT_MAX?]]></description>
		<content:encoded><![CDATA[<p>what are the values of INT_MIN and INT_MAX?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-35258</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Tue, 29 Apr 2014 00:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-35258</guid>
		<description><![CDATA[will not work if preorder and postorder traversals are given for BST]]></description>
		<content:encoded><![CDATA[<p>will not work if preorder and postorder traversals are given for BST</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-33103</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 01 Mar 2014 14:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-33103</guid>
		<description><![CDATA[Another method I could think of is: ( i is A[ ]&#039;s index and j is B[ ]&#039;s index )

* Start with i = 0 and j = 0. Check if the first element is same in both arrays (common root). If not, the BSTs have different structure

* Find the next smaller element in both the arrays and compare them. If they&#039;re not equal, then BSTs have different structure

* Traverse the array again but now keep checking if the next larger element in both arrays are equal. If not, BSTs are different.


We&#039;re traversing the array twice so it&#039;s O(N). If you guys find any bugs, do comment below!]]></description>
		<content:encoded><![CDATA[<p>Another method I could think of is: ( i is A[ ]&#8217;s index and j is B[ ]&#8217;s index )</p>
<p>* Start with i = 0 and j = 0. Check if the first element is same in both arrays (common root). If not, the BSTs have different structure</p>
<p>* Find the next smaller element in both the arrays and compare them. If they&#8217;re not equal, then BSTs have different structure</p>
<p>* Traverse the array again but now keep checking if the next larger element in both arrays are equal. If not, BSTs are different.</p>
<p>We&#8217;re traversing the array twice so it&#8217;s O(N). If you guys find any bugs, do comment below!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: akki</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-33073</link>
		<dc:creator><![CDATA[akki]]></dc:creator>
		<pubDate>Fri, 28 Feb 2014 09:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-33073</guid>
		<description><![CDATA[Consider the trees:
2
  
  3
   
     4


and 


          3
        /   
       2   4


They would have the same inorder traversal but different structures.]]></description>
		<content:encoded><![CDATA[<p>Consider the trees:<br />
2</p>
<p>  3</p>
<p>     4</p>
<p>and </p>
<p>          3<br />
        /<br />
       2   4</p>
<p>They would have the same inorder traversal but different structures.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-31135</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 30 Dec 2013 14:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-31135</guid>
		<description><![CDATA[I think the following should be an easier implementation:


bool IsIdenticalBST(int arr1[], int arr2[], int num_elems1, int num_elems2) {

    if (num_elems1 != num_elems2) return false;

    if (!num_elems1 &#038;&#038; !num_elems2) return true;

    

    if (arr1[0] == arr2[0]) return IsIdenticalBST(arr1+1, arr2+1, num_elems1-1, num_elems2-1);

    int i = 1;

    for (; i &#060; num_elems2; i++) {

        if (arr1[0] == arr2[i])

            break;

    }

    if (!IsIdenticalBST(arr1, arr2+i, i, i) &#124;&#124; !IsIdenticalBST(arr1+i, arr2, i, i)) return false;

    return IsIdenticalBST(arr1+2*i+1, arr2+2*i+1, num_elems1-2*i-1, num_elems2-2*i-1);

}]]></description>
		<content:encoded><![CDATA[<p>I think the following should be an easier implementation:</p>
<p>bool IsIdenticalBST(int arr1[], int arr2[], int num_elems1, int num_elems2) {</p>
<p>    if (num_elems1 != num_elems2) return false;</p>
<p>    if (!num_elems1 &amp;&amp; !num_elems2) return true;</p>
<p>    if (arr1[0] == arr2[0]) return IsIdenticalBST(arr1+1, arr2+1, num_elems1-1, num_elems2-1);</p>
<p>    int i = 1;</p>
<p>    for (; i &lt; num_elems2; i++) {</p>
<p>        if (arr1[0] == arr2[i])</p>
<p>            break;</p>
<p>    }</p>
<p>    if (!IsIdenticalBST(arr1, arr2+i, i, i) || !IsIdenticalBST(arr1+i, arr2, i, i)) return false;</p>
<p>    return IsIdenticalBST(arr1+2*i+1, arr2+2*i+1, num_elems1-2*i-1, num_elems2-2*i-1);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sumit</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-30658</link>
		<dc:creator><![CDATA[Sumit]]></dc:creator>
		<pubDate>Wed, 11 Dec 2013 19:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-30658</guid>
		<description><![CDATA[Tree for a will be (inorder travesal) : 
  2
  / 
1   3

Tree for b will be (preorder travesal) : 
http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/
  2
  / 
1  3


Both Tree appears to be same. Can you please tell us y sorting algo wont work.]]></description>
		<content:encoded><![CDATA[<p>Tree for a will be (inorder travesal) :<br />
  2<br />
  /<br />
1   3</p>
<p>Tree for b will be (preorder travesal) :<br />
<a href="http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/" rel="nofollow">http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/</a><br />
  2<br />
  /<br />
1  3</p>
<p>Both Tree appears to be same. Can you please tell us y sorting algo wont work.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anonymous</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-30522</link>
		<dc:creator><![CDATA[Anonymous]]></dc:creator>
		<pubDate>Sat, 07 Dec 2013 12:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-30522</guid>
		<description><![CDATA[yes, i think that is the way tree is constructed... it takes the first element as root and starts creating the tree...
in that case your solution fails.]]></description>
		<content:encoded><![CDATA[<p>yes, i think that is the way tree is constructed&#8230; it takes the first element as root and starts creating the tree&#8230;<br />
in that case your solution fails.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: anonymous</title>
		<link>http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/#comment-30468</link>
		<dc:creator><![CDATA[anonymous]]></dc:creator>
		<pubDate>Fri, 06 Dec 2013 06:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119697#comment-30468</guid>
		<description><![CDATA[I think that, they should make the same tree. Only one tree possible,
2
1 3

Tell me, how exactly is the array element order relevant? 
Is the following correct?
Okay, given the array {3,1,2,4}, is it that first the node with data &#039;3&#039; will be populated in BST, then node with &#039;1&#039; and then node with &#039;2&#039; and then &#039;4&#039;?
that is, 
&lt;code&gt;
1.)        3
2.)        3
      1
3.)        3
      1
         2
4.)        3
      1         4
         2
&lt;/code&gt;
If this is the way the BST is constructed from the array, then my logic is wrong.]]></description>
		<content:encoded><![CDATA[<p>I think that, they should make the same tree. Only one tree possible,<br />
2<br />
1 3</p>
<p>Tell me, how exactly is the array element order relevant?<br />
Is the following correct?<br />
Okay, given the array {3,1,2,4}, is it that first the node with data &#8216;3&#8217; will be populated in BST, then node with &#8216;1&#8217; and then node with &#8216;2&#8217; and then &#8216;4&#8217;?<br />
that is,<br />
<code><br />
1.)        3<br />
2.)        3<br />
      1<br />
3.)        3<br />
      1<br />
         2<br />
4.)        3<br />
      1         4<br />
         2<br />
</code><br />
If this is the way the BST is constructed from the array, then my logic is wrong.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:18:38 -->

<!-- Compression = gzip -->