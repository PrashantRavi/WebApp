<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Floor and Ceil from a BST</title>
	<atom:link href="http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ac</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-38793</link>
		<dc:creator><![CDATA[ac]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 07:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-38793</guid>
		<description><![CDATA[Dear GeeksforGeeks,
Don&#039;t you think that it should have been struct node *root instead of node *root since you have provided the C code?. It will work in C++ and not in C. Correct me if i&#039;m wrong :P]]></description>
		<content:encoded><![CDATA[<p>Dear GeeksforGeeks,<br />
Don&#8217;t you think that it should have been struct node *root instead of node *root since you have provided the C code?. It will work in C++ and not in C. Correct me if i&#8217;m wrong ðŸ˜›</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vin</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-38356</link>
		<dc:creator><![CDATA[vin]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 20:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-38356</guid>
		<description><![CDATA[@moderator - comment on below Floor and Ceil function in case corner cases are missing.

/*
int Floor(node *root, int input)
{

// Base case
if( root == NULL )
return 0;

if(input == root-&#062;key){
return input;	
}
else if(root-&#062;key &#062; input){
return Floor(root-&#062;left,input);
}
else{
int check = Floor(root-&#062;right,input);
return check != 0 ? check : root-&#062;key;
}
}

int Ceil(node *root, int input)
{
// Base case
if( root == NULL )
return -1;
if(input == root-&#062;key){
return input;	
}
else if(root-&#062;key right,input);
}
else{
int check = Ceil(root-&#062;left,input);
return check != -1 ? check : root-&#062;key;
}
}
*/]]></description>
		<content:encoded><![CDATA[<p>@moderator &#8211; comment on below Floor and Ceil function in case corner cases are missing.</p>
<p>/*<br />
int Floor(node *root, int input)<br />
{</p>
<p>// Base case<br />
if( root == NULL )<br />
return 0;</p>
<p>if(input == root-&gt;key){<br />
return input;<br />
}<br />
else if(root-&gt;key &gt; input){<br />
return Floor(root-&gt;left,input);<br />
}<br />
else{<br />
int check = Floor(root-&gt;right,input);<br />
return check != 0 ? check : root-&gt;key;<br />
}<br />
}</p>
<p>int Ceil(node *root, int input)<br />
{<br />
// Base case<br />
if( root == NULL )<br />
return -1;<br />
if(input == root-&gt;key){<br />
return input;<br />
}<br />
else if(root-&gt;key right,input);<br />
}<br />
else{<br />
int check = Ceil(root-&gt;left,input);<br />
return check != -1 ? check : root-&gt;key;<br />
}<br />
}<br />
*/</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-37628</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 19:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-37628</guid>
		<description><![CDATA[void floorNceil(bstnode *t,float k,int &#038;floor,int &#038;ceil)
{
    if(t!=NULL)
    {
        if(k==t-&#062;data)
        {
            ceil=t-&#062;data;
            floor=t-&#062;data;
        }
    
        else if(kdata)
        {
            ceil=t-&#062;data;
        floorNceil(t-&#062;lchild,k,floor,ceil);
        }
        else
        {
        floor=t-&#062;data;
        floorNceil(t-&#062;rchild,k,floor,ceil);
        }
        
    }
}]]></description>
		<content:encoded><![CDATA[<p>void floorNceil(bstnode *t,float k,int &amp;floor,int &amp;ceil)<br />
{<br />
    if(t!=NULL)<br />
    {<br />
        if(k==t-&gt;data)<br />
        {<br />
            ceil=t-&gt;data;<br />
            floor=t-&gt;data;<br />
        }</p>
<p>        else if(kdata)<br />
        {<br />
            ceil=t-&gt;data;<br />
        floorNceil(t-&gt;lchild,k,floor,ceil);<br />
        }<br />
        else<br />
        {<br />
        floor=t-&gt;data;<br />
        floorNceil(t-&gt;rchild,k,floor,ceil);<br />
        }</p>
<p>    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: devil</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-31558</link>
		<dc:creator><![CDATA[devil]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 09:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-31558</guid>
		<description><![CDATA[I think this is much better approach.
Do inorder traverasl and update Ceil &#038; Floor as we iterate.
http://ideone.com/oswEpn]]></description>
		<content:encoded><![CDATA[<p>I think this is much better approach.<br />
Do inorder traverasl and update Ceil &amp; Floor as we iterate.<br />
<a href="http://ideone.com/oswEpn" rel="nofollow">http://ideone.com/oswEpn</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Piyush Kapoor</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-28108</link>
		<dc:creator><![CDATA[Piyush Kapoor]]></dc:creator>
		<pubDate>Wed, 25 Sep 2013 15:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-28108</guid>
		<description><![CDATA[Your code is not even compiling !!]]></description>
		<content:encoded><![CDATA[<p>Your code is not even compiling !!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: srb</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-20382</link>
		<dc:creator><![CDATA[srb]]></dc:creator>
		<pubDate>Sat, 22 Jun 2013 19:53:34 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-20382</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code)

int floor(node *root, int input)
{
    // Base case
    if( root == NULL )
        return -1;
 
    // We found equal key
    if( root-&#062;key == input )
        return root-&#062;key;
 
    // If root&#039;s key is bigger, floor must be in left subtree
    if( root-&#062;key&#062; input )
        return floor(root-&#062;left, input);
 
    // Else, either right subtree or root has the floor value
    int floor = floor(root-&#062;right, input);
    return (floor &#060;= input &#038;&#038; floor!=-1) ? floor : root-&#062;key;
}
  */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code)

int floor(node *root, int input)
{
    // Base case
    if( root == NULL )
        return -1;
 
    // We found equal key
    if( root-&gt;key == input )
        return root-&gt;key;
 
    // If root's key is bigger, floor must be in left subtree
    if( root-&gt;key&gt; input )
        return floor(root-&gt;left, input);
 
    // Else, either right subtree or root has the floor value
    int floor = floor(root-&gt;right, input);
    return (floor &lt;= input &amp;&amp; floor!=-1) ? floor : root-&gt;key;
}
  */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-18472</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Wed, 22 May 2013 18:24:34 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-18472</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: spandan</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-18437</link>
		<dc:creator><![CDATA[spandan]]></dc:creator>
		<pubDate>Tue, 21 May 2013 14:50:49 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-18437</guid>
		<description><![CDATA[Yes]]></description>
		<content:encoded><![CDATA[<p>Yes</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-14986</link>
		<dc:creator><![CDATA[Amit]]></dc:creator>
		<pubDate>Sun, 03 Feb 2013 03:43:29 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-14986</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
#include&#060;stdio.h&#062;
#include &#060;limits.h&#062;
#include&#060;stdlib.h&#062;
int floor = 0;
int ceil = 0;
struct node{
       int data;
       struct node *left;
       struct node *right;
};
struct node * newNode(int data ){
       struct node * node = (struct node *)malloc(sizeof(struct node));
       node-&#062;left = NULL;
       node-&#062;data = data;
       node-&#062;right = NULL;
       return node;
}
void findfloor(struct node * root,int data){
     if(root==NULL){
                    return ;
     }
     if(root-&#062;data == data){
                   
                   floor = root-&#062;data;
     }
     else if(root-&#062;data &#060; data){
                  if(root-&#062;data &#060; data &#038;&#038; root-&#062;data &#062; floor){
                                floor = root-&#062;data;
                  }
                  findfloor(root-&#062;right,data);      
     }
     else if(root-&#062;data &#062; data){
                  if(root-&#062;data &#060; data &#038;&#038; root-&#062;data &#062; floor){
                                floor = root-&#062;data;
                  }
                  findfloor(root-&#062;left,data);      
     }
}
void findceil(struct node * root,int data){
     if(root==NULL){
                    return ;
     }
     if(root-&#062;data == data){
                   
                   ceil = root-&#062;data;
     }
     else if(root-&#062;data &#060; data){
                  if(root-&#062;data &#062; data &#038;&#038; root-&#062;data &#060; ceil){
                                ceil = root-&#062;data;
                  }
                  findceil(root-&#062;right,data);      
     }
     else if(root-&#062;data &#062; data){
                  if(root-&#062;data &#062; data &#038;&#038; root-&#062;data &#060; ceil){
                                ceil = root-&#062;data;
                  }
                  findceil(root-&#062;left,data);      
     }
}

int main()
{
//  struct node *root  = newNode(18);
//  root-&#062;left         = newNode(12);
//  root-&#062;left-&#062;left   = newNode(4);
//  root-&#062;left-&#062;right  = newNode(15);
//  root-&#062;left-&#062;left-&#062;left = newNode(1);
//  root-&#062;left-&#062;left-&#062;left-&#062;right = newNode(3);
//  root-&#062;left-&#062;right = newNode(15);
//  root-&#062;left-&#062;right-&#062;left = newNode(13);
//  root-&#062;left-&#062;right-&#062;left-&#062;right = newNode(14);
//  root-&#062;right = newNode(25);
//  root-&#062;right-&#062;left = newNode(25);
//  root-&#062;right-&#062;right = newNode(30);
//  root-&#062;right-&#062;right-&#062;left= newNode(28);
//  root-&#062;right-&#062;right-&#062;left-&#062;right = newNode(29);
// Driver program to test above function
    int i;
    struct node *root = newNode(8);
 
    root-&#062;left = newNode(4);
    root-&#062;right = newNode(12);
 
    root-&#062;left-&#062;left = newNode(2);
    root-&#062;left-&#062;right = newNode(6);
 
    root-&#062;right-&#062;left = newNode(10);
    root-&#062;right-&#062;right = newNode(14);
    
    printf(&#034;Ceil :-\n&#034;);
    for(i = 0; i &#060; 16; i++){
        ceil = INT_MAX;  
        findceil(root, i);
        if(ceil == INT_MAX){
                ceil = -1;
        }
        printf(&#034;%d  %d\n&#034;, i, ceil);
    } 
    printf(&#034;\nfloor :-\n&#034;); 
    for(i = 0; i &#060; 16; i++){
        floor = 0;      
        findfloor(root,i);
        if(floor == 0){
                floor = -1;
        }
        printf(&#034;%d  %d\n&#034;, i,floor ); 
    }
  getchar();
  return 0;
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
#include&lt;stdio.h&gt;
#include &lt;limits.h&gt;
#include&lt;stdlib.h&gt;
int floor = 0;
int ceil = 0;
struct node{
       int data;
       struct node *left;
       struct node *right;
};
struct node * newNode(int data ){
       struct node * node = (struct node *)malloc(sizeof(struct node));
       node-&gt;left = NULL;
       node-&gt;data = data;
       node-&gt;right = NULL;
       return node;
}
void findfloor(struct node * root,int data){
     if(root==NULL){
                    return ;
     }
     if(root-&gt;data == data){
                   
                   floor = root-&gt;data;
     }
     else if(root-&gt;data &lt; data){
                  if(root-&gt;data &lt; data &amp;&amp; root-&gt;data &gt; floor){
                                floor = root-&gt;data;
                  }
                  findfloor(root-&gt;right,data);      
     }
     else if(root-&gt;data &gt; data){
                  if(root-&gt;data &lt; data &amp;&amp; root-&gt;data &gt; floor){
                                floor = root-&gt;data;
                  }
                  findfloor(root-&gt;left,data);      
     }
}
void findceil(struct node * root,int data){
     if(root==NULL){
                    return ;
     }
     if(root-&gt;data == data){
                   
                   ceil = root-&gt;data;
     }
     else if(root-&gt;data &lt; data){
                  if(root-&gt;data &gt; data &amp;&amp; root-&gt;data &lt; ceil){
                                ceil = root-&gt;data;
                  }
                  findceil(root-&gt;right,data);      
     }
     else if(root-&gt;data &gt; data){
                  if(root-&gt;data &gt; data &amp;&amp; root-&gt;data &lt; ceil){
                                ceil = root-&gt;data;
                  }
                  findceil(root-&gt;left,data);      
     }
}

int main()
{
//  struct node *root  = newNode(18);
//  root-&gt;left         = newNode(12);
//  root-&gt;left-&gt;left   = newNode(4);
//  root-&gt;left-&gt;right  = newNode(15);
//  root-&gt;left-&gt;left-&gt;left = newNode(1);
//  root-&gt;left-&gt;left-&gt;left-&gt;right = newNode(3);
//  root-&gt;left-&gt;right = newNode(15);
//  root-&gt;left-&gt;right-&gt;left = newNode(13);
//  root-&gt;left-&gt;right-&gt;left-&gt;right = newNode(14);
//  root-&gt;right = newNode(25);
//  root-&gt;right-&gt;left = newNode(25);
//  root-&gt;right-&gt;right = newNode(30);
//  root-&gt;right-&gt;right-&gt;left= newNode(28);
//  root-&gt;right-&gt;right-&gt;left-&gt;right = newNode(29);
// Driver program to test above function
    int i;
    struct node *root = newNode(8);
 
    root-&gt;left = newNode(4);
    root-&gt;right = newNode(12);
 
    root-&gt;left-&gt;left = newNode(2);
    root-&gt;left-&gt;right = newNode(6);
 
    root-&gt;right-&gt;left = newNode(10);
    root-&gt;right-&gt;right = newNode(14);
    
    printf(&quot;Ceil :-\n&quot;);
    for(i = 0; i &lt; 16; i++){
        ceil = INT_MAX;  
        findceil(root, i);
        if(ceil == INT_MAX){
                ceil = -1;
        }
        printf(&quot;%d  %d\n&quot;, i, ceil);
    } 
    printf(&quot;\nfloor :-\n&quot;); 
    for(i = 0; i &lt; 16; i++){
        floor = 0;      
        findfloor(root,i);
        if(floor == 0){
                floor = -1;
        }
        printf(&quot;%d  %d\n&quot;, i,floor ); 
    }
  getchar();
  return 0;
}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Meghanath Macha</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-14033</link>
		<dc:creator><![CDATA[Meghanath Macha]]></dc:creator>
		<pubDate>Thu, 27 Dec 2012 06:28:39 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-14033</guid>
		<description><![CDATA[Hey Ceil / Floor is similar to Successor / Predecessor right ?]]></description>
		<content:encoded><![CDATA[<p>Hey Ceil / Floor is similar to Successor / Predecessor right ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nomind</title>
		<link>http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/#comment-13845</link>
		<dc:creator><![CDATA[Nomind]]></dc:creator>
		<pubDate>Fri, 21 Dec 2012 08:09:59 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12996#comment-13845</guid>
		<description><![CDATA[#include 
#include 
#include 
 
/* A binary tree node has key, left child and right child */
struct node
{
    int key;
    struct node* left;
    struct node* right;
};
 
/* Helper function that allocates a new node with the given key and
   NULL left and right  pointers.*/
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&#062;key = key;
    node-&#062;left = NULL;
    node-&#062;right = NULL;
    return(node);
}
 
// Function to find ceil of a given input in BST. If input is more
// than the max key in BST, return -1
int floor(node *root, int input)
{
    // Base case
    if( root == NULL )
        return INT_MAX;
 
    // We found equal key
    if( root-&#062;key == input )
        return root-&#062;key;
 
    // If root&#039;s key is smaller, ceil must be in right subtree
    if( root-&#062;key &#062; input )
        return floor(root-&#062;left, input);
 
    // Else, either left subtree or root has the ceil value
    int Floor = floor(root-&#062;right, input);
    return (Floor key;
}
 
// Driver program to test above function
int main()
{
    node *root = newNode(8);
 
    root-&#062;left = newNode(4);
    root-&#062;right = newNode(12);
 
    root-&#062;left-&#062;left = newNode(2);
    root-&#062;left-&#062;right = newNode(6);
 
    root-&#062;right-&#062;left = newNode(10);
    root-&#062;right-&#062;right = newNode(14);
 
    for(int i = 0; i &#060; 16; i++)
        printf(&#034;%d  %d\n&#034;, i, floor(root, i));
        getchar();
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include </p>
<p>/* A binary tree node has key, left child and right child */<br />
struct node<br />
{<br />
    int key;<br />
    struct node* left;<br />
    struct node* right;<br />
};</p>
<p>/* Helper function that allocates a new node with the given key and<br />
   NULL left and right  pointers.*/<br />
struct node* newNode(int key)<br />
{<br />
    struct node* node = (struct node*)malloc(sizeof(struct node));<br />
    node-&gt;key = key;<br />
    node-&gt;left = NULL;<br />
    node-&gt;right = NULL;<br />
    return(node);<br />
}</p>
<p>// Function to find ceil of a given input in BST. If input is more<br />
// than the max key in BST, return -1<br />
int floor(node *root, int input)<br />
{<br />
    // Base case<br />
    if( root == NULL )<br />
        return INT_MAX;</p>
<p>    // We found equal key<br />
    if( root-&gt;key == input )<br />
        return root-&gt;key;</p>
<p>    // If root&#8217;s key is smaller, ceil must be in right subtree<br />
    if( root-&gt;key &gt; input )<br />
        return floor(root-&gt;left, input);</p>
<p>    // Else, either left subtree or root has the ceil value<br />
    int Floor = floor(root-&gt;right, input);<br />
    return (Floor key;<br />
}</p>
<p>// Driver program to test above function<br />
int main()<br />
{<br />
    node *root = newNode(8);</p>
<p>    root-&gt;left = newNode(4);<br />
    root-&gt;right = newNode(12);</p>
<p>    root-&gt;left-&gt;left = newNode(2);<br />
    root-&gt;left-&gt;right = newNode(6);</p>
<p>    root-&gt;right-&gt;left = newNode(10);<br />
    root-&gt;right-&gt;right = newNode(14);</p>
<p>    for(int i = 0; i &lt; 16; i++)<br />
        printf(&quot;%d  %d\n&quot;, i, floor(root, i));<br />
        getchar();<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:06:40 -->

<!-- Compression = gzip -->