<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Given a binary tree, print out all of its root-to-leaf paths one per line.</title>
	<atom:link href="http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ashish</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-39856</link>
		<dc:creator><![CDATA[ashish]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 09:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-39856</guid>
		<description><![CDATA[no it wont work...]]></description>
		<content:encoded><![CDATA[<p>no it wont work&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Deepesh Panjabi</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-39248</link>
		<dc:creator><![CDATA[Deepesh Panjabi]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 12:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-39248</guid>
		<description><![CDATA[http://ideone.com/Xu5xbc]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/Xu5xbc" rel="nofollow">http://ideone.com/Xu5xbc</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Baghel</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-39163</link>
		<dc:creator><![CDATA[Amit Baghel]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 14:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-39163</guid>
		<description><![CDATA[flag=true;]]></description>
		<content:encoded><![CDATA[<p>flag=true;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: MANAS KUMAR</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-38945</link>
		<dc:creator><![CDATA[MANAS KUMAR]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 12:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-38945</guid>
		<description><![CDATA[Thanks]]></description>
		<content:encoded><![CDATA[<p>Thanks</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vikas Rajoria</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-38775</link>
		<dc:creator><![CDATA[Vikas Rajoria]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 05:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-38775</guid>
		<description><![CDATA[Simple dfs example, use stacks for this.]]></description>
		<content:encoded><![CDATA[<p>Simple dfs example, use stacks for this.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-37605</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 12:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-37605</guid>
		<description><![CDATA[i think it should be ( in for loop )
&quot; i&#060;j &#034; not &#034; i&#060;=j &#034;]]></description>
		<content:encoded><![CDATA[<p>i think it should be ( in for loop )<br />
&#8221; i&lt;j &quot; not &quot; i&lt;=j &quot;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek Garg</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-36603</link>
		<dc:creator><![CDATA[Vivek Garg]]></dc:creator>
		<pubDate>Sun, 25 May 2014 06:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-36603</guid>
		<description><![CDATA[Here is the another way for doing this.I change some modifications in original node class and adding an extra parent node pointer which point to the parent of an particular node.
C++ implementation for this is given below.

#include &quot;iostream&quot;

using namespace std;

class node

{

    public:

    int data;

    node *left,*right,*parent;

    node()

    {

        left=NULL;

        right=NULL;

        parent=NULL;

    }

};

node* newNode(int d)

{

    node *nd=new node();

    nd-&#062;data=d;

    return nd;

}

void assignParent(node *root)

{

    if(root==NULL) return;

    if(root-&#062;left !=NULL)

    root-&#062;left-&#062;parent=root;

    if(root-&#062;right!=NULL)

    root-&#062;right-&#062;parent=root;

    assignParent(root-&#062;left);

    assignParent(root-&#062;right);

}

void rootToLeafPath(node *root)

{

    if(root==NULL) return;

    if(root-&#062;left==NULL &#038;&#038; root-&#062;right==NULL)

    {

        node *root1=root;

        while(root1-&#062;parent!=NULL)

        {

            cout&#060;data&#060;parent;

        }

        cout&#060;data&#060;left);

    rootToLeafPath(root-&#062;right);

}

int main()

{

    node *root=new node();

    root-&#062;data=1;

    root-&#062;left=newNode(2);

    root-&#062;right=newNode(3);

    root-&#062;left-&#062;left=newNode(4);

    root-&#062;left-&#062;right=newNode(5);

    assignParent(root);

cout&#060;&#060;&#034;n Root to leaf path one per linen&#034;;

    rootToLeafPath(root);

}]]></description>
		<content:encoded><![CDATA[<p>Here is the another way for doing this.I change some modifications in original node class and adding an extra parent node pointer which point to the parent of an particular node.<br />
C++ implementation for this is given below.</p>
<p>#include &#8220;iostream&#8221;</p>
<p>using namespace std;</p>
<p>class node</p>
<p>{</p>
<p>    public:</p>
<p>    int data;</p>
<p>    node *left,*right,*parent;</p>
<p>    node()</p>
<p>    {</p>
<p>        left=NULL;</p>
<p>        right=NULL;</p>
<p>        parent=NULL;</p>
<p>    }</p>
<p>};</p>
<p>node* newNode(int d)</p>
<p>{</p>
<p>    node *nd=new node();</p>
<p>    nd-&gt;data=d;</p>
<p>    return nd;</p>
<p>}</p>
<p>void assignParent(node *root)</p>
<p>{</p>
<p>    if(root==NULL) return;</p>
<p>    if(root-&gt;left !=NULL)</p>
<p>    root-&gt;left-&gt;parent=root;</p>
<p>    if(root-&gt;right!=NULL)</p>
<p>    root-&gt;right-&gt;parent=root;</p>
<p>    assignParent(root-&gt;left);</p>
<p>    assignParent(root-&gt;right);</p>
<p>}</p>
<p>void rootToLeafPath(node *root)</p>
<p>{</p>
<p>    if(root==NULL) return;</p>
<p>    if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)</p>
<p>    {</p>
<p>        node *root1=root;</p>
<p>        while(root1-&gt;parent!=NULL)</p>
<p>        {</p>
<p>            cout&lt;data&lt;parent;</p>
<p>        }</p>
<p>        cout&lt;data&lt;left);</p>
<p>    rootToLeafPath(root-&gt;right);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    node *root=new node();</p>
<p>    root-&gt;data=1;</p>
<p>    root-&gt;left=newNode(2);</p>
<p>    root-&gt;right=newNode(3);</p>
<p>    root-&gt;left-&gt;left=newNode(4);</p>
<p>    root-&gt;left-&gt;right=newNode(5);</p>
<p>    assignParent(root);</p>
<p>cout&lt;&lt;&quot;n Root to leaf path one per linen&quot;;</p>
<p>    rootToLeafPath(root);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Tony</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-33856</link>
		<dc:creator><![CDATA[Tony]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 05:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-33856</guid>
		<description><![CDATA[public void allPathSum(BNode root,Stack s){
        
        if (root == null){
            return;
            
        }
        s.add(root);
        if (root.left == null &#038;&#038; root.right == null){
            int sum =0;
            for (BNode node : s){
                System.out.print(node.data+&quot; + &quot;);
                sum =sum+node.data;
            }
            System.out.print(&quot; = &quot;+(sum)+&quot; n&quot;);
            
        }
        
        allPathSum(root.left,s);
        
        allPathSum(root.right,s);
        s.pop();
        
        
    }]]></description>
		<content:encoded><![CDATA[<p>public void allPathSum(BNode root,Stack s){</p>
<p>        if (root == null){<br />
            return;</p>
<p>        }<br />
        s.add(root);<br />
        if (root.left == null &amp;&amp; root.right == null){<br />
            int sum =0;<br />
            for (BNode node : s){<br />
                System.out.print(node.data+&#8221; + &#8220;);<br />
                sum =sum+node.data;<br />
            }<br />
            System.out.print(&#8221; = &#8220;+(sum)+&#8221; n&#8221;);</p>
<p>        }</p>
<p>        allPathSum(root.left,s);</p>
<p>        allPathSum(root.right,s);<br />
        s.pop();</p>
<p>    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gandalf</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-33444</link>
		<dc:creator><![CDATA[Gandalf]]></dc:creator>
		<pubDate>Wed, 12 Mar 2014 23:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-33444</guid>
		<description><![CDATA[//From Leaf To Root without extra space.

boolean rootToLeaf(Node root){

if(root == null) return false;

if(!root.left &#038;&#038; !root.right) return true;

if(rootToLeaf(root.left)) System.out.println(root..left.data);

if(rootToLeaf(root.right))System.out.println(root.right.data); 


return true;

}]]></description>
		<content:encoded><![CDATA[<p>//From Leaf To Root without extra space.</p>
<p>boolean rootToLeaf(Node root){</p>
<p>if(root == null) return false;</p>
<p>if(!root.left &amp;&amp; !root.right) return true;</p>
<p>if(rootToLeaf(root.left)) System.out.println(root..left.data);</p>
<p>if(rootToLeaf(root.right))System.out.println(root.right.data); </p>
<p>return true;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Marsha Donna</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-33236</link>
		<dc:creator><![CDATA[Marsha Donna]]></dc:creator>
		<pubDate>Wed, 05 Mar 2014 17:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-33236</guid>
		<description><![CDATA[#include
#include
#include
struct node
{
	char data;
	struct node *left;
	struct node *right;
};

struct node* insert(char item)
{
	struct node *temp=(struct node *)malloc(sizeof(struct node));
	temp-&#062;data=item;
	temp-&#062;left=NULL;
	temp-&#062;right=NULL;
	return temp;
}

void display(struct node *root)
{
	if(root==NULL)return;
	
	printf(&quot;%c &quot;,root-&#062;data);
	display(root-&#062;left);
	display(root-&#062;right);
	
}

void disp_all_root_2_leaf_path(struct node *node,char arr[],int j)
{	

	int i;
	if(node==NULL)return;
	
	if((node-&#062;left==NULL)&#038;&#038;(node-&#062;right==NULL))
	{	arr[j]=node-&#062;data;
		for(i=0;idata;
	j++;
	disp_all_root_2_leaf_path(node-&#062;left,arr,j);
	disp_all_root_2_leaf_path(node-&#062;right,arr,j);
}





int main(void) {
	int i,j=0;
	char arr[50];
	struct node*root=insert(&#039;a&#039;);
	root-&#062;left=insert(&#039;b&#039;);
	root-&#062;right=insert(&#039;c&#039;);
	root-&#062;left-&#062;left=insert(&#039;d&#039;);
	root-&#062;left-&#062;right=insert(&#039;e&#039;);
	root-&#062;right-&#062;left=insert(&#039;f&#039;);
	
	printf(&quot;now the tree is displayed in preordern&quot;);
	display(root);
	printf(&quot;n&quot;);
	
	for(i=0;i&#060;50;i++)
	arr[i]=&#039;&#039;;
	
	disp_all_root_2_leaf_path(root,arr,j);
	
	return 0;
}
]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
struct node<br />
{<br />
	char data;<br />
	struct node *left;<br />
	struct node *right;<br />
};</p>
<p>struct node* insert(char item)<br />
{<br />
	struct node *temp=(struct node *)malloc(sizeof(struct node));<br />
	temp-&gt;data=item;<br />
	temp-&gt;left=NULL;<br />
	temp-&gt;right=NULL;<br />
	return temp;<br />
}</p>
<p>void display(struct node *root)<br />
{<br />
	if(root==NULL)return;</p>
<p>	printf(&#8220;%c &#8220;,root-&gt;data);<br />
	display(root-&gt;left);<br />
	display(root-&gt;right);</p>
<p>}</p>
<p>void disp_all_root_2_leaf_path(struct node *node,char arr[],int j)<br />
{	</p>
<p>	int i;<br />
	if(node==NULL)return;</p>
<p>	if((node-&gt;left==NULL)&amp;&amp;(node-&gt;right==NULL))<br />
	{	arr[j]=node-&gt;data;<br />
		for(i=0;idata;<br />
	j++;<br />
	disp_all_root_2_leaf_path(node-&gt;left,arr,j);<br />
	disp_all_root_2_leaf_path(node-&gt;right,arr,j);<br />
}</p>
<p>int main(void) {<br />
	int i,j=0;<br />
	char arr[50];<br />
	struct node*root=insert(&#8216;a&#8217;);<br />
	root-&gt;left=insert(&#8216;b&#8217;);<br />
	root-&gt;right=insert(&#8216;c&#8217;);<br />
	root-&gt;left-&gt;left=insert(&#8216;d&#8217;);<br />
	root-&gt;left-&gt;right=insert(&#8216;e&#8217;);<br />
	root-&gt;right-&gt;left=insert(&#8216;f&#8217;);</p>
<p>	printf(&#8220;now the tree is displayed in preordern&#8221;);<br />
	display(root);<br />
	printf(&#8220;n&#8221;);</p>
<p>	for(i=0;i&lt;50;i++)<br />
	arr[i]=&#039;&#039;;</p>
<p>	disp_all_root_2_leaf_path(root,arr,j);</p>
<p>	return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: cruser11232</title>
		<link>http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/#comment-33009</link>
		<dc:creator><![CDATA[cruser11232]]></dc:creator>
		<pubDate>Wed, 26 Feb 2014 12:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1005#comment-33009</guid>
		<description><![CDATA[void PrintPathSub(node * root, stack * stk)
{
     if(root== NULL)
         return;
    
     push(stk,root-&#062;data);
     PrintPathSub(root-&#062;left,stk);
    
     PrintPathSub(root-&#062;right,stk);    

     if(root-&#062;left==NULL &#038;&#038; root-&#062;right==NULL )
     {
         print(stk);
     }
     pop(stk);
}]]></description>
		<content:encoded><![CDATA[<p>void PrintPathSub(node * root, stack * stk)<br />
{<br />
     if(root== NULL)<br />
         return;</p>
<p>     push(stk,root-&gt;data);<br />
     PrintPathSub(root-&gt;left,stk);</p>
<p>     PrintPathSub(root-&gt;right,stk);    </p>
<p>     if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL )<br />
     {<br />
         print(stk);<br />
     }<br />
     pop(stk);<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.052 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:33 -->

<!-- Compression = gzip -->