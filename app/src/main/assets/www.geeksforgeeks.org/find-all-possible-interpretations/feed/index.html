<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find all possible interpretations of an array of digits</title>
	<atom:link href="http://www.geeksforgeeks.org/find-all-possible-interpretations/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Omi</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-37974</link>
		<dc:creator><![CDATA[Omi]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 07:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-37974</guid>
		<description><![CDATA[c++ implementation

#include
#include
using namespace std;
struct node{
char a[15];
node* left;
node* right;
node(char x[])
{
  strcpy(a,x);
  left=right=NULL;
};
};
void createTree(node*&#038; root,int input[],int findex,int size)
{
   if(findex==size)
   return;
   char s[15];char v[15];
   if(findexa);
           v[0]=input[findex]+96;
           v[1]=&#039;&#039;;
           strcat(s,v);
           root-&#062;left=new node(s);
           if(input[findex]*10+input[findex+1]&#062;26){
           root-&#062;right=NULL;
           }
           else
           {
               int c=input[findex]*10+input[findex+1];
               v[0]=c+96;
               v[1]=&#039;&#039;;
               strcpy(s,root-&#062;a);
               strcat(s,v);
               root-&#062;right=new node(s);
           }
           createTree(root-&#062;left,input,findex+1,size);
           if(root-&#062;right)
           createTree(root-&#062;right,input,findex+2,size);
   }
   else if(findex==size-1)
   {
           strcpy(s,root-&#062;a);
           v[0]=input[findex]+96;
           v[1]=&#039;&#039;;
           strcat(s,v);
           root-&#062;left=new node(s);
           root-&#062;right=NULL;
   }
}
void print(node* root)
{
    if(root)
    {
        if(!root-&#062;left &#038;&#038; !root-&#062;right)
            cout&#060;a&#060;left);
        print(root-&#062;right);

    }
}
int main()
{
    node* root=new node(&quot;&quot;);
    int a[]={1,1,3,4};
    createTree(root,a,0,4);
    print(root);
    return 0;
}
]]></description>
		<content:encoded><![CDATA[<p>c++ implementation</p>
<p>#include<br />
#include<br />
using namespace std;<br />
struct node{<br />
char a[15];<br />
node* left;<br />
node* right;<br />
node(char x[])<br />
{<br />
  strcpy(a,x);<br />
  left=right=NULL;<br />
};<br />
};<br />
void createTree(node*&amp; root,int input[],int findex,int size)<br />
{<br />
   if(findex==size)<br />
   return;<br />
   char s[15];char v[15];<br />
   if(findexa);<br />
           v[0]=input[findex]+96;<br />
           v[1]=&#8221;;<br />
           strcat(s,v);<br />
           root-&gt;left=new node(s);<br />
           if(input[findex]*10+input[findex+1]&gt;26){<br />
           root-&gt;right=NULL;<br />
           }<br />
           else<br />
           {<br />
               int c=input[findex]*10+input[findex+1];<br />
               v[0]=c+96;<br />
               v[1]=&#8221;;<br />
               strcpy(s,root-&gt;a);<br />
               strcat(s,v);<br />
               root-&gt;right=new node(s);<br />
           }<br />
           createTree(root-&gt;left,input,findex+1,size);<br />
           if(root-&gt;right)<br />
           createTree(root-&gt;right,input,findex+2,size);<br />
   }<br />
   else if(findex==size-1)<br />
   {<br />
           strcpy(s,root-&gt;a);<br />
           v[0]=input[findex]+96;<br />
           v[1]=&#8221;;<br />
           strcat(s,v);<br />
           root-&gt;left=new node(s);<br />
           root-&gt;right=NULL;<br />
   }<br />
}<br />
void print(node* root)<br />
{<br />
    if(root)<br />
    {<br />
        if(!root-&gt;left &amp;&amp; !root-&gt;right)<br />
            cout&lt;a&lt;left);<br />
        print(root-&gt;right);</p>
<p>    }<br />
}<br />
int main()<br />
{<br />
    node* root=new node(&#8220;&#8221;);<br />
    int a[]={1,1,3,4};<br />
    createTree(root,a,0,4);<br />
    print(root);<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: silu</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-37401</link>
		<dc:creator><![CDATA[silu]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 05:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-37401</guid>
		<description><![CDATA[//Tapopadma Tripathy

#include

#include

#include

#include

#include

#include

#include

using namespace std;

char given[100];

int ln;

struct code

{

    char ch[100];code *l;code *r;

};

void make_tree(code *root,int i)

{

    if(i &#062;= ln) return;

    if(!root) return;

    char prev[100];int j=0;

    for(int ii=0;iich);prev[j++]=root-&#062;ch[ii],++ii);

    if(given[i]-&#039;0&#039;){

        prev[j++] = given[i]-&#039;0&#039;-1+&#039;a&#039;;

        prev[j]=&#039;&#039;;

        code *left = new code;

        strcpy(left-&#062;ch,prev);

        left-&#062;l=0;left-&#062;r=0;

        root-&#062;l = left;

        root-&#062;r = 0;}

    if(i+1 &#060; ln){

    int sum = 10*(given[i]-&#039;0&#039;)+given[i+1]-&#039;0&#039;;

    if(sum ch,prev);

        right-&#062;l=0;right-&#062;r=0;

        root-&#062;r = right;

    }

    }

    make_tree(root-&#062;l,i+1);

    make_tree(root-&#062;r,i+2);

}

void print_leaves(code *root)

{

    if(!root) return;

    if(!root-&#062;l and !root-&#062;r) cout&#060;ch&#060;l);

    print_leaves(root-&#062;r);

}

int main()

{

    scanf(&quot;%s&quot;,given);

    ln = strlen(given);

    code *root = new code;

    root-&#062;ch[0] = &#039;&#039;;root-&#062;l = 0;root-&#062;r = 0;

    make_tree(root,0);

    printf(&quot;=================================n&quot;);

    print_leaves(root);

}]]></description>
		<content:encoded><![CDATA[<p>//Tapopadma Tripathy</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>char given[100];</p>
<p>int ln;</p>
<p>struct code</p>
<p>{</p>
<p>    char ch[100];code *l;code *r;</p>
<p>};</p>
<p>void make_tree(code *root,int i)</p>
<p>{</p>
<p>    if(i &gt;= ln) return;</p>
<p>    if(!root) return;</p>
<p>    char prev[100];int j=0;</p>
<p>    for(int ii=0;iich);prev[j++]=root-&gt;ch[ii],++ii);</p>
<p>    if(given[i]-&#8216;0&#8217;){</p>
<p>        prev[j++] = given[i]-&#8216;0&#8242;-1+&#8217;a&#8217;;</p>
<p>        prev[j]=&#8221;;</p>
<p>        code *left = new code;</p>
<p>        strcpy(left-&gt;ch,prev);</p>
<p>        left-&gt;l=0;left-&gt;r=0;</p>
<p>        root-&gt;l = left;</p>
<p>        root-&gt;r = 0;}</p>
<p>    if(i+1 &lt; ln){</p>
<p>    int sum = 10*(given[i]-&#039;0&#039;)+given[i+1]-&#039;0&#039;;</p>
<p>    if(sum ch,prev);</p>
<p>        right-&gt;l=0;right-&gt;r=0;</p>
<p>        root-&gt;r = right;</p>
<p>    }</p>
<p>    }</p>
<p>    make_tree(root-&gt;l,i+1);</p>
<p>    make_tree(root-&gt;r,i+2);</p>
<p>}</p>
<p>void print_leaves(code *root)</p>
<p>{</p>
<p>    if(!root) return;</p>
<p>    if(!root-&gt;l and !root-&gt;r) cout&lt;ch&lt;l);</p>
<p>    print_leaves(root-&gt;r);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    scanf(&#8220;%s&#8221;,given);</p>
<p>    ln = strlen(given);</p>
<p>    code *root = new code;</p>
<p>    root-&gt;ch[0] = &#8221;;root-&gt;l = 0;root-&gt;r = 0;</p>
<p>    make_tree(root,0);</p>
<p>    printf(&#8220;=================================n&#8221;);</p>
<p>    print_leaves(root);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: 12rad</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-36891</link>
		<dc:creator><![CDATA[12rad]]></dc:creator>
		<pubDate>Tue, 27 May 2014 00:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-36891</guid>
		<description><![CDATA[Code in JAVA

static int [] a= new int[]{1,2,1};

	static char c[]={&#039; &#039;,&#039;a&#039;,&#039;b&#039;,&#039;c&#039;,&#039;d&#039;,&#039;e&#039;,&#039;f&#039;,&#039;g&#039;,&#039;h&#039;,&#039;i&#039;,&#039;j&#039;,&#039;k&#039;,&#039;l&#039;,&#039;m&#039;,&#039;n&#039;,&#039;o&#039;,&#039;p&#039;,&#039;q&#039;,&#039;r&#039;,&#039;s&#039;,&#039;t&#039;,&#039;u&#039;,&#039;v&#039;,&#039;w&#039;,&#039;x&#039;,&#039;y&#039;,&#039;z&#039;};

	static int result [] = new int[3];

	public static void printInterpretations(int id, int resultId, char[] result){

		

  if(id == (a.length)){

        if(resultId&#060;id){
           result[resultId]=&#039;&#039;;
        }
 
         System.out.println(Arrays.toString(result));
   return;
		}

		result[resultId] = c[a[id]];
		printInterpretations(id+1, resultId+1, result);

		if(id&#060;a.length-1){

         if((a[id]*10 +a[id+1])&#060;=26){
              int nums = a[id]*10 +a[id+1];
              result[resultId ] = c[nums];
              printInterpretations(id+2, resultId+1, result);
 }

		}]]></description>
		<content:encoded><![CDATA[<p>Code in JAVA</p>
<p>static int [] a= new int[]{1,2,1};</p>
<p>	static char c[]={&#8216; &#8216;,&#8217;a&#8217;,&#8217;b&#8217;,&#8217;c&#8217;,&#8217;d&#8217;,&#8217;e&#8217;,&#8217;f&#8217;,&#8217;g&#8217;,&#8217;h&#8217;,&#8217;i&#8217;,&#8217;j&#8217;,&#8217;k&#8217;,&#8217;l&#8217;,&#8217;m&#8217;,&#8217;n&#8217;,&#8217;o&#8217;,&#8217;p&#8217;,&#8217;q&#8217;,&#8217;r&#8217;,&#8217;s&#8217;,&#8217;t&#8217;,&#8217;u&#8217;,&#8217;v&#8217;,&#8217;w&#8217;,&#8217;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;};</p>
<p>	static int result [] = new int[3];</p>
<p>	public static void printInterpretations(int id, int resultId, char[] result){</p>
<p>  if(id == (a.length)){</p>
<p>        if(resultId&lt;id){<br />
           result[resultId]=&#039;&#039;;<br />
        }</p>
<p>         System.out.println(Arrays.toString(result));<br />
   return;<br />
		}</p>
<p>		result[resultId] = c[a[id]];<br />
		printInterpretations(id+1, resultId+1, result);</p>
<p>		if(id&lt;a.length-1){</p>
<p>         if((a[id]*10 +a[id+1])&lt;=26){<br />
              int nums = a[id]*10 +a[id+1];<br />
              result[resultId ] = c[nums];<br />
              printInterpretations(id+2, resultId+1, result);<br />
 }</p>
<p>		}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: guest</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-36890</link>
		<dc:creator><![CDATA[guest]]></dc:creator>
		<pubDate>Mon, 26 May 2014 23:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-36890</guid>
		<description><![CDATA[void PrintDecodings(const int* a, size_t length, std::string acc){
        static const char* alphabet = &quot;0abcdefghijklmnopqrstuvwxyz&quot;;
        if(length == 0){
            std::cout &#060;&#060; acc &#060;&#060; std::endl;
            return;
        }
        if(length == 1){
            std::cout &#060;&#060; acc &#060;&#060; alphabet[*a] &#060;&#060; std::endl;
            return;
        }
        if(10*a[0]+a[1] =2, so a[1] is OK
            PrintDecodings(a+2, length-2, acc+alphabet[10*a[0]+a[1]]);
        }
        return PrintDecodings(a+1, length-1, acc+alphabet[*a]);
    }

A solution that seems simpler]]></description>
		<content:encoded><![CDATA[<p>void PrintDecodings(const int* a, size_t length, std::string acc){<br />
        static const char* alphabet = &#8220;0abcdefghijklmnopqrstuvwxyz&#8221;;<br />
        if(length == 0){<br />
            std::cout &lt;&lt; acc &lt;&lt; std::endl;<br />
            return;<br />
        }<br />
        if(length == 1){<br />
            std::cout &lt;&lt; acc &lt;&lt; alphabet[*a] &lt;&lt; std::endl;<br />
            return;<br />
        }<br />
        if(10*a[0]+a[1] =2, so a[1] is OK<br />
            PrintDecodings(a+2, length-2, acc+alphabet[10*a[0]+a[1]]);<br />
        }<br />
        return PrintDecodings(a+1, length-1, acc+alphabet[*a]);<br />
    }</p>
<p>A solution that seems simpler</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Peace</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-36012</link>
		<dc:creator><![CDATA[Peace]]></dc:creator>
		<pubDate>Wed, 14 May 2014 02:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-36012</guid>
		<description><![CDATA[Its important to know this is class example of fibonacci series. 
e.g {1,1,1,1} can be interpreted in 5 ways which is total number of interpretation of n=3 + n=2. This is exactly same as number of ways to reach 4th step provided you can only move 1 step or 2 steps at a time.]]></description>
		<content:encoded><![CDATA[<p>Its important to know this is class example of fibonacci series.<br />
e.g {1,1,1,1} can be interpreted in 5 ways which is total number of interpretation of n=3 + n=2. This is exactly same as number of ways to reach 4th step provided you can only move 1 step or 2 steps at a time.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-35255</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 21:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-35255</guid>
		<description><![CDATA[Another non-tree based solution using recursion:

#include

int a[3]={1, 2, 1};

char c[]={&#039;0&#039;,&#039;a&#039;,&#039;b&#039;,&#039;c&#039;,&#039;d&#039;,&#039;e&#039;,&#039;f&#039;,&#039;g&#039;,&#039;h&#039;,&#039;i&#039;,&#039;j&#039;,&#039;k&#039;,&#039;l&#039;,&#039;m&#039;,&#039;n&#039;,&#039;o&#039;,&#039;p&#039;,&#039;q&#039;,&#039;r&#039;,&#039;s&#039;,&#039;t&#039;,&#039;u&#039;,&#039;v&#039;,&#039;w&#039;,&#039;x&#039;,&#039;y&#039;,&#039;z&#039;};

void func(int i,char result[3],int r)

{

	int index;

	int temp;

    if(i&#062;=3)

    {

      	for(index=0;index&#060;3;index++)

      	{

      		printf(&#034;%c, &#034;,result[index]);

      	}

      	printf(&#034;n&#034;);

       return;

    }

    if(i+1&#060;3)

    {

    	temp = 10*a[i]+a[i+1];

    	if(temp&#060;=26)

    	{

     	 	result[r]=c[temp];

    	    func(i+2,result,r+1);

    	}

    }

    result[r]=c[a[i]];

    func(i+1,result,r+1);

}

int main()

{

    char result[10];

    func(0,result,0);

}]]></description>
		<content:encoded><![CDATA[<p>Another non-tree based solution using recursion:</p>
<p>#include</p>
<p>int a[3]={1, 2, 1};</p>
<p>char c[]={&#8216;0&#8242;,&#8217;a&#8217;,&#8217;b&#8217;,&#8217;c&#8217;,&#8217;d&#8217;,&#8217;e&#8217;,&#8217;f&#8217;,&#8217;g&#8217;,&#8217;h&#8217;,&#8217;i&#8217;,&#8217;j&#8217;,&#8217;k&#8217;,&#8217;l&#8217;,&#8217;m&#8217;,&#8217;n&#8217;,&#8217;o&#8217;,&#8217;p&#8217;,&#8217;q&#8217;,&#8217;r&#8217;,&#8217;s&#8217;,&#8217;t&#8217;,&#8217;u&#8217;,&#8217;v&#8217;,&#8217;w&#8217;,&#8217;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;};</p>
<p>void func(int i,char result[3],int r)</p>
<p>{</p>
<p>	int index;</p>
<p>	int temp;</p>
<p>    if(i&gt;=3)</p>
<p>    {</p>
<p>      	for(index=0;index&lt;3;index++)</p>
<p>      	{</p>
<p>      		printf(&quot;%c, &quot;,result[index]);</p>
<p>      	}</p>
<p>      	printf(&quot;n&quot;);</p>
<p>       return;</p>
<p>    }</p>
<p>    if(i+1&lt;3)</p>
<p>    {</p>
<p>    	temp = 10*a[i]+a[i+1];</p>
<p>    	if(temp&lt;=26)</p>
<p>    	{</p>
<p>     	 	result[r]=c[temp];</p>
<p>    	    func(i+2,result,r+1);</p>
<p>    	}</p>
<p>    }</p>
<p>    result[r]=c[a[i]];</p>
<p>    func(i+1,result,r+1);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    char result[10];</p>
<p>    func(0,result,0);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-35144</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 08:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-35144</guid>
		<description><![CDATA[tree* possible(string word, queue temp)

{

     tree *root=newnode(word);

     if(temp.empty())

     {

         cout&#060;str&#060;left=possible(word+char(96+a),temp);}

          if(!temp.empty())

          {

           a=a*10+temp.front()-&#039;0&#039;;

           temp.pop();

           root-&#062;right=possible(word+char(96+a),temp);

          }

     return root;

}]]></description>
		<content:encoded><![CDATA[<p>tree* possible(string word, queue temp)</p>
<p>{</p>
<p>     tree *root=newnode(word);</p>
<p>     if(temp.empty())</p>
<p>     {</p>
<p>         cout&lt;str&lt;left=possible(word+char(96+a),temp);}</p>
<p>          if(!temp.empty())</p>
<p>          {</p>
<p>           a=a*10+temp.front()-&#8216;0&#8217;;</p>
<p>           temp.pop();</p>
<p>           root-&gt;right=possible(word+char(96+a),temp);</p>
<p>          }</p>
<p>     return root;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bhopu</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-34952</link>
		<dc:creator><![CDATA[bhopu]]></dc:creator>
		<pubDate>Mon, 21 Apr 2014 11:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-34952</guid>
		<description><![CDATA[change in leaf to hold modified string

#include

#include

#include

struct tree{

    char *str;

    struct tree *lchild;

    struct tree *rchild;

};

struct tree *getnode(char *str,int n){

    struct tree *newnode=(struct tree *)malloc(sizeof(struct tree));

    newnode-&#062;str=(char *)malloc(sizeof(char)*n);

    newnode-&#062;lchild=NULL;

    newnode-&#062;rchild=NULL;

return newnode;

}

struct tree *insert(char *hash,char *str,char *temp,int lavel,int remen,int index,int child,int n){

    if(remen&#060;0)

    return NULL;

    int i,j=0,ind=0;

   

    struct tree *root=getnode(str,n);

   

    char *prstr=(char*)malloc(sizeof(char)*n);

    int size=strlen(temp);

    

    for(i=0;i&#060;size;i++){

        prstr[j]=temp[i];

        if(i==index&#124;&#124;(child==2&#038;&#038;i==index-1)){

     

              

           if(child==1)

           prstr[j]=hash[temp[i]-49];

           else{

               ind=temp[i++]-48;

               ind=10*ind;

               ind+=temp[i]-48;

               if(ind26)

               return NULL;

               prstr[j]=hash[ind-1];

               index--;

               

           }

        }

        j++;

    }

   

   

    prstr[j]=&#039;&#039;;

    strcpy(root-&#062;str,prstr);

    root-&#062;lchild=insert(hash,str,prstr,lavel+1,remen-1,index+1,1,n);

    root-&#062;rchild=insert(hash,str,prstr,lavel+1,remen-2,index+2,2,n);

    

    return root;

}

traverse(struct tree *ptr){

    

    if(ptr){

        

        

       traverse(ptr-&#062;lchild);

       if(ptr-&#062;lchild==NULL&#038;&#038;ptr-&#062;rchild==NULL)

       printf(&quot;  %s&quot;,ptr-&#062;str);

       traverse(ptr-&#062;rchild);        

    }

}

    

    

 main(){

     struct tree *root;

     char str[]={&#039;1&#039;,&#039;2&#039;,&#039;2&#039;,&#039;1&#039;};

     char hash[]={&#039;a&#039;,&#039;b&#039;,&#039;c&#039;,&#039;d&#039;,&#039;e&#039;,&#039;f&#039;,&#039;g&#039;,&#039;h&#039;,&#039;i&#039;,&#039;j&#039;,&#039;k&#039;,&#039;l&#039;,&#039;m&#039;,&#039;n&#039;,&#039;o&#039;,&#039;p&#039;,&#039;q&#039;,&#039;r&#039;,&#039;s&#039;,&#039;t&#039;,&#039;u&#039;,&#039;v&#039;,&#039;w&#039;,&#039;x&#039;,&#039;y&#039;,&#039;z&#039;};

     

     int n=strlen(str);

     char *temp=(char*)malloc(sizeof(char)*n);

     strcpy(temp,str);

    

     root=insert(hash,str,temp,0,n,-1,0,n);

     

     traverse(root);

     

 }]]></description>
		<content:encoded><![CDATA[<p>change in leaf to hold modified string</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct tree{</p>
<p>    char *str;</p>
<p>    struct tree *lchild;</p>
<p>    struct tree *rchild;</p>
<p>};</p>
<p>struct tree *getnode(char *str,int n){</p>
<p>    struct tree *newnode=(struct tree *)malloc(sizeof(struct tree));</p>
<p>    newnode-&gt;str=(char *)malloc(sizeof(char)*n);</p>
<p>    newnode-&gt;lchild=NULL;</p>
<p>    newnode-&gt;rchild=NULL;</p>
<p>return newnode;</p>
<p>}</p>
<p>struct tree *insert(char *hash,char *str,char *temp,int lavel,int remen,int index,int child,int n){</p>
<p>    if(remen&lt;0)</p>
<p>    return NULL;</p>
<p>    int i,j=0,ind=0;</p>
<p>    struct tree *root=getnode(str,n);</p>
<p>    char *prstr=(char*)malloc(sizeof(char)*n);</p>
<p>    int size=strlen(temp);</p>
<p>    for(i=0;i&lt;size;i++){</p>
<p>        prstr[j]=temp[i];</p>
<p>        if(i==index||(child==2&amp;&amp;i==index-1)){</p>
<p>           if(child==1)</p>
<p>           prstr[j]=hash[temp[i]-49];</p>
<p>           else{</p>
<p>               ind=temp[i++]-48;</p>
<p>               ind=10*ind;</p>
<p>               ind+=temp[i]-48;</p>
<p>               if(ind26)</p>
<p>               return NULL;</p>
<p>               prstr[j]=hash[ind-1];</p>
<p>               index&#8211;;</p>
<p>           }</p>
<p>        }</p>
<p>        j++;</p>
<p>    }</p>
<p>    prstr[j]=&#8221;;</p>
<p>    strcpy(root-&gt;str,prstr);</p>
<p>    root-&gt;lchild=insert(hash,str,prstr,lavel+1,remen-1,index+1,1,n);</p>
<p>    root-&gt;rchild=insert(hash,str,prstr,lavel+1,remen-2,index+2,2,n);</p>
<p>    return root;</p>
<p>}</p>
<p>traverse(struct tree *ptr){</p>
<p>    if(ptr){</p>
<p>       traverse(ptr-&gt;lchild);</p>
<p>       if(ptr-&gt;lchild==NULL&amp;&amp;ptr-&gt;rchild==NULL)</p>
<p>       printf(&#8221;  %s&#8221;,ptr-&gt;str);</p>
<p>       traverse(ptr-&gt;rchild);        </p>
<p>    }</p>
<p>}</p>
<p> main(){</p>
<p>     struct tree *root;</p>
<p>     char str[]={&#8216;1&#8242;,&#8217;2&#8242;,&#8217;2&#8242;,&#8217;1&#8217;};</p>
<p>     char hash[]={&#8216;a&#8217;,&#8217;b&#8217;,&#8217;c&#8217;,&#8217;d&#8217;,&#8217;e&#8217;,&#8217;f&#8217;,&#8217;g&#8217;,&#8217;h&#8217;,&#8217;i&#8217;,&#8217;j&#8217;,&#8217;k&#8217;,&#8217;l&#8217;,&#8217;m&#8217;,&#8217;n&#8217;,&#8217;o&#8217;,&#8217;p&#8217;,&#8217;q&#8217;,&#8217;r&#8217;,&#8217;s&#8217;,&#8217;t&#8217;,&#8217;u&#8217;,&#8217;v&#8217;,&#8217;w&#8217;,&#8217;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;};</p>
<p>     int n=strlen(str);</p>
<p>     char *temp=(char*)malloc(sizeof(char)*n);</p>
<p>     strcpy(temp,str);</p>
<p>     root=insert(hash,str,temp,0,n,-1,0,n);</p>
<p>     traverse(root);</p>
<p> }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Umang Mahajan</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-33886</link>
		<dc:creator><![CDATA[Umang Mahajan]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 18:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-33886</guid>
		<description><![CDATA[great!! Just one modification...do you really need to pass &#039;d&#039; as a parameter? 

#include
#include
#include
using namespace std;

string alpha[] = {&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;,&quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;v&quot;, &quot;z&quot;};

void create(int arr[],int n,string res)
{
	if (n==0)
	{
		cout&#060;&#060;res&#060;1)
	{
		d=arr[0]*10+arr[1];
		if (d &#060; 27)
			create (arr+2,n-2,res+alpha[d]);
	}
}

void printAllInterpretations(int arr[],int n)
{
	create(arr,n,&#034;&#034;);
}

int main()
{
	int arr[] = {1, 2, 1};
	int n=sizeof(arr)/sizeof(arr[0]);
        printAllInterpretations(arr,n);
        return 0;
}

This seems to work fine]]></description>
		<content:encoded><![CDATA[<p>great!! Just one modification&#8230;do you really need to pass &#8216;d&#8217; as a parameter? </p>
<p>#include<br />
#include<br />
#include<br />
using namespace std;</p>
<p>string alpha[] = {&#8220;&#8221;, &#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;,&#8221;f&#8221;, &#8220;g&#8221;, &#8220;h&#8221;, &#8220;i&#8221;, &#8220;j&#8221;, &#8220;k&#8221;, &#8220;l&#8221;, &#8220;m&#8221;, &#8220;n&#8221;, &#8220;o&#8221;, &#8220;p&#8221;, &#8220;q&#8221;, &#8220;r&#8221;, &#8220;s&#8221;, &#8220;t&#8221;, &#8220;u&#8221;, &#8220;v&#8221;, &#8220;w&#8221;, &#8220;x&#8221;, &#8220;v&#8221;, &#8220;z&#8221;};</p>
<p>void create(int arr[],int n,string res)<br />
{<br />
	if (n==0)<br />
	{<br />
		cout&lt;&lt;res&lt;1)<br />
	{<br />
		d=arr[0]*10+arr[1];<br />
		if (d &lt; 27)<br />
			create (arr+2,n-2,res+alpha[d]);<br />
	}<br />
}</p>
<p>void printAllInterpretations(int arr[],int n)<br />
{<br />
	create(arr,n,&quot;&quot;);<br />
}</p>
<p>int main()<br />
{<br />
	int arr[] = {1, 2, 1};<br />
	int n=sizeof(arr)/sizeof(arr[0]);<br />
        printAllInterpretations(arr,n);<br />
        return 0;<br />
}</p>
<p>This seems to work fine</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: naveenbobbili</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-32618</link>
		<dc:creator><![CDATA[naveenbobbili]]></dc:creator>
		<pubDate>Sun, 16 Feb 2014 20:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-32618</guid>
		<description><![CDATA[Below is my solution using only recursion.

/*
 * patterns.cpp
 *
 *  Created on: Feb 16, 2014
 *      Author: naveen1.b
 */
#include
#include
#include
#include
#include

using namespace std;

static string alphabets[] = { &quot; &quot;,
&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;,  &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;,
&quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;,
&quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;
};

list printAllInterpretationsUtil(int* a, int start, int size) {
    int noOfElementsToProcess = size - start;
    list combinations;
    if (noOfElementsToProcess == 1) {
        int elem = a[start];
        if (elem &#060;= 26) {
            string str = alphabets[elem];
            //cout &#060;&#060; &#034;Pushing &#034; &#060;&#060; str &#060;&#060; &#034;n&#034;;
            //cout &#060;&#060; &#034;===========================&#034; &#060; 1) {
        // Recursive call to same function.
        int elem = a[start];
        list results = printAllInterpretationsUtil(a, start + 1, size);
        list::iterator it;
        // Perform permuations in a for loop.
        for (it = results.begin(); it != results.end(); ++it) {
            string result = *it;
            // simple append and push
            string pattern;
            pattern  = alphabets[elem];
            //cout &#060;&#060; &#034;Pushing &#034; &#060;&#060; pattern+result &#060;&#060; &#034;n&#034;;
            combinations.push_back(pattern + result);

            // mix and check . for eg 1 and 1 as 11 etc
            int suffix = (result[0] - &#039;a&#039;) + 1;
            if (suffix &#060; 10) {
                int patternInt = (elem * 10) + suffix;
                if (patternInt  1) {
                        //cout &#060;&#060; &#034;Pushing &#034; &#060;&#060; pattern + result.substr(1, result.length() - 1) &#060;&#060; &#034;n&#034;;
                        combinations.push_back(pattern + result.substr(1, result.length() - 1));
                    } else {
                        //cout &#060;&#060; &#034;Pushing &#034; &#060;&#060; pattern &#060;&#060; &#034;n&#034;;
                        combinations.push_back(pattern);
                    }
                }
            }
            // cout &#060;&#060; &#034;===========================&#034; &#060;&#060; &#034;n&#034;;
        }
    }
    return combinations;
}

void printAllInterpretations(int* a, int size) {
    if (NULL == a)
        return;

    list result = printAllInterpretationsUtil(a, 0, size);
    list::iterator it;
    for (it = result.begin(); it != result.end(); ++it) {
        cout &#060;&#060; *it &#060;&#060; &#034;,&#034;;
    }
    cout &#060;&#060; &#034;n&#034;;
}

int main() {
    int a[] = {1,1,3,4};
    printAllInterpretations(a, 4);

    int b[4] = {1,1,1};
    printAllInterpretations(b, 3);

    int c[4] = {2,6};
    printAllInterpretations(c, 2);

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Below is my solution using only recursion.</p>
<p>/*<br />
 * patterns.cpp<br />
 *<br />
 *  Created on: Feb 16, 2014<br />
 *      Author: naveen1.b<br />
 */<br />
#include<br />
#include<br />
#include<br />
#include<br />
#include</p>
<p>using namespace std;</p>
<p>static string alphabets[] = { &#8221; &#8220;,<br />
&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;, &#8220;d&#8221;, &#8220;e&#8221;,  &#8220;f&#8221;, &#8220;g&#8221;, &#8220;h&#8221;, &#8220;i&#8221;,<br />
&#8220;j&#8221;, &#8220;k&#8221;, &#8220;l&#8221;, &#8220;m&#8221;, &#8220;n&#8221;, &#8220;o&#8221;, &#8220;p&#8221;, &#8220;q&#8221;, &#8220;r&#8221;,<br />
&#8220;s&#8221;, &#8220;t&#8221;, &#8220;u&#8221;, &#8220;v&#8221;, &#8220;w&#8221;, &#8220;x&#8221;, &#8220;y&#8221;, &#8220;z&#8221;<br />
};</p>
<p>list printAllInterpretationsUtil(int* a, int start, int size) {<br />
    int noOfElementsToProcess = size &#8211; start;<br />
    list combinations;<br />
    if (noOfElementsToProcess == 1) {<br />
        int elem = a[start];<br />
        if (elem &lt;= 26) {<br />
            string str = alphabets[elem];<br />
            //cout &lt;&lt; &quot;Pushing &quot; &lt;&lt; str &lt;&lt; &quot;n&quot;;<br />
            //cout &lt;&lt; &quot;===========================&quot; &lt; 1) {<br />
        // Recursive call to same function.<br />
        int elem = a[start];<br />
        list results = printAllInterpretationsUtil(a, start + 1, size);<br />
        list::iterator it;<br />
        // Perform permuations in a for loop.<br />
        for (it = results.begin(); it != results.end(); ++it) {<br />
            string result = *it;<br />
            // simple append and push<br />
            string pattern;<br />
            pattern  = alphabets[elem];<br />
            //cout &lt;&lt; &quot;Pushing &quot; &lt;&lt; pattern+result &lt;&lt; &quot;n&quot;;<br />
            combinations.push_back(pattern + result);</p>
<p>            // mix and check . for eg 1 and 1 as 11 etc<br />
            int suffix = (result[0] &#8211; &#039;a&#039;) + 1;<br />
            if (suffix &lt; 10) {<br />
                int patternInt = (elem * 10) + suffix;<br />
                if (patternInt  1) {<br />
                        //cout &lt;&lt; &quot;Pushing &quot; &lt;&lt; pattern + result.substr(1, result.length() &#8211; 1) &lt;&lt; &quot;n&quot;;<br />
                        combinations.push_back(pattern + result.substr(1, result.length() &#8211; 1));<br />
                    } else {<br />
                        //cout &lt;&lt; &quot;Pushing &quot; &lt;&lt; pattern &lt;&lt; &quot;n&quot;;<br />
                        combinations.push_back(pattern);<br />
                    }<br />
                }<br />
            }<br />
            // cout &lt;&lt; &quot;===========================&quot; &lt;&lt; &quot;n&quot;;<br />
        }<br />
    }<br />
    return combinations;<br />
}</p>
<p>void printAllInterpretations(int* a, int size) {<br />
    if (NULL == a)<br />
        return;</p>
<p>    list result = printAllInterpretationsUtil(a, 0, size);<br />
    list::iterator it;<br />
    for (it = result.begin(); it != result.end(); ++it) {<br />
        cout &lt;&lt; *it &lt;&lt; &quot;,&quot;;<br />
    }<br />
    cout &lt;&lt; &quot;n&quot;;<br />
}</p>
<p>int main() {<br />
    int a[] = {1,1,3,4};<br />
    printAllInterpretations(a, 4);</p>
<p>    int b[4] = {1,1,1};<br />
    printAllInterpretations(b, 3);</p>
<p>    int c[4] = {2,6};<br />
    printAllInterpretations(c, 2);</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Shivam</title>
		<link>http://www.geeksforgeeks.org/find-all-possible-interpretations/#comment-29597</link>
		<dc:creator><![CDATA[Shivam]]></dc:creator>
		<pubDate>Wed, 06 Nov 2013 08:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=118567#comment-29597</guid>
		<description><![CDATA[No need to make tree. 




void dfs(int a[],int i,int prev,int n,string s)

{

    if(i==n)

       {

           s=s+char(prev+&#039;a&#039;-1);

           cout&#060;&#060;s&#060;&#060;endl;

           return;

       }

    dfs(a,i+1,a[i],n,s+char(prev+&#039;a&#039;-1));

    if(prev*10+a[i]&#062;t;

while(t--)

{

int n;

cin&#062;&#062;n;

int a[n];

for(int i=0;i&#062;a[i];

dfs(a,1,a[0],n,&quot;&quot;);

}

return 0;

}]]></description>
		<content:encoded><![CDATA[<p>No need to make tree. </p>
<p>void dfs(int a[],int i,int prev,int n,string s)</p>
<p>{</p>
<p>    if(i==n)</p>
<p>       {</p>
<p>           s=s+char(prev+&#8217;a&#8217;-1);</p>
<p>           cout&lt;&lt;s&lt;&lt;endl;</p>
<p>           return;</p>
<p>       }</p>
<p>    dfs(a,i+1,a[i],n,s+char(prev+&#039;a&#039;-1));</p>
<p>    if(prev*10+a[i]&gt;t;</p>
<p>while(t&#8211;)</p>
<p>{</p>
<p>int n;</p>
<p>cin&gt;&gt;n;</p>
<p>int a[n];</p>
<p>for(int i=0;i&gt;a[i];</p>
<p>dfs(a,1,a[0],n,&#8221;&#8221;);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.053 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:20:29 -->

<!-- Compression = gzip -->