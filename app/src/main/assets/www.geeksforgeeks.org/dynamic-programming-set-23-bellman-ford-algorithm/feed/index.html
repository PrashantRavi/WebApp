<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 23 (Bellmanâ€“Ford Algorithm)</title>
	<atom:link href="http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-38373</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 03:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-38373</guid>
		<description><![CDATA[Try to apply Dijkstras on the graph and see the result.

http://i.stack.imgur.com/xp1H4.png]]></description>
		<content:encoded><![CDATA[<p>Try to apply Dijkstras on the graph and see the result.</p>
<p><a href="http://i.stack.imgur.com/xp1H4.png" rel="nofollow">http://i.stack.imgur.com/xp1H4.png</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-38367</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 02:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-38367</guid>
		<description><![CDATA[we already reached &#039;u&#039;, It means we already computed distance of &#039;u&#039;]]></description>
		<content:encoded><![CDATA[<p>we already reached &#8216;u&#8217;, It means we already computed distance of &#8216;u&#8217;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sidharth</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-38366</link>
		<dc:creator><![CDATA[Sidharth]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 02:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-38366</guid>
		<description><![CDATA[Do u know the compexity of this solution ?]]></description>
		<content:encoded><![CDATA[<p>Do u know the compexity of this solution ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: arjomanD</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-37753</link>
		<dc:creator><![CDATA[arjomanD]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 14:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-37753</guid>
		<description><![CDATA[wait,why just update v&#039;s distance ? why don&#039;t check u&#039;s distance too ? (for both endpoints of edge i mean)]]></description>
		<content:encoded><![CDATA[<p>wait,why just update v&#8217;s distance ? why don&#8217;t check u&#8217;s distance too ? (for both endpoints of edge i mean)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hero</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-37466</link>
		<dc:creator><![CDATA[Hero]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 01:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-37466</guid>
		<description><![CDATA[Yes?that might be a overflow problem, but still your way doesn&#039;t overcome overflow problem. We should do like this:

//handle overflow

				if (dist[i] != INT_MAX &#038;&#038; dist[i] + w &#060; dist[j])

				{

					dist[j] = dist[i] + w;

				}]]></description>
		<content:encoded><![CDATA[<p>Yes?that might be a overflow problem, but still your way doesn&#8217;t overcome overflow problem. We should do like this:</p>
<p>//handle overflow</p>
<p>				if (dist[i] != INT_MAX &amp;&amp; dist[i] + w &lt; dist[j])</p>
<p>				{</p>
<p>					dist[j] = dist[i] + w;</p>
<p>				}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-35870</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Sat, 10 May 2014 12:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-35870</guid>
		<description><![CDATA[u can also implement it with queue
http://ideone.com/3BRwwB
for cycle with negative weight sum it will run into infinte loop because each tym a new path is possible...so if a vertex is inserted more than n times in the queue u can say graph has a negative weight cycle]]></description>
		<content:encoded><![CDATA[<p>u can also implement it with queue<br />
<a href="http://ideone.com/3BRwwB" rel="nofollow">http://ideone.com/3BRwwB</a><br />
for cycle with negative weight sum it will run into infinte loop because each tym a new path is possible&#8230;so if a vertex is inserted more than n times in the queue u can say graph has a negative weight cycle</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lohith Ravi</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-34953</link>
		<dc:creator><![CDATA[Lohith Ravi]]></dc:creator>
		<pubDate>Mon, 21 Apr 2014 12:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-34953</guid>
		<description><![CDATA[Can some one tell me why Dijikstras do not work for negatives.  I just applied dijikstras on this and got the same output.]]></description>
		<content:encoded><![CDATA[<p>Can some one tell me why Dijikstras do not work for negatives.  I just applied dijikstras on this and got the same output.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lohith Ravi</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-34954</link>
		<dc:creator><![CDATA[Lohith Ravi]]></dc:creator>
		<pubDate>Mon, 21 Apr 2014 12:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-34954</guid>
		<description><![CDATA[Can some one tell me why Dijikstras do not work for negatives.  I just applied dijikstras on this and got the same output.]]></description>
		<content:encoded><![CDATA[<p>Can some one tell me why Dijikstras do not work for negatives.  I just applied dijikstras on this and got the same output.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tokes</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-30384</link>
		<dc:creator><![CDATA[tokes]]></dc:creator>
		<pubDate>Tue, 03 Dec 2013 23:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-30384</guid>
		<description><![CDATA[There is a problem where if you change the source node to something different from &quot;a&quot; which is &quot;0&quot; you will get wrong answers.]]></description>
		<content:encoded><![CDATA[<p>There is a problem where if you change the source node to something different from &#8220;a&#8221; which is &#8220;0&#8221; you will get wrong answers.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: viki</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-28927</link>
		<dc:creator><![CDATA[viki]]></dc:creator>
		<pubDate>Tue, 15 Oct 2013 19:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-28927</guid>
		<description><![CDATA[Hi Sir,

Replace the code &quot;dist[u] + weight &#060; dist[v]&#034; 
by &#034;dist[u]  &#060; dist[v] - weight&#034; to overcome integer overflow.

BTW excellent post.]]></description>
		<content:encoded><![CDATA[<p>Hi Sir,</p>
<p>Replace the code &#8220;dist[u] + weight &lt; dist[v]&quot;<br />
by &quot;dist[u]  &lt; dist[v] &#8211; weight&quot; to overcome integer overflow.</p>
<p>BTW excellent post.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Krishna Prasad</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/#comment-28178</link>
		<dc:creator><![CDATA[Krishna Prasad]]></dc:creator>
		<pubDate>Fri, 27 Sep 2013 15:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27914#comment-28178</guid>
		<description><![CDATA[For step 2:
what if i use....

int flag=1;
while(flag)
    {
flag=0;
        for (int j = 0; j edge[j].src;
            int v = graph-&#062;edge[j].dest;
            int weight = graph-&#062;edge[j].weight;
            if (dist[u] + weight &#060; dist[v])
                   { dist[v] = dist[u] + weight;
                        flag=1;
}
        }
    }

instead of.....

for (int i = 1; i &#060;= V-1; i++)
    {
        for (int j = 0; j edge[j].src;
            int v = graph-&#062;edge[j].dest;
            int weight = graph-&#062;edge[j].weight;
            if (dist[u] + weight &#060; dist[v])
                dist[v] = dist[u] + weight;
        }
    }
.....
It may improve performance breaking out unnecessary iterations
am i right?????
and what is the need of step3 ?.... i dint understand it......]]></description>
		<content:encoded><![CDATA[<p>For step 2:<br />
what if i use&#8230;.</p>
<p>int flag=1;<br />
while(flag)<br />
    {<br />
flag=0;<br />
        for (int j = 0; j edge[j].src;<br />
            int v = graph-&gt;edge[j].dest;<br />
            int weight = graph-&gt;edge[j].weight;<br />
            if (dist[u] + weight &lt; dist[v])<br />
                   { dist[v] = dist[u] + weight;<br />
                        flag=1;<br />
}<br />
        }<br />
    }</p>
<p>instead of&#8230;..</p>
<p>for (int i = 1; i &lt;= V-1; i++)<br />
    {<br />
        for (int j = 0; j edge[j].src;<br />
            int v = graph-&gt;edge[j].dest;<br />
            int weight = graph-&gt;edge[j].weight;<br />
            if (dist[u] + weight &lt; dist[v])<br />
                dist[v] = dist[u] + weight;<br />
        }<br />
    }<br />
&#8230;..<br />
It may improve performance breaking out unnecessary iterations<br />
am i right?????<br />
and what is the need of step3 ?&#8230;. i dint understand it&#8230;&#8230;</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:41 -->

<!-- Compression = gzip -->