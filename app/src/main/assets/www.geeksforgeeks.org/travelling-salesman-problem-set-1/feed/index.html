<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Travelling Salesman Problem &#124; Set 1 (Naive and Dynamic Programming)</title>
	<atom:link href="http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: j</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-39415</link>
		<dc:creator><![CDATA[j]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 07:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-39415</guid>
		<description><![CDATA[How to track the path and get the shortest path?]]></description>
		<content:encoded><![CDATA[<p>How to track the path and get the shortest path?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rohan</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-34786</link>
		<dc:creator><![CDATA[rohan]]></dc:creator>
		<pubDate>Thu, 17 Apr 2014 17:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-34786</guid>
		<description><![CDATA[http://ideone.com/tYdrK8

It is well commented and contains the recursion tree for an example input graph :) enjoy 

Using the DP equation-

g(i,S)= min(Cij + g( j, S-{ j }) where j belongs to S.

where g(i,S) is length of a shortest path starting at vertex i, going through all vertices in S and terminating at vertex 1.]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/tYdrK8" rel="nofollow">http://ideone.com/tYdrK8</a></p>
<p>It is well commented and contains the recursion tree for an example input graph ðŸ™‚ enjoy </p>
<p>Using the DP equation-</p>
<p>g(i,S)= min(Cij + g( j, S-{ j }) where j belongs to S.</p>
<p>where g(i,S) is length of a shortest path starting at vertex i, going through all vertices in S and terminating at vertex 1.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: NB</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-34535</link>
		<dc:creator><![CDATA[NB]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 21:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-34535</guid>
		<description><![CDATA[Why is the Time Complexity: big omega (n!)  ? This should be an upper bound, not lower bound right]]></description>
		<content:encoded><![CDATA[<p>Why is the Time Complexity: big omega (n!)  ? This should be an upper bound, not lower bound right</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: john</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-33751</link>
		<dc:creator><![CDATA[john]]></dc:creator>
		<pubDate>Sat, 22 Mar 2014 20:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-33751</guid>
		<description><![CDATA[and that dp-derived path (preferably, as it pertains to the top-down sol&#039;n)?]]></description>
		<content:encoded><![CDATA[<p>and that dp-derived path (preferably, as it pertains to the top-down sol&#8217;n)?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Bharathkumar Hegde</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-32820</link>
		<dc:creator><![CDATA[Bharathkumar Hegde]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 20:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-32820</guid>
		<description><![CDATA[I think if subset is greater than two, then

loop for each j in S-{i}:
  required = min ( required , C (S-{i}, j) + dist ( i , j ) );

now &#039;required&#039; has minimum cost of travelling through S - { i } considering some city &#039; j &#039; in S - { i } is last node plus the dist from &#039; j &#039; (possible last city )  to i.]]></description>
		<content:encoded><![CDATA[<p>I think if subset is greater than two, then</p>
<p>loop for each j in S-{i}:<br />
  required = min ( required , C (S-{i}, j) + dist ( i , j ) );</p>
<p>now &#8216;required&#8217; has minimum cost of travelling through S &#8211; { i } considering some city &#8216; j &#8216; in S &#8211; { i } is last node plus the dist from &#8216; j &#8216; (possible last city )  to i.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lohith Ravi</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-32702</link>
		<dc:creator><![CDATA[Lohith Ravi]]></dc:creator>
		<pubDate>Tue, 18 Feb 2014 16:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-32702</guid>
		<description><![CDATA[Hi Moderators, 
I really like geeks for geeks for the service it renders by spreading so much of knowledge. 
I also want you guys to make a point some where that, Dynamic programming is just a method where we cache the result so that it need not be computer once more and a HashMap could be of great help as a simple cache.


// for the above problem, I have a DP code writtern in Java, I wish you use it in the above post so that it helps people

import java.util.ArrayList;

import java.util.HashMap;

public class TravelingSalesManProblem {

	public static HashMap DynamicProgrammingCache = new HashMap();

	

	public static void main(String[] args) {

		int source = 0;

		int matrix[][] = { { 0, 10, 15, 20 }, { 10, 0, 35, 25 },

				{ 15, 35, 0, 30 }, { 20, 25, 30, 0 } };

		ArrayList visitedNodes = new ArrayList();

		visitedNodes.add(source);

		int minDistance = findMinimumDistance(matrix, source, visitedNodes);

		System.out.println(minDistance);

	}

	private static int findMinimumDistance(int[][] matrix, int source, ArrayList visitedNodes) {

		

		

		if(DynamicProgrammingCache.containsKey(visitedNodes+&quot;,(&quot;+source+&quot;)&quot;))

		{

			return DynamicProgrammingCache.get(visitedNodes+&quot;,(&quot;+source+&quot;)&quot;);

		}

		

		if(visitedNodes.size() == 4){

			int temp = matrix[visitedNodes.get(visitedNodes.size()-1)][visitedNodes.get(0)];

			if(temp !=0)

			   return temp;

			else

				return -1;

		}

		int min = -1;

		for (int i = 0; i &#060; matrix.length; i++) {

			if (matrix[source][/source][i] != 0 &#038;&#038; notInVisitedNodes(visitedNodes, i)) {

				ArrayList tempVisitedNodes = copyOf(visitedNodes);

				tempVisitedNodes.add(i);

				int val = findMinimumDistance(matrix, i, tempVisitedNodes) ;

				if (val != -1) {

					val = val + matrix[source][/source][i];

					if (min == -1) {

						min = val ;

					} else {

						if (min &#062; val) {

							min = val;

						}

					}

				}

			}

		}

		

		DynamicProgrammingCache.put(visitedNodes+&quot;,(&quot;+source+&quot;)&quot;, min);

		return min;

	}

	private static ArrayList copyOf(ArrayList visitedNodes) {

		return new ArrayList(visitedNodes);

	}

	private static boolean notInVisitedNodes(ArrayList visitedNodes, int i) {

		return !visitedNodes.contains(i);

	}

}]]></description>
		<content:encoded><![CDATA[<p>Hi Moderators,<br />
I really like geeks for geeks for the service it renders by spreading so much of knowledge.<br />
I also want you guys to make a point some where that, Dynamic programming is just a method where we cache the result so that it need not be computer once more and a HashMap could be of great help as a simple cache.</p>
<p>// for the above problem, I have a DP code writtern in Java, I wish you use it in the above post so that it helps people</p>
<p>import java.util.ArrayList;</p>
<p>import java.util.HashMap;</p>
<p>public class TravelingSalesManProblem {</p>
<p>	public static HashMap DynamicProgrammingCache = new HashMap();</p>
<p>	public static void main(String[] args) {</p>
<p>		int source = 0;</p>
<p>		int matrix[][] = { { 0, 10, 15, 20 }, { 10, 0, 35, 25 },</p>
<p>				{ 15, 35, 0, 30 }, { 20, 25, 30, 0 } };</p>
<p>		ArrayList visitedNodes = new ArrayList();</p>
<p>		visitedNodes.add(source);</p>
<p>		int minDistance = findMinimumDistance(matrix, source, visitedNodes);</p>
<p>		System.out.println(minDistance);</p>
<p>	}</p>
<p>	private static int findMinimumDistance(int[][] matrix, int source, ArrayList visitedNodes) {</p>
<p>		if(DynamicProgrammingCache.containsKey(visitedNodes+&#8221;,(&#8220;+source+&#8221;)&#8221;))</p>
<p>		{</p>
<p>			return DynamicProgrammingCache.get(visitedNodes+&#8221;,(&#8220;+source+&#8221;)&#8221;);</p>
<p>		}</p>
<p>		if(visitedNodes.size() == 4){</p>
<p>			int temp = matrix[visitedNodes.get(visitedNodes.size()-1)][visitedNodes.get(0)];</p>
<p>			if(temp !=0)</p>
<p>			   return temp;</p>
<p>			else</p>
<p>				return -1;</p>
<p>		}</p>
<p>		int min = -1;</p>
<p>		for (int i = 0; i &lt; matrix.length; i++) {</p>
<p>			if (matrix[i] != 0 &amp;&amp; notInVisitedNodes(visitedNodes, i)) {</p>
<p>				ArrayList tempVisitedNodes = copyOf(visitedNodes);</p>
<p>				tempVisitedNodes.add(i);</p>
<p>				int val = findMinimumDistance(matrix, i, tempVisitedNodes) ;</p>
<p>				if (val != -1) {</p>
<p>					val = val + matrix[i];</p>
<p>					if (min == -1) {</p>
<p>						min = val ;</p>
<p>					} else {</p>
<p>						if (min &gt; val) {</p>
<p>							min = val;</p>
<p>						}</p>
<p>					}</p>
<p>				}</p>
<p>			}</p>
<p>		}</p>
<p>		DynamicProgrammingCache.put(visitedNodes+&#8221;,(&#8220;+source+&#8221;)&#8221;, min);</p>
<p>		return min;</p>
<p>	}</p>
<p>	private static ArrayList copyOf(ArrayList visitedNodes) {</p>
<p>		return new ArrayList(visitedNodes);</p>
<p>	}</p>
<p>	private static boolean notInVisitedNodes(ArrayList visitedNodes, int i) {</p>
<p>		return !visitedNodes.contains(i);</p>
<p>	}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-32664</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 17 Feb 2014 18:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-32664</guid>
		<description><![CDATA[import java.util.ArrayList;

public class TravelingSalesManProblem {

	public static void main(String[] args) {

		int source = 0;

		int matrix[][] = { { 0, 10, 15, 20 }, { 10, 0, 35, 25 },

				{ 15, 35, 0, 30 }, { 20, 25, 30, 0 } };

		ArrayList visitedNodes = new ArrayList();

		visitedNodes.add(source);

		int minDistance = findMinimumDistance(matrix, source, visitedNodes);

		System.out.println(minDistance);

	}

	private static int findMinimumDistance(int[][] matrix, int source, ArrayList visitedNodes) {

		int min = -1;

		for (int i = 0; i &#060; matrix.length; i++) {

			ArrayList visitedNodes = copyOf(visitedNodes);

			visitedNodes.add(i);

			if (i != source &#038;&#038; matrix[source][/source][i] != 0 &#038;&#038; notInVisitedNodes(visitedNodes)) {

				int val = findMinimumDistance(matrix, i, visitedNodes) ;

				if (val != -1) {

					if (min == -1) {

						min = val + matrix[source][/source][i];

					} else {

						if (min &#062; val + matrix[source][/source][i]) {

							min = val + matrix[source][/source][i];

						}

					}

				}

			}

		}

		return min;

	}

}]]></description>
		<content:encoded><![CDATA[<p>import java.util.ArrayList;</p>
<p>public class TravelingSalesManProblem {</p>
<p>	public static void main(String[] args) {</p>
<p>		int source = 0;</p>
<p>		int matrix[][] = { { 0, 10, 15, 20 }, { 10, 0, 35, 25 },</p>
<p>				{ 15, 35, 0, 30 }, { 20, 25, 30, 0 } };</p>
<p>		ArrayList visitedNodes = new ArrayList();</p>
<p>		visitedNodes.add(source);</p>
<p>		int minDistance = findMinimumDistance(matrix, source, visitedNodes);</p>
<p>		System.out.println(minDistance);</p>
<p>	}</p>
<p>	private static int findMinimumDistance(int[][] matrix, int source, ArrayList visitedNodes) {</p>
<p>		int min = -1;</p>
<p>		for (int i = 0; i &lt; matrix.length; i++) {</p>
<p>			ArrayList visitedNodes = copyOf(visitedNodes);</p>
<p>			visitedNodes.add(i);</p>
<p>			if (i != source &amp;&amp; matrix[i] != 0 &amp;&amp; notInVisitedNodes(visitedNodes)) {</p>
<p>				int val = findMinimumDistance(matrix, i, visitedNodes) ;</p>
<p>				if (val != -1) {</p>
<p>					if (min == -1) {</p>
<p>						min = val + matrix[i];</p>
<p>					} else {</p>
<p>						if (min &gt; val + matrix[i]) {</p>
<p>							min = val + matrix[i];</p>
<p>						}</p>
<p>					}</p>
<p>				}</p>
<p>			}</p>
<p>		}</p>
<p>		return min;</p>
<p>	}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: mysticPrince</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-31754</link>
		<dc:creator><![CDATA[mysticPrince]]></dc:creator>
		<pubDate>Thu, 23 Jan 2014 10:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-31754</guid>
		<description><![CDATA[C(S, i) = min { C(S-{i}, j) + dis(j, i)} where j belongs to S, j != i and j != 1
This one I suppose.
As the author has stated:
C(S, i) be the cost of the minimum cost path visiting each vertex in set S exactly once, starting at 1 and ending at i.



For each subset size&#062;2,
C(S,i) is given as minimum of all path lengths visiting every vertex in subset S exactly once, starting at 1, ending at i (i belongs to S) , with j as intermediate vertex, for all j in S (j!=i, j!=1), for all i in S (i!=1).
So the expressions is of form: C(S-{i}, j) +dist (j,i)
I hope it helps :)]]></description>
		<content:encoded><![CDATA[<p>C(S, i) = min { C(S-{i}, j) + dis(j, i)} where j belongs to S, j != i and j != 1<br />
This one I suppose.<br />
As the author has stated:<br />
C(S, i) be the cost of the minimum cost path visiting each vertex in set S exactly once, starting at 1 and ending at i.</p>
<p>For each subset size&gt;2,<br />
C(S,i) is given as minimum of all path lengths visiting every vertex in subset S exactly once, starting at 1, ending at i (i belongs to S) , with j as intermediate vertex, for all j in S (j!=i, j!=1), for all i in S (i!=1).<br />
So the expressions is of form: C(S-{i}, j) +dist (j,i)<br />
I hope it helps ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: mysticPrince</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-31753</link>
		<dc:creator><![CDATA[mysticPrince]]></dc:creator>
		<pubDate>Thu, 23 Jan 2014 10:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-31753</guid>
		<description><![CDATA[Look at this recurrence:

C(S, i) = min { C(S-{i}, j) + dis(j, i)}
Doesn&#039;t it look similar to relaxation property in Bellman ford&#039;s?

Why not the same complexity then?

1. Cause there are two constraints in particular: 
  a)Each vertex must be visited, and only once (except 1 where tour    starts and ends)

  b) For nth vertex, in tour (from 1st), we are looking for a n-length path      subject to above two constraints.

2. Cause it NP Complete problem :p  incorporating above two constraints

Well, I&#039;m not the author of the article. But maybe it helps. :)]]></description>
		<content:encoded><![CDATA[<p>Look at this recurrence:</p>
<p>C(S, i) = min { C(S-{i}, j) + dis(j, i)}<br />
Doesn&#8217;t it look similar to relaxation property in Bellman ford&#8217;s?</p>
<p>Why not the same complexity then?</p>
<p>1. Cause there are two constraints in particular:<br />
  a)Each vertex must be visited, and only once (except 1 where tour    starts and ends)</p>
<p>  b) For nth vertex, in tour (from 1st), we are looking for a n-length path      subject to above two constraints.</p>
<p>2. Cause it NP Complete problem :p  incorporating above two constraints</p>
<p>Well, I&#8217;m not the author of the article. But maybe it helps. ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sriharsha g.r.v</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-30274</link>
		<dc:creator><![CDATA[Sriharsha g.r.v]]></dc:creator>
		<pubDate>Sat, 30 Nov 2013 21:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-30274</guid>
		<description><![CDATA[hello  sir, i am naive to this concept, but i would like to know if disktras or bellmann algo could be applied to very vertex one after th other and discard that vertex from graph..in that way dont we get the shortest tour possible?]]></description>
		<content:encoded><![CDATA[<p>hello  sir, i am naive to this concept, but i would like to know if disktras or bellmann algo could be applied to very vertex one after th other and discard that vertex from graph..in that way dont we get the shortest tour possible?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kaushik Srinivasan</title>
		<link>http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/#comment-29947</link>
		<dc:creator><![CDATA[Kaushik Srinivasan]]></dc:creator>
		<pubDate>Mon, 18 Nov 2013 10:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123690#comment-29947</guid>
		<description><![CDATA[Can someone please explain the 2nd recurrence relation?]]></description>
		<content:encoded><![CDATA[<p>Can someone please explain the 2nd recurrence relation?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:19:05 -->

<!-- Compression = gzip -->