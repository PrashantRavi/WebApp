<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Greedy Algorithms &#124; Set 2 (Kruskalâ€™s Minimum Spanning Tree Algorithm)</title>
	<atom:link href="http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: SIDDHARTHA SARKAR</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-38290</link>
		<dc:creator><![CDATA[SIDDHARTHA SARKAR]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 08:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-38290</guid>
		<description><![CDATA[The value of E can be at most V*(V-1), not V*V in an undirected graph.]]></description>
		<content:encoded><![CDATA[<p>The value of E can be at most V*(V-1), not V*V in an undirected graph.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-38288</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 08:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-38288</guid>
		<description><![CDATA[The value of V can be at most V(V-1) for undirected graphs.
Not V*V.]]></description>
		<content:encoded><![CDATA[<p>The value of V can be at most V(V-1) for undirected graphs.<br />
Not V*V.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Alex T</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-38013</link>
		<dc:creator><![CDATA[Alex T]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 16:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-38013</guid>
		<description><![CDATA[myComp function should return three different values - 0, 1, -1, so the std::qsort function determines the place of each element. Therefore, the corrected myComp function is presented here:


int myComp(const void* a, const void* b)
{
Edge* a1 = (Edge*)a;
Edge* b1 = (Edge*)b;
if (a1-&#062;weight  &#062; b1-&#062;weight)  return  1;
if (a1-&#062;weight == b1-&#062;weight)  return  0;
if (a1-&#062;weight  weight)  return -1;
}



Thanks for attention.]]></description>
		<content:encoded><![CDATA[<p>myComp function should return three different values &#8211; 0, 1, -1, so the std::qsort function determines the place of each element. Therefore, the corrected myComp function is presented here:</p>
<p>int myComp(const void* a, const void* b)<br />
{<br />
Edge* a1 = (Edge*)a;<br />
Edge* b1 = (Edge*)b;<br />
if (a1-&gt;weight  &gt; b1-&gt;weight)  return  1;<br />
if (a1-&gt;weight == b1-&gt;weight)  return  0;<br />
if (a1-&gt;weight  weight)  return -1;<br />
}</p>
<p>Thanks for attention.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-35149</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 10:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-35149</guid>
		<description><![CDATA[My Java implementation  of Kruskal algo is as follows.
1) I am using map to keep track of already covered nodes.
2) Edge class implements Comparable so that edges can be sorted.
3) Program asks for weight for distance between every pair of node(as non-directional; so every pair is asked just once)
4) User input zero indicates that no such link exist
http://ideone.com/IdwASw

------- input output console -------------------

Enter the number of vertices
4
Enter distance between node 1 and 2
6
Enter distance between node 1 and 3
8
Enter distance between node 1 and 4
6
Enter distance between node 2 and 3
0
Enter distance between node 2 and 4
5
Enter distance between node 3 and 4
7

The spanning tree is 
Between node 2 &#038; node 4 weight 5
Between node 1 &#038; node 2 weight 6
Between node 3 &#038; node 4 weight 7]]></description>
		<content:encoded><![CDATA[<p>My Java implementation  of Kruskal algo is as follows.<br />
1) I am using map to keep track of already covered nodes.<br />
2) Edge class implements Comparable so that edges can be sorted.<br />
3) Program asks for weight for distance between every pair of node(as non-directional; so every pair is asked just once)<br />
4) User input zero indicates that no such link exist<br />
<a href="http://ideone.com/IdwASw" rel="nofollow">http://ideone.com/IdwASw</a></p>
<p>&#8212;&#8212;- input output console &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
<p>Enter the number of vertices<br />
4<br />
Enter distance between node 1 and 2<br />
6<br />
Enter distance between node 1 and 3<br />
8<br />
Enter distance between node 1 and 4<br />
6<br />
Enter distance between node 2 and 3<br />
0<br />
Enter distance between node 2 and 4<br />
5<br />
Enter distance between node 3 and 4<br />
7</p>
<p>The spanning tree is<br />
Between node 2 &amp; node 4 weight 5<br />
Between node 1 &amp; node 2 weight 6<br />
Between node 3 &amp; node 4 weight 7</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-35145</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 09:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-35145</guid>
		<description><![CDATA[/* How to add code here directly without using ideone.com


*/]]></description>
		<content:encoded><![CDATA[<p>/* How to add code here directly without using ideone.com</p>
<p>*/</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-32626</link>
		<dc:creator><![CDATA[Rahul]]></dc:creator>
		<pubDate>Mon, 17 Feb 2014 02:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-32626</guid>
		<description><![CDATA[I have a doubt, how will while loop will break, if there is a cycle in the graph ? as we are taking break condition as e &#060; V-1 and e only increments when there is no cycle till now.]]></description>
		<content:encoded><![CDATA[<p>I have a doubt, how will while loop will break, if there is a cycle in the graph ? as we are taking break condition as e &lt; V-1 and e only increments when there is no cycle till now.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anitesh Kumar</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-30849</link>
		<dc:creator><![CDATA[Anitesh Kumar]]></dc:creator>
		<pubDate>Thu, 19 Dec 2013 05:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-30849</guid>
		<description><![CDATA[Please correct me if i am wrong. The compare function used for ::qsort(), mycomp() should be static. 
I am coding with VC++ and using VS2008 IDE. If i do not make mycomp() function static i am getting following CT error:
&quot;function call missing argument list; use &#039;&#038;Graph::mycomp&#039; to create a pointer to member&quot;.
Please reply.]]></description>
		<content:encoded><![CDATA[<p>Please correct me if i am wrong. The compare function used for ::qsort(), mycomp() should be static.<br />
I am coding with VC++ and using VS2008 IDE. If i do not make mycomp() function static i am getting following CT error:<br />
&#8220;function call missing argument list; use &#8216;&amp;Graph::mycomp&#8217; to create a pointer to member&#8221;.<br />
Please reply.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-30146</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Tue, 26 Nov 2013 12:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-30146</guid>
		<description><![CDATA[
package kruskalunionfind;

class Edge
{
    int src,dest,weight;
}

class Graph
{
     // V-&#062; Number of vertices, E-&#062; Number of edges
    int V, E;
    
    // graph is represented as an array of edges. Since the graph is
    // undirected, the edge from src to dest is also edge from dest
    // to src. Both are counted as 1 edge here.
    Edge edge[]=null;
    
    public void createGraph(int v,int e)
    {
        Graph g=new Graph();
        V=v;
        E=e;
        edge=new Edge[e];        
        
        for(int i=0;i&#060;e;i++)
            edge[i]=new Edge();
    }
}

// structure to represent a subset for union-find
class subset
{
    int parent;
    int rank;    
    
    // A utility function to find set of an element i
// (uses path compression technique)
    int find(subset subsets[],int i)
    {
        // find root and make root as parent of i (path compression)
        if (subsets[i].parent != i)
        {
            subsets[i].parent = find(subsets, subsets[i].parent);
        }
        
        return subsets[i].parent;
    }
    
    
    // A function that does union of two sets of x and y
// (uses union by rank)
void Union( subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
 
    // Attach smaller rank tree under root of high rank tree
    // (Union by Rank)
    if (subsets[xroot].rank  subsets[yroot].rank)
        subsets[yroot].parent = xroot;
 
    // If ranks are same, then make one as root and increment
    // its rank by one
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}
}

public class KruskalUnionFind {

    static void srtEdge(Edge[] e)
    {
        int min=-1;
     for(int i=0;i&#060;e.length-1;i++)   
     {
         int p=e[i].weight;
         
         for(int j=i;je[j].weight)
                 min=j;                 
             
         }
          // swap two edge objects
                 Edge temp;
                 temp=e[i];
                 e[i]=e[min];
                 e[min]=temp;
     }
        
    }
    // The main function to construct MST using Kruskal&#039;s algorithm
 static void KruskalMST(Graph g)
 {
     int V=g.V;
     Edge result[]=new Edge[V];  // This will store resultant MST
     
      int e = 0;  // An index variable, used for result[]
    int i = 0;  // An index variable, used for sorted edges
 
   
    System.out.println(&quot;Before sorting:&quot;);
    for(int j=0;j&#060;g.E;j++)
        System.out.print(g.edge[j].weight+&#034;  &#034;);
    
     System.out.println();   
   
     
     srtEdge(g.edge);   
    
     System.out.println(&#034;After sorting:&#034;);
      for(int j=0;j&#060;g.E;j++)
        System.out.print(g.edge[j].weight+&#034;  &#034;);
    
     System.out.println();
     
     
    
    subset s[]=new subset[V];
      // Create V subsets with single elements
    for (int v = 0; v &#060; V; ++v)
    {
        s[v]=new subset();
        
        s[v].parent = v;
        s[v].rank = 0;
    }
 
    subset ob=new subset();
    // Number of edges to be taken is equal to V-1
    while(e&#060;V-1)    
    {        
           Edge next_edge=g.edge[i++];
           int x=ob.find(s,next_edge.src);
           int y=ob.find(s,next_edge.dest);
           
           // If including this edge does&#039;t cause cycle, include it
        // in result and increment the index of result for next edge
        if (x != y)
        {
            result[e++] = next_edge;
            ob.Union(s, x, y);            
        }
        // Else discard the next_edge
    }
    
      // print the contents of result[] to display the built MST
    System.out.println(&#034;Following are the edges in the constructed MST&#034;);
    
    for(i=0;i&#060;e;i++)
        System.out.println(result[i].src+&#034;  &#034;+result[i].dest+&#034;  &#034;+result[i].weight);
 
 
 }
    public static void main(String[] args) {
        /* Let us create following weighted graph
             10
        0--------1
        &#124;       &#124;
       6&#124;   5   &#124;15
        &#124;       &#124;
        2--------3
            4       */
    int V = 4;  // Number of vertices in graph
    int E = 5;  // Number of edges in graph
     Graph g= new  Graph();
     g.createGraph(V, E);
     
      // add edge 0-1
    g.edge[0].src = 0;
    g.edge[0].dest = 1;
    g.edge[0].weight = 10;
    
    
     // add edge 0-2
    g.edge[1].src = 0;
    g.edge[1].dest = 2;
    g.edge[1].weight = 6;
 
    // add edge 0-3
    g.edge[2].src = 0;
    g.edge[2].dest = 3;
    g.edge[2].weight = 5;
 
    // add edge 1-3
    g.edge[3].src = 1;
    g.edge[3].dest = 3;
    g.edge[3].weight = 15;
 
    // add edge 2-3
    g.edge[4].src = 2;
    g.edge[4].dest = 3;
    g.edge[4].weight = 4;
    
    KruskalMST(g);
    
    }
}
]]></description>
		<content:encoded><![CDATA[<p>package kruskalunionfind;</p>
<p>class Edge<br />
{<br />
    int src,dest,weight;<br />
}</p>
<p>class Graph<br />
{<br />
     // V-&gt; Number of vertices, E-&gt; Number of edges<br />
    int V, E;</p>
<p>    // graph is represented as an array of edges. Since the graph is<br />
    // undirected, the edge from src to dest is also edge from dest<br />
    // to src. Both are counted as 1 edge here.<br />
    Edge edge[]=null;</p>
<p>    public void createGraph(int v,int e)<br />
    {<br />
        Graph g=new Graph();<br />
        V=v;<br />
        E=e;<br />
        edge=new Edge[e];        </p>
<p>        for(int i=0;i&lt;e;i++)<br />
            edge[i]=new Edge();<br />
    }<br />
}</p>
<p>// structure to represent a subset for union-find<br />
class subset<br />
{<br />
    int parent;<br />
    int rank;    </p>
<p>    // A utility function to find set of an element i<br />
// (uses path compression technique)<br />
    int find(subset subsets[],int i)<br />
    {<br />
        // find root and make root as parent of i (path compression)<br />
        if (subsets[i].parent != i)<br />
        {<br />
            subsets[i].parent = find(subsets, subsets[i].parent);<br />
        }</p>
<p>        return subsets[i].parent;<br />
    }</p>
<p>    // A function that does union of two sets of x and y<br />
// (uses union by rank)<br />
void Union( subset subsets[], int x, int y)<br />
{<br />
    int xroot = find(subsets, x);<br />
    int yroot = find(subsets, y);</p>
<p>    // Attach smaller rank tree under root of high rank tree<br />
    // (Union by Rank)<br />
    if (subsets[xroot].rank  subsets[yroot].rank)<br />
        subsets[yroot].parent = xroot;</p>
<p>    // If ranks are same, then make one as root and increment<br />
    // its rank by one<br />
    else<br />
    {<br />
        subsets[yroot].parent = xroot;<br />
        subsets[xroot].rank++;<br />
    }<br />
}<br />
}</p>
<p>public class KruskalUnionFind {</p>
<p>    static void srtEdge(Edge[] e)<br />
    {<br />
        int min=-1;<br />
     for(int i=0;i&lt;e.length-1;i++)<br />
     {<br />
         int p=e[i].weight;</p>
<p>         for(int j=i;je[j].weight)<br />
                 min=j;                 </p>
<p>         }<br />
          // swap two edge objects<br />
                 Edge temp;<br />
                 temp=e[i];<br />
                 e[i]=e[min];<br />
                 e[min]=temp;<br />
     }</p>
<p>    }<br />
    // The main function to construct MST using Kruskal&#8217;s algorithm<br />
 static void KruskalMST(Graph g)<br />
 {<br />
     int V=g.V;<br />
     Edge result[]=new Edge[V];  // This will store resultant MST</p>
<p>      int e = 0;  // An index variable, used for result[]<br />
    int i = 0;  // An index variable, used for sorted edges</p>
<p>    System.out.println(&#8220;Before sorting:&#8221;);<br />
    for(int j=0;j&lt;g.E;j++)<br />
        System.out.print(g.edge[j].weight+&quot;  &quot;);</p>
<p>     System.out.println();   </p>
<p>     srtEdge(g.edge);   </p>
<p>     System.out.println(&quot;After sorting:&quot;);<br />
      for(int j=0;j&lt;g.E;j++)<br />
        System.out.print(g.edge[j].weight+&quot;  &quot;);</p>
<p>     System.out.println();</p>
<p>    subset s[]=new subset[V];<br />
      // Create V subsets with single elements<br />
    for (int v = 0; v &lt; V; ++v)<br />
    {<br />
        s[v]=new subset();</p>
<p>        s[v].parent = v;<br />
        s[v].rank = 0;<br />
    }</p>
<p>    subset ob=new subset();<br />
    // Number of edges to be taken is equal to V-1<br />
    while(e&lt;V-1)<br />
    {<br />
           Edge next_edge=g.edge[i++];<br />
           int x=ob.find(s,next_edge.src);<br />
           int y=ob.find(s,next_edge.dest);</p>
<p>           // If including this edge does&#039;t cause cycle, include it<br />
        // in result and increment the index of result for next edge<br />
        if (x != y)<br />
        {<br />
            result[e++] = next_edge;<br />
            ob.Union(s, x, y);<br />
        }<br />
        // Else discard the next_edge<br />
    }</p>
<p>      // print the contents of result[] to display the built MST<br />
    System.out.println(&quot;Following are the edges in the constructed MST&quot;);</p>
<p>    for(i=0;i&lt;e;i++)<br />
        System.out.println(result[i].src+&quot;  &quot;+result[i].dest+&quot;  &quot;+result[i].weight);</p>
<p> }<br />
    public static void main(String[] args) {<br />
        /* Let us create following weighted graph<br />
             10<br />
        0&#8212;&#8212;&#8211;1<br />
        |       |<br />
       6|   5   |15<br />
        |       |<br />
        2&#8212;&#8212;&#8211;3<br />
            4       */<br />
    int V = 4;  // Number of vertices in graph<br />
    int E = 5;  // Number of edges in graph<br />
     Graph g= new  Graph();<br />
     g.createGraph(V, E);</p>
<p>      // add edge 0-1<br />
    g.edge[0].src = 0;<br />
    g.edge[0].dest = 1;<br />
    g.edge[0].weight = 10;</p>
<p>     // add edge 0-2<br />
    g.edge[1].src = 0;<br />
    g.edge[1].dest = 2;<br />
    g.edge[1].weight = 6;</p>
<p>    // add edge 0-3<br />
    g.edge[2].src = 0;<br />
    g.edge[2].dest = 3;<br />
    g.edge[2].weight = 5;</p>
<p>    // add edge 1-3<br />
    g.edge[3].src = 1;<br />
    g.edge[3].dest = 3;<br />
    g.edge[3].weight = 15;</p>
<p>    // add edge 2-3<br />
    g.edge[4].src = 2;<br />
    g.edge[4].dest = 3;<br />
    g.edge[4].weight = 4;</p>
<p>    KruskalMST(g);</p>
<p>    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sudshekhar</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-28893</link>
		<dc:creator><![CDATA[sudshekhar]]></dc:creator>
		<pubDate>Tue, 15 Oct 2013 08:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-28893</guid>
		<description><![CDATA[Hi,

Consider the following : 

0 1 3
1 2 5
2 3 4
3 4 6
4 5 7
5 6 8
6 0 9

The first two are the src and dest and third is the weight.
Here, we first add the edge (0,1) and then (2,3). Then we get the edge (1,2) which has had both its vertices&#039;s visited, BUT it doesn&#039;t form a loop. (since the two components are independent till now) and it will be a part of the MST.

This is why we need the union-find algorithm.]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>Consider the following : </p>
<p>0 1 3<br />
1 2 5<br />
2 3 4<br />
3 4 6<br />
4 5 7<br />
5 6 8<br />
6 0 9</p>
<p>The first two are the src and dest and third is the weight.<br />
Here, we first add the edge (0,1) and then (2,3). Then we get the edge (1,2) which has had both its vertices&#8217;s visited, BUT it doesn&#8217;t form a loop. (since the two components are independent till now) and it will be a part of the MST.</p>
<p>This is why we need the union-find algorithm.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GuruSimhe</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-28633</link>
		<dc:creator><![CDATA[GuruSimhe]]></dc:creator>
		<pubDate>Wed, 09 Oct 2013 13:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-28633</guid>
		<description><![CDATA[Dude, go through Union by rank algorithm first. :-)]]></description>
		<content:encoded><![CDATA[<p>Dude, go through Union by rank algorithm first. ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: angel</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/#comment-28553</link>
		<dc:creator><![CDATA[angel]]></dc:creator>
		<pubDate>Mon, 07 Oct 2013 15:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=26604#comment-28553</guid>
		<description><![CDATA[Hi,

I have one doubt,why do we need to use Union find algorithm for loop detection,if both vertics of current edge are already visited ,then definately they would create loop.so why to spend extra log n processing time in finding of loop.I made a small program of kruskals,in which i used one visited array of vertices only to detect cycle.Please let me know if i am missing something

void MinSpanningTree_Kruskals(struct edge *Graph_edge,int count)

{

	bool visited[SIZE]={0,};

	int i=0,k=0;

	struct edge final_edges[SIZE]={0,};

	while(k&#060;SIZE-1&#038;&#038; i&#060;count)

	{

		if(!visited[Graph_edge[i].dest]&#124;&#124;!visited[Graph_edge[i].src])

		{

			visited[Graph_edge[i].dest]=1;

			visited[Graph_edge[i].src]=1;

			final_edges[k++]=Graph_edge[i];

		}

		i++;

	}

	printf(&#034;nKruskals Algorithmn&#034;);

	for(i=0;i&#060;SIZE-1;i++)

	 {

		 printf(&#034;nsrc=%d,dest=%d,weight=%dn&#034;,final_edges[i].src,final_edges[i].dest,final_edges[i].weight);

	 }

}]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I have one doubt,why do we need to use Union find algorithm for loop detection,if both vertics of current edge are already visited ,then definately they would create loop.so why to spend extra log n processing time in finding of loop.I made a small program of kruskals,in which i used one visited array of vertices only to detect cycle.Please let me know if i am missing something</p>
<p>void MinSpanningTree_Kruskals(struct edge *Graph_edge,int count)</p>
<p>{</p>
<p>	bool visited[SIZE]={0,};</p>
<p>	int i=0,k=0;</p>
<p>	struct edge final_edges[SIZE]={0,};</p>
<p>	while(k&lt;SIZE-1&amp;&amp; i&lt;count)</p>
<p>	{</p>
<p>		if(!visited[Graph_edge[i].dest]||!visited[Graph_edge[i].src])</p>
<p>		{</p>
<p>			visited[Graph_edge[i].dest]=1;</p>
<p>			visited[Graph_edge[i].src]=1;</p>
<p>			final_edges[k++]=Graph_edge[i];</p>
<p>		}</p>
<p>		i++;</p>
<p>	}</p>
<p>	printf(&quot;nKruskals Algorithmn&quot;);</p>
<p>	for(i=0;i&lt;SIZE-1;i++)</p>
<p>	 {</p>
<p>		 printf(&quot;nsrc=%d,dest=%d,weight=%dn&quot;,final_edges[i].src,final_edges[i].dest,final_edges[i].weight);</p>
<p>	 }</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:08:38 -->

<!-- Compression = gzip -->