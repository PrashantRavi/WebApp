<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Implement Queue using Stacks</title>
	<atom:link href="http://www.geeksforgeeks.org/queue-using-stacks/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/queue-using-stacks/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: 01210121</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-39628</link>
		<dc:creator><![CDATA[01210121]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 11:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-39628</guid>
		<description><![CDATA[can sumbody tell me how to display the items here after enqueued]]></description>
		<content:encoded><![CDATA[<p>can sumbody tell me how to display the items here after enqueued</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hitesh</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-39389</link>
		<dc:creator><![CDATA[Hitesh]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 22:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-39389</guid>
		<description><![CDATA[/*working code for implementing queue using two stacks if anyone can find an error or a better approach can discuss it on form or mail me (saini.hitesh93@hotmail.com)*/ 

#include
using namespace std;
struct node
{
    int data;
    struct node *next;
}*top1=NULL,*top2=NULL;
void printreverse(struct node *x)
{
    if(x==NULL)
    return;
    else
    printreverse(x-&#062;next);
    cout&#060;data&#060;&#060;&#034;    &#034;;
    
}
void enqueue()
{       
int n;
struct node *temp,*p,*temp1;  
temp=(struct node*)malloc(sizeof(struct node));
cout&#060;&#060;&#034;enter the numbe you want to insert&#034;&#060;&#062;n;
temp-&#062;data=n;
temp-&#062;next=top1;
top1=temp;
}        
void dequeue()
{
struct node *p; 
 if(top1==NULL&#038;&#038;top2==NULL)
cout&#060;&#060;&#034;queue is empty&#034;&#060;data=top1-&#062;data;
        temp-&#062;next=top2;
        top1=top1-&#062;next;
        top2=temp;
    }
    p=top2;
    top2=top2-&#062;next;
    cout&#060;data&#060;&#060;&#034; &#034;&#060;&#060;&#034;has been deleted&#034;&#060;next;
    cout&#060;data&#060;&#060;&#034; &#034;&#060;&#060;&#034;has been deleted&#034;&#060;&#060;endl;
    free(p);    
}
}
}
void display()
{ 
struct node *p,*prev,*current,*next;
    if(top1==NULL&#038;&#038;top2==NULL)
    cout&#060;&#060;&#034;queue is empty&#034;&#060;&#060;endl;
    else
    {
        if(top2!=NULL)
        {   p=top2;
            while(p!=NULL)
            {
                cout&#060;data&#060;next;
            }
            if(top1!=NULL)
        printreverse(top1);
            cout&#060;&#060;&#034;n&#034;;
        }
        else
        {
                printreverse(top1);
                cout&#060;&#060;&#034;n&#034;;
        }
        
    }
}
int main()
{
    int n;
    while(1)
    {
    
    cout&#060;&#060;&#034;enter your choice&#034;&#060;&#060;endl&#060;&#060;&#034;1.insert&#034;&#060;&#060;endl&#060;&#060;&#034;2.dequeue&#034;&#060;&#060;endl&#060;&#060;&#034;3.display&#034;&#060;&#060;endl&#060;&#060;&#034;4.exit&#034;&#060;&#062;n;
    switch(n)
    {
        case 1:
       enqueue();
            break;
            case 2:
                dequeue();
                break;
                case 3:
                    display();
                    break;
                    case 4:
                        exit(1);
                        default:
                            cout&#060;&#060;&#034;invalid choice&#034;&#060;&#060;endl;
    }
}
}]]></description>
		<content:encoded><![CDATA[<p>/*working code for implementing queue using two stacks if anyone can find an error or a better approach can discuss it on form or mail me (saini.hitesh93@hotmail.com)*/ </p>
<p>#include<br />
using namespace std;<br />
struct node<br />
{<br />
    int data;<br />
    struct node *next;<br />
}*top1=NULL,*top2=NULL;<br />
void printreverse(struct node *x)<br />
{<br />
    if(x==NULL)<br />
    return;<br />
    else<br />
    printreverse(x-&gt;next);<br />
    cout&lt;data&lt;&lt;&quot;    &quot;;</p>
<p>}<br />
void enqueue()<br />
{<br />
int n;<br />
struct node *temp,*p,*temp1;<br />
temp=(struct node*)malloc(sizeof(struct node));<br />
cout&lt;&lt;&quot;enter the numbe you want to insert&quot;&lt;&gt;n;<br />
temp-&gt;data=n;<br />
temp-&gt;next=top1;<br />
top1=temp;<br />
}<br />
void dequeue()<br />
{<br />
struct node *p;<br />
 if(top1==NULL&amp;&amp;top2==NULL)<br />
cout&lt;&lt;&quot;queue is empty&quot;&lt;data=top1-&gt;data;<br />
        temp-&gt;next=top2;<br />
        top1=top1-&gt;next;<br />
        top2=temp;<br />
    }<br />
    p=top2;<br />
    top2=top2-&gt;next;<br />
    cout&lt;data&lt;&lt;&quot; &quot;&lt;&lt;&quot;has been deleted&quot;&lt;next;<br />
    cout&lt;data&lt;&lt;&quot; &quot;&lt;&lt;&quot;has been deleted&quot;&lt;&lt;endl;<br />
    free(p);<br />
}<br />
}<br />
}<br />
void display()<br />
{<br />
struct node *p,*prev,*current,*next;<br />
    if(top1==NULL&amp;&amp;top2==NULL)<br />
    cout&lt;&lt;&quot;queue is empty&quot;&lt;&lt;endl;<br />
    else<br />
    {<br />
        if(top2!=NULL)<br />
        {   p=top2;<br />
            while(p!=NULL)<br />
            {<br />
                cout&lt;data&lt;next;<br />
            }<br />
            if(top1!=NULL)<br />
        printreverse(top1);<br />
            cout&lt;&lt;&quot;n&quot;;<br />
        }<br />
        else<br />
        {<br />
                printreverse(top1);<br />
                cout&lt;&lt;&quot;n&quot;;<br />
        }</p>
<p>    }<br />
}<br />
int main()<br />
{<br />
    int n;<br />
    while(1)<br />
    {</p>
<p>    cout&lt;&lt;&quot;enter your choice&quot;&lt;&lt;endl&lt;&lt;&quot;1.insert&quot;&lt;&lt;endl&lt;&lt;&quot;2.dequeue&quot;&lt;&lt;endl&lt;&lt;&quot;3.display&quot;&lt;&lt;endl&lt;&lt;&quot;4.exit&quot;&lt;&gt;n;<br />
    switch(n)<br />
    {<br />
        case 1:<br />
       enqueue();<br />
            break;<br />
            case 2:<br />
                dequeue();<br />
                break;<br />
                case 3:<br />
                    display();<br />
                    break;<br />
                    case 4:<br />
                        exit(1);<br />
                        default:<br />
                            cout&lt;&lt;&quot;invalid choice&quot;&lt;&lt;endl;<br />
    }<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gaurav_sharma_17</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-32732</link>
		<dc:creator><![CDATA[gaurav_sharma_17]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 09:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-32732</guid>
		<description><![CDATA[/*
Queue can also be implemented using one user stack and one Function Call Stack.
Below
 is modified Method 2 where recursion (or Function Call Stack) is used 
to implement queue using only one user defined stack.

enQueue(x)
  1) Push x to stack1.

deQueue:
  1) If stack1 is empty then error.
  2) If stack1 has only one element then return it.
  3) Recursively pop everything from the stack1, store the popped item 

    in a variable res,  push the res back to stack1 and return res

The
 step 3 makes sure that the last popped item is always returned and 
since the recursion stops when there is only one item in stack1 (step 
2), we get the last element of stack1 in dequeue() and all other items 
are pushed back in step 3.

*/

#include
#include
#include
#include
#include 
#include 

class Q
{
      public :

      void enQueue(std::stack&#038;s1, int x)
      {
         s1.push(x);
      }
  
     int deQueue(std::stack &#038;d)
     {
         int x, res;
         if(d.empty())

         {
            printf(&quot;Q is empty&quot;);
            getchar();
            exit(0);
          }
          else if(d.size() == 1)
          {
             x=d.top();
             d.pop();

             return  x;
          }
          else
          {
               /* pop an item from the stack1 */
               x=d.top();
               d.pop();
                
               /* store the last dequeued item */

               res = deQueue(d);
  
               /* push everything back to stack1 */
               d.push(x);
               return res;
          }
       }
};  

  

int main()
{

   std::stack s1;
   Q  d;
   d.enQueue(s1,7);
   d.enQueue(s1,71);
   d.enQueue(s1,17);
   d.enQueue(s1,47);
   d.enQueue(s1,74);
   d.enQueue(s1,741);
   cout&#060;&#060;d.deQueue(s1);
  cout&#060;&#060;endl&#060;&#060;&#034;rest of the queue :n&#034;;
while (!s1.empty())
{
     std::cout&#060;&#060;&#039; &#039;&#060;&#060; s1.top();
     s1.pop();
   }
   getchar();
}]]></description>
		<content:encoded><![CDATA[<p>/*<br />
Queue can also be implemented using one user stack and one Function Call Stack.<br />
Below<br />
 is modified Method 2 where recursion (or Function Call Stack) is used<br />
to implement queue using only one user defined stack.</p>
<p>enQueue(x)<br />
  1) Push x to stack1.</p>
<p>deQueue:<br />
  1) If stack1 is empty then error.<br />
  2) If stack1 has only one element then return it.<br />
  3) Recursively pop everything from the stack1, store the popped item </p>
<p>    in a variable res,  push the res back to stack1 and return res</p>
<p>The<br />
 step 3 makes sure that the last popped item is always returned and<br />
since the recursion stops when there is only one item in stack1 (step<br />
2), we get the last element of stack1 in dequeue() and all other items<br />
are pushed back in step 3.</p>
<p>*/</p>
<p>#include<br />
#include<br />
#include<br />
#include<br />
#include<br />
#include </p>
<p>class Q<br />
{<br />
      public :</p>
<p>      void enQueue(std::stack&amp;s1, int x)<br />
      {<br />
         s1.push(x);<br />
      }</p>
<p>     int deQueue(std::stack &amp;d)<br />
     {<br />
         int x, res;<br />
         if(d.empty())</p>
<p>         {<br />
            printf(&#8220;Q is empty&#8221;);<br />
            getchar();<br />
            exit(0);<br />
          }<br />
          else if(d.size() == 1)<br />
          {<br />
             x=d.top();<br />
             d.pop();</p>
<p>             return  x;<br />
          }<br />
          else<br />
          {<br />
               /* pop an item from the stack1 */<br />
               x=d.top();<br />
               d.pop();</p>
<p>               /* store the last dequeued item */</p>
<p>               res = deQueue(d);</p>
<p>               /* push everything back to stack1 */<br />
               d.push(x);<br />
               return res;<br />
          }<br />
       }<br />
};  </p>
<p>int main()<br />
{</p>
<p>   std::stack s1;<br />
   Q  d;<br />
   d.enQueue(s1,7);<br />
   d.enQueue(s1,71);<br />
   d.enQueue(s1,17);<br />
   d.enQueue(s1,47);<br />
   d.enQueue(s1,74);<br />
   d.enQueue(s1,741);<br />
   cout&lt;&lt;d.deQueue(s1);<br />
  cout&lt;&lt;endl&lt;&lt;&quot;rest of the queue :n&quot;;<br />
while (!s1.empty())<br />
{<br />
     std::cout&lt;&lt;&#039; &#039;&lt;&lt; s1.top();<br />
     s1.pop();<br />
   }<br />
   getchar();<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Chad</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-32619</link>
		<dc:creator><![CDATA[Chad]]></dc:creator>
		<pubDate>Sun, 16 Feb 2014 20:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-32619</guid>
		<description><![CDATA[How would you implement a copy constructor for Queue?]]></description>
		<content:encoded><![CDATA[<p>How would you implement a copy constructor for Queue?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aditya</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-31471</link>
		<dc:creator><![CDATA[Aditya]]></dc:creator>
		<pubDate>Sun, 12 Jan 2014 08:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-31471</guid>
		<description><![CDATA[What is the practical use case for such a problem? (obviously except that there are only stacks available and no queues)]]></description>
		<content:encoded><![CDATA[<p>What is the practical use case for such a problem? (obviously except that there are only stacks available and no queues)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: yyk</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-28307</link>
		<dc:creator><![CDATA[yyk]]></dc:creator>
		<pubDate>Tue, 01 Oct 2013 08:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-28307</guid>
		<description><![CDATA[yah...you r missing...point that....
&quot;While dequeuing, when there are no elements in stack 2 u r pushing all elements in stack 1 to stack 2 not everytime,,,,,,when there are elements in stack 2, u dequeue directly from stack 2....without pushing elements from stack 1&quot;]]></description>
		<content:encoded><![CDATA[<p>yah&#8230;you r missing&#8230;point that&#8230;.<br />
&#8220;While dequeuing, when there are no elements in stack 2 u r pushing all elements in stack 1 to stack 2 not everytime,,,,,,when there are elements in stack 2, u dequeue directly from stack 2&#8230;.without pushing elements from stack 1&#8221;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Piyush</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-27182</link>
		<dc:creator><![CDATA[Piyush]]></dc:creator>
		<pubDate>Fri, 30 Aug 2013 11:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-27182</guid>
		<description><![CDATA[Damn !! The newer interface of geeksforgeeks is not beautifying the code properly. It messed my code.


Please consider the code till dequeue only. Imagine that the class ended after that.


I tried to write traverse func, but it got messed up here with main().]]></description>
		<content:encoded><![CDATA[<p>Damn !! The newer interface of geeksforgeeks is not beautifying the code properly. It messed my code.</p>
<p>Please consider the code till dequeue only. Imagine that the class ended after that.</p>
<p>I tried to write traverse func, but it got messed up here with main().</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Piyush</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-27181</link>
		<dc:creator><![CDATA[Piyush]]></dc:creator>
		<pubDate>Fri, 30 Aug 2013 11:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-27181</guid>
		<description><![CDATA[My method.

In this approach, enqueue operation is o(1) and dequeue is avg o(2).
&lt;code&gt;

#include
#include

#define ERROR 0xFFFFFFFF
using namespace std;

template 
class Queue {
        private:
                stack A,B;
        public:
                int enqueue(T element)
                {
                        A.push(element);
                        return 1;
                }
                int dequeue(T *element)
                {
                        if(B.empty())
                        {
                                if(A.empty())
                                {
                                        *element = ERROR;
                                        return -1;
                                }
                                while(!A.empty())
                                {
                                        B.push(A.top());
                                        A.pop();
                                }
                        }
                        *element = B.top();
                        B.pop();
                        return 1;
                }
                void traverse()
                {
                        while(!B.empty())
                        {
                                cout &#060;&#060; &#034; &#034; &#060;&#060;B.top();
                                B.pop();
                        }
                        while(!A.empty())
                        {
                                B.push(A.top());
                                A.pop();
                        }
                        while(!B.empty())
                        {
                                cout &#060;&#060; &#034; &#034; &#060;&#060;B.top();
                                B.pop();
                        }
                }
};

int main()
{
        int ptr;
        Queue q;
        q.enqueue(5);
        q.enqueue(10);
        q.enqueue(15);
        q.enqueue(20);
        q.dequeue(&#038;ptr);
        q.dequeue(&#038;ptr);
        q.enqueue(25);
        q.enqueue(30);
        q.enqueue(35);
        q.enqueue(40);
        q.dequeue(&#038;ptr);
        q.dequeue(&#038;ptr);
        q.enqueue(45);
        q.enqueue(50);
        q.dequeue(&#038;ptr);
        q.traverse();
        return 0;
}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>My method.</p>
<p>In this approach, enqueue operation is o(1) and dequeue is avg o(2).<br />
<code></p>
<p>#include<br />
#include</p>
<p>#define ERROR 0xFFFFFFFF<br />
using namespace std;</p>
<p>template<br />
class Queue {<br />
        private:<br />
                stack A,B;<br />
        public:<br />
                int enqueue(T element)<br />
                {<br />
                        A.push(element);<br />
                        return 1;<br />
                }<br />
                int dequeue(T *element)<br />
                {<br />
                        if(B.empty())<br />
                        {<br />
                                if(A.empty())<br />
                                {<br />
                                        *element = ERROR;<br />
                                        return -1;<br />
                                }<br />
                                while(!A.empty())<br />
                                {<br />
                                        B.push(A.top());<br />
                                        A.pop();<br />
                                }<br />
                        }<br />
                        *element = B.top();<br />
                        B.pop();<br />
                        return 1;<br />
                }<br />
                void traverse()<br />
                {<br />
                        while(!B.empty())<br />
                        {<br />
                                cout &lt;&lt; &quot; &quot; &lt;&lt;B.top();<br />
                                B.pop();<br />
                        }<br />
                        while(!A.empty())<br />
                        {<br />
                                B.push(A.top());<br />
                                A.pop();<br />
                        }<br />
                        while(!B.empty())<br />
                        {<br />
                                cout &lt;&lt; &quot; &quot; &lt;&lt;B.top();<br />
                                B.pop();<br />
                        }<br />
                }<br />
};</p>
<p>int main()<br />
{<br />
        int ptr;<br />
        Queue q;<br />
        q.enqueue(5);<br />
        q.enqueue(10);<br />
        q.enqueue(15);<br />
        q.enqueue(20);<br />
        q.dequeue(&amp;ptr);<br />
        q.dequeue(&amp;ptr);<br />
        q.enqueue(25);<br />
        q.enqueue(30);<br />
        q.enqueue(35);<br />
        q.enqueue(40);<br />
        q.dequeue(&amp;ptr);<br />
        q.dequeue(&amp;ptr);<br />
        q.enqueue(45);<br />
        q.enqueue(50);<br />
        q.dequeue(&amp;ptr);<br />
        q.traverse();<br />
        return 0;<br />
}<br />
</code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek Choudhery</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-27046</link>
		<dc:creator><![CDATA[Abhishek Choudhery]]></dc:creator>
		<pubDate>Tue, 27 Aug 2013 17:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-27046</guid>
		<description><![CDATA[No, the next element that you would want on the next pop operation is now at the top of Stack 2. See the Algo for Pop again! 
    Even I had the same doubt previously]]></description>
		<content:encoded><![CDATA[<p>No, the next element that you would want on the next pop operation is now at the top of Stack 2. See the Algo for Pop again!<br />
    Even I had the same doubt previously</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rengasami21</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-25174</link>
		<dc:creator><![CDATA[rengasami21]]></dc:creator>
		<pubDate>Sun, 18 Aug 2013 10:33:20 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-25174</guid>
		<description><![CDATA[In method 2 (using two stacks), don&#039;t we need to push all the elements back from stack 2 to stack 1? Because when we pop out for deque stack 1 becomes empty. 

Am I missing something? Can somebody help me?]]></description>
		<content:encoded><![CDATA[<p>In method 2 (using two stacks), don&#8217;t we need to push all the elements back from stack 2 to stack 1? Because when we pop out for deque stack 1 becomes empty. </p>
<p>Am I missing something? Can somebody help me?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rengasami21</title>
		<link>http://www.geeksforgeeks.org/queue-using-stacks/#comment-25170</link>
		<dc:creator><![CDATA[rengasami21]]></dc:creator>
		<pubDate>Sun, 18 Aug 2013 09:57:30 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5009#comment-25170</guid>
		<description><![CDATA[Hi,

As per method 2 of using 2 stacks, we are popping every element of stack 1 and pushing it to stack 2 when we dequeue. So after this step, the stack 1 is empty. Now we are enqueuing an element, it will get added to stack 1. Now if we would like to dequeue an element, that one element will be popped out and pushed to stack 2, now if I pop from stack 2, it will give me only the element that was enqueued just now.

Don&#039;t we need to push all the elements from Stack 2 to Stack 1 after dequeue?

Am I missing something here? Can somebody help me?

regards,
Rengasami R]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>As per method 2 of using 2 stacks, we are popping every element of stack 1 and pushing it to stack 2 when we dequeue. So after this step, the stack 1 is empty. Now we are enqueuing an element, it will get added to stack 1. Now if we would like to dequeue an element, that one element will be popped out and pushed to stack 2, now if I pop from stack 2, it will give me only the element that was enqueued just now.</p>
<p>Don&#8217;t we need to push all the elements from Stack 2 to Stack 1 after dequeue?</p>
<p>Am I missing something here? Can somebody help me?</p>
<p>regards,<br />
Rengasami R</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:23:44 -->

<!-- Compression = gzip -->