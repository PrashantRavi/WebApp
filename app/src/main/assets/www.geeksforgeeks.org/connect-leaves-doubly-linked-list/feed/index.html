<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Extract Leaves of a Binary Tree in a Doubly Linked List</title>
	<atom:link href="http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-34937</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Sun, 20 Apr 2014 19:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-34937</guid>
		<description><![CDATA[So did you got selected and did the Interviewer asked further question on your approach......What all questions did he asked you, Sorry but I am a little curious because after 3 months i have amazon visiting my campus for placements.So, would be a great help if you could tell me..]]></description>
		<content:encoded><![CDATA[<p>So did you got selected and did the Interviewer asked further question on your approach&#8230;&#8230;What all questions did he asked you, Sorry but I am a little curious because after 3 months i have amazon visiting my campus for placements.So, would be a great help if you could tell me..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: KB</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-34832</link>
		<dc:creator><![CDATA[KB]]></dc:creator>
		<pubDate>Fri, 18 Apr 2014 18:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-34832</guid>
		<description><![CDATA[It is correct i guess, i did it by inorder traversal only in Amazon interview.]]></description>
		<content:encoded><![CDATA[<p>It is correct i guess, i did it by inorder traversal only in Amazon interview.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-34815</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Fri, 18 Apr 2014 12:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-34815</guid>
		<description><![CDATA[A simple inorder traversal can be used for this question.........@geeksforgeeks please suggest if some error or case is missing....

Initially called with convert(root,NULL,NULL);

root= root of tree.
prev=this points to parent of the root.
head=used for DLL.
 
void convert(struct tree *root,struct tree *prev,struct tree **head)
{
static struct tree *p=NULL;
if(root==NULL)
return;
else
{
convert(root-&#062;left,root,head);

if(root-&#062;left==NULL &#038;&#038; root-&#062;right==NULL)
{
root-&#062;left=p;
if((*head)==NULL)
*head=root;
else
{ p-&#062;right=root; }
p=root;
if(prev-&#062;left==root) //deleting node from tree
prev-&#062;left=NULL;
else
prev-&#062;right=NULL;
}

convert(root-&#062;right,root,head);
} 
}]]></description>
		<content:encoded><![CDATA[<p>A simple inorder traversal can be used for this question&#8230;&#8230;&#8230;@geeksforgeeks please suggest if some error or case is missing&#8230;.</p>
<p>Initially called with convert(root,NULL,NULL);</p>
<p>root= root of tree.<br />
prev=this points to parent of the root.<br />
head=used for DLL.</p>
<p>void convert(struct tree *root,struct tree *prev,struct tree **head)<br />
{<br />
static struct tree *p=NULL;<br />
if(root==NULL)<br />
return;<br />
else<br />
{<br />
convert(root-&gt;left,root,head);</p>
<p>if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)<br />
{<br />
root-&gt;left=p;<br />
if((*head)==NULL)<br />
*head=root;<br />
else<br />
{ p-&gt;right=root; }<br />
p=root;<br />
if(prev-&gt;left==root) //deleting node from tree<br />
prev-&gt;left=NULL;<br />
else<br />
prev-&gt;right=NULL;<br />
}</p>
<p>convert(root-&gt;right,root,head);<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-34814</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 18 Apr 2014 12:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-34814</guid>
		<description><![CDATA[A simple inorder traversal can be used for this question.........@geeksforgeeks please suggest if some error or case is missing....

Initially called with convert(root,NULL,NULL);

void convert(struct tree *root,struct tree *prev,struct tree **head)
{
    static struct tree *p=NULL;
    if(root==NULL)
        return;
    else
    {
        convert(root-&#062;left,root,head);

        if(root-&#062;left==NULL &#038;&#038; root-&#062;right==NULL)
        {
            root-&#062;left=p;
            if((*head)==NULL)
                *head=root;
            else
 { p-&#062;right=root; }
            p=root;
            if(prev-&#062;left==root) //deleting node from tree
                prev-&#062;left=NULL;
            else
                prev-&#062;right=NULL;
        }

        convert(root-&#062;right,root,head);
    } 
}]]></description>
		<content:encoded><![CDATA[<p>A simple inorder traversal can be used for this question&#8230;&#8230;&#8230;@geeksforgeeks please suggest if some error or case is missing&#8230;.</p>
<p>Initially called with convert(root,NULL,NULL);</p>
<p>void convert(struct tree *root,struct tree *prev,struct tree **head)<br />
{<br />
    static struct tree *p=NULL;<br />
    if(root==NULL)<br />
        return;<br />
    else<br />
    {<br />
        convert(root-&gt;left,root,head);</p>
<p>        if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)<br />
        {<br />
            root-&gt;left=p;<br />
            if((*head)==NULL)<br />
                *head=root;<br />
            else<br />
 { p-&gt;right=root; }<br />
            p=root;<br />
            if(prev-&gt;left==root) //deleting node from tree<br />
                prev-&gt;left=NULL;<br />
            else<br />
                prev-&gt;right=NULL;<br />
        }</p>
<p>        convert(root-&gt;right,root,head);<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wgpshashank</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30779</link>
		<dc:creator><![CDATA[wgpshashank]]></dc:creator>
		<pubDate>Mon, 16 Dec 2013 19:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30779</guid>
		<description><![CDATA[There is no need of reverse post order traversal , http://ideone.com/cEFBah.]]></description>
		<content:encoded><![CDATA[<p>There is no need of reverse post order traversal , <a href="http://ideone.com/cEFBah" rel="nofollow">http://ideone.com/cEFBah</a>.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wgpshashank</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30767</link>
		<dc:creator><![CDATA[wgpshashank]]></dc:creator>
		<pubDate>Mon, 16 Dec 2013 12:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30767</guid>
		<description><![CDATA[Yes that&#039;s the way , we should always avoid the recursion as much as possible .]]></description>
		<content:encoded><![CDATA[<p>Yes that&#8217;s the way , we should always avoid the recursion as much as possible .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: coder_aks</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30412</link>
		<dc:creator><![CDATA[coder_aks]]></dc:creator>
		<pubDate>Wed, 04 Dec 2013 15:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30412</guid>
		<description><![CDATA[I didn&#039;t get the significance of DLL here? Can anyone help me ?]]></description>
		<content:encoded><![CDATA[<p>I didn&#8217;t get the significance of DLL here? Can anyone help me ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: coder_aks</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30411</link>
		<dc:creator><![CDATA[coder_aks]]></dc:creator>
		<pubDate>Wed, 04 Dec 2013 15:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30411</guid>
		<description><![CDATA[Can this be done through level order traversal? The output(order in DLL) might not be the same as discussed here.]]></description>
		<content:encoded><![CDATA[<p>Can this be done through level order traversal? The output(order in DLL) might not be the same as discussed here.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: coder_aks</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30410</link>
		<dc:creator><![CDATA[coder_aks]]></dc:creator>
		<pubDate>Wed, 04 Dec 2013 15:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30410</guid>
		<description><![CDATA[Can we do it through level order traversal? The output might not be same as the one discussed here!]]></description>
		<content:encoded><![CDATA[<p>Can we do it through level order traversal? The output might not be same as the one discussed here!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nitin</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30159</link>
		<dc:creator><![CDATA[nitin]]></dc:creator>
		<pubDate>Tue, 26 Nov 2013 16:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30159</guid>
		<description><![CDATA[the extractLeafList should return (*head) instead of root at the last]]></description>
		<content:encoded><![CDATA[<p>the extractLeafList should return (*head) instead of root at the last</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Coder011</title>
		<link>http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/#comment-30069</link>
		<dc:creator><![CDATA[Coder011]]></dc:creator>
		<pubDate>Sat, 23 Nov 2013 15:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=123360#comment-30069</guid>
		<description><![CDATA[#include 

#include 

#include 

using namespace std;

struct TreeNode {

      int val;

      TreeNode *left;

      TreeNode *right;

      TreeNode(int x) : val(x), left(NULL), right(NULL) {}

  };

bool Inorder(TreeNode **tail,TreeNode *root)

{

	if(!root)

	  return 0;

	if(!root-&#062;left &#038;&#038; !root-&#062;right)

	  {

	  	(*tail)-&#062;right=root;

	  	root-&#062;left=(*tail);

	  	(*tail)=root;

	  	return 1;

	  }

	 if(Inorder(tail,root-&#062;left))   // As a check for hitting a Leaf Node

	 root-&#062;left=NULL;

	 if(Inorder(tail,root-&#062;right))

        root-&#062;right=NULL;

     return false;

}

TreeNode *newNode(int val)

{

	TreeNode *X=(TreeNode *)calloc(1,sizeof(TreeNode));

	X-&#062;val=val;

	X-&#062;right=X-&#062;left=NULL;

	return X;

}

void MakeTree(TreeNode *root)

{

	 root-&#062;left = newNode(2);

     root-&#062;right = newNode(3);

     root-&#062;left-&#062;left = newNode(4);

     root-&#062;left-&#062;right = newNode(5);

     root-&#062;right-&#062;right = newNode(6);

     root-&#062;left-&#062;left-&#062;left = newNode(7);

     root-&#062;left-&#062;left-&#062;right = newNode(8);

     root-&#062;right-&#062;right-&#062;left = newNode(9);

     root-&#062;right-&#062;right-&#062;right = newNode(10);

     return;

}

class Solution

{

	public:

	 	TreeNode *ExtractLeavesDLL(TreeNode*,TreeNode *);

};

TreeNode *Solution::ExtractLeavesDLL(TreeNode *head,TreeNode *root)

{

	TreeNode *SaveHead=head;

	Inorder(&#038;head,root);

	return SaveHead-&#062;right;

}

void Doinorder(TreeNode* root)

{

    if(!root) return;

    Doinorder(root-&#062;left);

    cout&#060;val&#060;right);

}

 /* Driver Program to test the above Code */

int main() {

	 Solution ob1;

	 struct TreeNode *head = newNode(-1);

     struct TreeNode *root = newNode(1);

     MakeTree(root);

     head=ob1.ExtractLeavesDLL(head,root);

     cout&#060;&#060;&#034;Printing the Doubly Linked Listn&#034;;

     while(head)

      {

          cout&#060;val&#060;right;

      }

     cout&#060;&#060;&#034;n--------------------------------n&#034;;

     cout&#060;&#060;&#034; Inorder Traversal of Modified Treen&#034;;

     Doinorder(root);

     cout&#060;&#060;&#034;n&#034;;

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>using namespace std;</p>
<p>struct TreeNode {</p>
<p>      int val;</p>
<p>      TreeNode *left;</p>
<p>      TreeNode *right;</p>
<p>      TreeNode(int x) : val(x), left(NULL), right(NULL) {}</p>
<p>  };</p>
<p>bool Inorder(TreeNode **tail,TreeNode *root)</p>
<p>{</p>
<p>	if(!root)</p>
<p>	  return 0;</p>
<p>	if(!root-&gt;left &amp;&amp; !root-&gt;right)</p>
<p>	  {</p>
<p>	  	(*tail)-&gt;right=root;</p>
<p>	  	root-&gt;left=(*tail);</p>
<p>	  	(*tail)=root;</p>
<p>	  	return 1;</p>
<p>	  }</p>
<p>	 if(Inorder(tail,root-&gt;left))   // As a check for hitting a Leaf Node</p>
<p>	 root-&gt;left=NULL;</p>
<p>	 if(Inorder(tail,root-&gt;right))</p>
<p>        root-&gt;right=NULL;</p>
<p>     return false;</p>
<p>}</p>
<p>TreeNode *newNode(int val)</p>
<p>{</p>
<p>	TreeNode *X=(TreeNode *)calloc(1,sizeof(TreeNode));</p>
<p>	X-&gt;val=val;</p>
<p>	X-&gt;right=X-&gt;left=NULL;</p>
<p>	return X;</p>
<p>}</p>
<p>void MakeTree(TreeNode *root)</p>
<p>{</p>
<p>	 root-&gt;left = newNode(2);</p>
<p>     root-&gt;right = newNode(3);</p>
<p>     root-&gt;left-&gt;left = newNode(4);</p>
<p>     root-&gt;left-&gt;right = newNode(5);</p>
<p>     root-&gt;right-&gt;right = newNode(6);</p>
<p>     root-&gt;left-&gt;left-&gt;left = newNode(7);</p>
<p>     root-&gt;left-&gt;left-&gt;right = newNode(8);</p>
<p>     root-&gt;right-&gt;right-&gt;left = newNode(9);</p>
<p>     root-&gt;right-&gt;right-&gt;right = newNode(10);</p>
<p>     return;</p>
<p>}</p>
<p>class Solution</p>
<p>{</p>
<p>	public:</p>
<p>	 	TreeNode *ExtractLeavesDLL(TreeNode*,TreeNode *);</p>
<p>};</p>
<p>TreeNode *Solution::ExtractLeavesDLL(TreeNode *head,TreeNode *root)</p>
<p>{</p>
<p>	TreeNode *SaveHead=head;</p>
<p>	Inorder(&amp;head,root);</p>
<p>	return SaveHead-&gt;right;</p>
<p>}</p>
<p>void Doinorder(TreeNode* root)</p>
<p>{</p>
<p>    if(!root) return;</p>
<p>    Doinorder(root-&gt;left);</p>
<p>    cout&lt;val&lt;right);</p>
<p>}</p>
<p> /* Driver Program to test the above Code */</p>
<p>int main() {</p>
<p>	 Solution ob1;</p>
<p>	 struct TreeNode *head = newNode(-1);</p>
<p>     struct TreeNode *root = newNode(1);</p>
<p>     MakeTree(root);</p>
<p>     head=ob1.ExtractLeavesDLL(head,root);</p>
<p>     cout&lt;&lt;&quot;Printing the Doubly Linked Listn&quot;;</p>
<p>     while(head)</p>
<p>      {</p>
<p>          cout&lt;val&lt;right;</p>
<p>      }</p>
<p>     cout&lt;&lt;&quot;n&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;n&quot;;</p>
<p>     cout&lt;&lt;&quot; Inorder Traversal of Modified Treen&quot;;</p>
<p>     Doinorder(root);</p>
<p>     cout&lt;&lt;&quot;n&quot;;</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:40 -->

<!-- Compression = gzip -->