<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: QuickSort on Singly Linked List</title>
	<atom:link href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: anand</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-35969</link>
		<dc:creator><![CDATA[anand]]></dc:creator>
		<pubDate>Tue, 13 May 2014 09:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-35969</guid>
		<description><![CDATA[void sortList() {

                        NODE *tmp1=NULL,*tmp2=NULL,*tmp3=NULL;

                        int num;

                        if(start != NULL){

                                                tmp1 = start;

                                                while(tmp1-&#062;next != NULL &#124;&#124; tmp1 != head)

                                                {

                                                 tmp2 =tmp3= tmp1;

                                                 num  = tmp1-&#062;val;

                                                        while(tmp2-&#062;next != NULL &#124;&#124; tmp2 != head)

                                                        {

                                                                if(tmp2-&#062;val val)

                                                                 {

                                                                        tmp3 = tmp2;

                                                                        }

                                                                tmp2 = tmp2-&#062;next;

                                                        }

                                                 if(tmp2-&#062;val val)

                                                        tmp3 = tmp2;

                                                 num = tmp3-&#062;val;

                                                 tmp3-&#062;val = tmp1-&#062;val;

                                                 tmp1-&#062;val =num;

                                                 tmp1=tmp1-&#062;next;

                                                }

                                        }

                        else

                                printf(&quot;No node present in list n&quot;);

}









Is there is any problem with this code...???]]></description>
		<content:encoded><![CDATA[<p>void sortList() {</p>
<p>                        NODE *tmp1=NULL,*tmp2=NULL,*tmp3=NULL;</p>
<p>                        int num;</p>
<p>                        if(start != NULL){</p>
<p>                                                tmp1 = start;</p>
<p>                                                while(tmp1-&gt;next != NULL || tmp1 != head)</p>
<p>                                                {</p>
<p>                                                 tmp2 =tmp3= tmp1;</p>
<p>                                                 num  = tmp1-&gt;val;</p>
<p>                                                        while(tmp2-&gt;next != NULL || tmp2 != head)</p>
<p>                                                        {</p>
<p>                                                                if(tmp2-&gt;val val)</p>
<p>                                                                 {</p>
<p>                                                                        tmp3 = tmp2;</p>
<p>                                                                        }</p>
<p>                                                                tmp2 = tmp2-&gt;next;</p>
<p>                                                        }</p>
<p>                                                 if(tmp2-&gt;val val)</p>
<p>                                                        tmp3 = tmp2;</p>
<p>                                                 num = tmp3-&gt;val;</p>
<p>                                                 tmp3-&gt;val = tmp1-&gt;val;</p>
<p>                                                 tmp1-&gt;val =num;</p>
<p>                                                 tmp1=tmp1-&gt;next;</p>
<p>                                                }</p>
<p>                                        }</p>
<p>                        else</p>
<p>                                printf(&#8220;No node present in list n&#8221;);</p>
<p>}</p>
<p>Is there is any problem with this code&#8230;???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: rupali</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-34495</link>
		<dc:creator><![CDATA[rupali]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 09:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-34495</guid>
		<description><![CDATA[their is an error:

in quickSortRecur function,

before calling it recursively for right part,we need to check if (pivot-&#062;next !=NULL) or if(pivot-&#062;next !=newEnd)

so it will be

if(pivot!=newEnd)
pivot-&#062;next = quickSortRecur(pivot-&#062;next, newEnd);

otherwise it may give segmentation error,if such a condition is encountered.]]></description>
		<content:encoded><![CDATA[<p>their is an error:</p>
<p>in quickSortRecur function,</p>
<p>before calling it recursively for right part,we need to check if (pivot-&gt;next !=NULL) or if(pivot-&gt;next !=newEnd)</p>
<p>so it will be</p>
<p>if(pivot!=newEnd)<br />
pivot-&gt;next = quickSortRecur(pivot-&gt;next, newEnd);</p>
<p>otherwise it may give segmentation error,if such a condition is encountered.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Zheng Luo</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-33669</link>
		<dc:creator><![CDATA[Zheng Luo]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 18:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-33669</guid>
		<description><![CDATA[Very Good source code, thanks for sharing.]]></description>
		<content:encoded><![CDATA[<p>Very Good source code, thanks for sharing.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Indra Kumar Gurjar</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-31565</link>
		<dc:creator><![CDATA[Indra Kumar Gurjar]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 16:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-31565</guid>
		<description><![CDATA[You can see a very sort programme for it...
http://ideone.com/T72pBP]]></description>
		<content:encoded><![CDATA[<p>You can see a very sort programme for it&#8230;<br />
<a href="http://ideone.com/T72pBP" rel="nofollow">http://ideone.com/T72pBP</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Indra Kumar Gurjar</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-31564</link>
		<dc:creator><![CDATA[Indra Kumar Gurjar]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 16:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-31564</guid>
		<description><![CDATA[#include
#define null (node*)(-1)
typedef struct node node;
struct node
{
	node *next;
	int value;
};
node* new_node(int value,node* next)
{
   node* newn;
   newn=(node*)malloc(sizeof(node));
   newn-&#062;value=value;
   newn-&#062;next=next;
   return newn;
}

// function for quick_sort of linked list//
void sort(node** start,node* end)
{
       if(*start==end)
    	   return;
       //chosen first item as pivot//
   node *pivot=(*start);
   node *temp=(*start),*temp1;
   while(temp-&#062;next!=end)
   {
        if(temp-&#062;next-&#062;value value)
        {
        	temp1=(*start);
           *start=temp-&#062;next;
          temp-&#062;next=temp-&#062;next-&#062;next;
           (*start)-&#062;next=temp1;
        }
        else
        temp=temp-&#062;next;
   }
   sort(start,pivot);
   sort(&#038;(pivot-&#062;next),end);
}

// mainfunction for test//
int main()
{
   node *head;
   node *a[11];
 a[5]=new_node(2,null);
   a[4]=new_node(3,a[5]);
   a[3]=new_node(1,a[4]);
   a[2]=new_node(5,a[3]);
   a[1]=new_node(4,a[2]);
   head=a[1];
sort(&#038;head,null);
while(head!=null)
{
	printf(&quot;%d &quot;,head-&#062;value);
	head=head-&#062;next;
}
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#define null (node*)(-1)<br />
typedef struct node node;<br />
struct node<br />
{<br />
	node *next;<br />
	int value;<br />
};<br />
node* new_node(int value,node* next)<br />
{<br />
   node* newn;<br />
   newn=(node*)malloc(sizeof(node));<br />
   newn-&gt;value=value;<br />
   newn-&gt;next=next;<br />
   return newn;<br />
}</p>
<p>// function for quick_sort of linked list//<br />
void sort(node** start,node* end)<br />
{<br />
       if(*start==end)<br />
    	   return;<br />
       //chosen first item as pivot//<br />
   node *pivot=(*start);<br />
   node *temp=(*start),*temp1;<br />
   while(temp-&gt;next!=end)<br />
   {<br />
        if(temp-&gt;next-&gt;value value)<br />
        {<br />
        	temp1=(*start);<br />
           *start=temp-&gt;next;<br />
          temp-&gt;next=temp-&gt;next-&gt;next;<br />
           (*start)-&gt;next=temp1;<br />
        }<br />
        else<br />
        temp=temp-&gt;next;<br />
   }<br />
   sort(start,pivot);<br />
   sort(&amp;(pivot-&gt;next),end);<br />
}</p>
<p>// mainfunction for test//<br />
int main()<br />
{<br />
   node *head;<br />
   node *a[11];<br />
 a[5]=new_node(2,null);<br />
   a[4]=new_node(3,a[5]);<br />
   a[3]=new_node(1,a[4]);<br />
   a[2]=new_node(5,a[3]);<br />
   a[1]=new_node(4,a[2]);<br />
   head=a[1];<br />
sort(&amp;head,null);<br />
while(head!=null)<br />
{<br />
	printf(&#8220;%d &#8220;,head-&gt;value);<br />
	head=head-&gt;next;<br />
}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prasanna</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-30941</link>
		<dc:creator><![CDATA[Prasanna]]></dc:creator>
		<pubDate>Sun, 22 Dec 2013 18:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-30941</guid>
		<description><![CDATA[why not exchange the data instead of changing the pointers? it would be more easy]]></description>
		<content:encoded><![CDATA[<p>why not exchange the data instead of changing the pointers? it would be more easy</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Confused</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-26950</link>
		<dc:creator><![CDATA[Confused]]></dc:creator>
		<pubDate>Sun, 25 Aug 2013 15:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-26950</guid>
		<description><![CDATA[You mean when the list is empty?]]></description>
		<content:encoded><![CDATA[<p>You mean when the list is empty?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gopi</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-26949</link>
		<dc:creator><![CDATA[Gopi]]></dc:creator>
		<pubDate>Sun, 25 Aug 2013 14:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-26949</guid>
		<description><![CDATA[The other condition checks for NULL which looks correct.]]></description>
		<content:encoded><![CDATA[<p>The other condition checks for NULL which looks correct.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: confused</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-26947</link>
		<dc:creator><![CDATA[confused]]></dc:creator>
		<pubDate>Sun, 25 Aug 2013 14:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-26947</guid>
		<description><![CDATA[Hi,

I am kind of confused with the base case, shouldn&#039;t it just be 

if ( head == end)

        return head;





Thanks.]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I am kind of confused with the base case, shouldn&#8217;t it just be </p>
<p>if ( head == end)</p>
<p>        return head;</p>
<p>Thanks.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: confused</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-26948</link>
		<dc:creator><![CDATA[confused]]></dc:creator>
		<pubDate>Sun, 25 Aug 2013 14:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-26948</guid>
		<description><![CDATA[Hi,

I am kind of confused with the base case, shouldn&#039;t it just be 

if ( head == end)

        return head;





Thanks.]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I am kind of confused with the base case, shouldn&#8217;t it just be </p>
<p>if ( head == end)</p>
<p>        return head;</p>
<p>Thanks.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Atiqur Rahman</title>
		<link>http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/#comment-25916</link>
		<dc:creator><![CDATA[Atiqur Rahman]]></dc:creator>
		<pubDate>Fri, 16 Aug 2013 14:34:26 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=119900#comment-25916</guid>
		<description><![CDATA[//Quicksort using singly linked list.
#include &#060;stdio.h&#062;
#include &#060;string.h&#062;
#include &#060;stdlib.h&#062;
typedef struct LinkList. 
{
    int data;.
    struct LinkList *next;.
}List;
void Insert(List **Head, int value).
{
    List *ptr=*Head;.
    List *newnode;.
    newnode=(List*)malloc(sizeof(List));.
    newnode-&#062;data=value;.
    newnode-&#062;next=NULL;.
    if(ptr==NULL).
    *Head=newnode;.
    else.
    {.
        while(ptr-&#062;next!=NULL).
        ptr=ptr-&#062;next;.
        ptr-&#062;next=newnode;.
    }.

}
void Quicksort(List *Head, List *end).
{  if(Head==end)return;.
    int count=0, count1=0, count2=0, temp=0;.
    List *front=Head,*back=end, pf, bf,*ptr=Head,*pivot=Head;.
    while(ptr!=end).
    {.
        count++;.
        ptr=ptr-&#062;next;.    
    }.

    while(count&#062;=0&#038;&#038;front-&#062;next!=back).
    {.
        while(front-&#062;next&#038;&#038;front-&#062;next-&#062;data&#060;pivot-&#062;data).
          front=front-&#062;next;.
        while(count&#062;0&#038;&#038;front-&#062;next!=back).
        {.
            back=Head;.
            count1=--count;.
            while(count1).
            {.
                back=back-&#062;next;.
                count1--;.
            }.
            if(back-&#062;data&#060;pivot-&#062;data).
            {.
               temp=front-&#062;next-&#062;data;.
               front-&#062;next-&#062;data=back-&#062;data;.
               back-&#062;data=temp;.
               front=front-&#062;next;.
               count;.
               break;.
            }.
        }.

   }.
    temp=front-&#062;data;.
    front-&#062;data=pivot-&#062;data;.
    pivot-&#062;data=temp;.
    Display(Head);.
    Quicksort(Head, front);.
   Quicksort(front-&#062;next, end);.
}
void Display(List *Head).
{
    if(! Head)return ;
    printf(&#034;%d  &#034;, Head-&#062;data);.
    Display(Head-&#062;next);.
}
int main(void)
{
List *Head=NULL;
int i, value;
for(i=0;i&#060;10;i++) 
{
    scanf(&#034;%d&#034;,&#038;value);.
    Insert(&#038;Head, value);.
}
    Display(Head);printf(&#034;n&#034;);.
    Quicksort(Head, NULL);.
    printf(&#034;n&#034;);.
   Display(Head);.
return 0;    
}]]></description>
		<content:encoded><![CDATA[<p>//Quicksort using singly linked list.<br />
#include &lt;stdio.h&gt;<br />
#include &lt;string.h&gt;<br />
#include &lt;stdlib.h&gt;<br />
typedef struct LinkList.<br />
{<br />
    int data;.<br />
    struct LinkList *next;.<br />
}List;<br />
void Insert(List **Head, int value).<br />
{<br />
    List *ptr=*Head;.<br />
    List *newnode;.<br />
    newnode=(List*)malloc(sizeof(List));.<br />
    newnode-&gt;data=value;.<br />
    newnode-&gt;next=NULL;.<br />
    if(ptr==NULL).<br />
    *Head=newnode;.<br />
    else.<br />
    {.<br />
        while(ptr-&gt;next!=NULL).<br />
        ptr=ptr-&gt;next;.<br />
        ptr-&gt;next=newnode;.<br />
    }.</p>
<p>}<br />
void Quicksort(List *Head, List *end).<br />
{  if(Head==end)return;.<br />
    int count=0, count1=0, count2=0, temp=0;.<br />
    List *front=Head,*back=end, pf, bf,*ptr=Head,*pivot=Head;.<br />
    while(ptr!=end).<br />
    {.<br />
        count++;.<br />
        ptr=ptr-&gt;next;.<br />
    }.</p>
<p>    while(count&gt;=0&amp;&amp;front-&gt;next!=back).<br />
    {.<br />
        while(front-&gt;next&amp;&amp;front-&gt;next-&gt;data&lt;pivot-&gt;data).<br />
          front=front-&gt;next;.<br />
        while(count&gt;0&amp;&amp;front-&gt;next!=back).<br />
        {.<br />
            back=Head;.<br />
            count1=&#8211;count;.<br />
            while(count1).<br />
            {.<br />
                back=back-&gt;next;.<br />
                count1&#8211;;.<br />
            }.<br />
            if(back-&gt;data&lt;pivot-&gt;data).<br />
            {.<br />
               temp=front-&gt;next-&gt;data;.<br />
               front-&gt;next-&gt;data=back-&gt;data;.<br />
               back-&gt;data=temp;.<br />
               front=front-&gt;next;.<br />
               count;.<br />
               break;.<br />
            }.<br />
        }.</p>
<p>   }.<br />
    temp=front-&gt;data;.<br />
    front-&gt;data=pivot-&gt;data;.<br />
    pivot-&gt;data=temp;.<br />
    Display(Head);.<br />
    Quicksort(Head, front);.<br />
   Quicksort(front-&gt;next, end);.<br />
}<br />
void Display(List *Head).<br />
{<br />
    if(! Head)return ;<br />
    printf(&quot;%d  &quot;, Head-&gt;data);.<br />
    Display(Head-&gt;next);.<br />
}<br />
int main(void)<br />
{<br />
List *Head=NULL;<br />
int i, value;<br />
for(i=0;i&lt;10;i++)<br />
{<br />
    scanf(&quot;%d&quot;,&amp;value);.<br />
    Insert(&amp;Head, value);.<br />
}<br />
    Display(Head);printf(&quot;n&quot;);.<br />
    Quicksort(Head, NULL);.<br />
    printf(&quot;n&quot;);.<br />
   Display(Head);.<br />
return 0;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.052 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:08:24 -->

<!-- Compression = gzip -->