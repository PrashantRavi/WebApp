<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Print Ancestors of a given node in Binary Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Jun</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39664</link>
		<dc:creator><![CDATA[Jun]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 16:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39664</guid>
		<description><![CDATA[Hello...The code runs perfectly fine and has comparable complexity with the  recursive solution.:) :)...
But the solution works well only for a BST..while the solution provided above works for a non BST as well...]]></description>
		<content:encoded><![CDATA[<p>Hello&#8230;The code runs perfectly fine and has comparable complexity with the  recursive solution.:) :)&#8230;<br />
But the solution works well only for a BST..while the solution provided above works for a non BST as well&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jun</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39662</link>
		<dc:creator><![CDATA[Jun]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 16:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39662</guid>
		<description><![CDATA[Hello...The code runs perfectly fine and has comparable complexity with the  recursive solution.:) :)]]></description>
		<content:encoded><![CDATA[<p>Hello&#8230;The code runs perfectly fine and has comparable complexity with the  recursive solution.:) ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39534</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 14:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39534</guid>
		<description><![CDATA[you search for that node and all those nodes which come in the path while searching are ancestors!! Right?
So why complicate the code]]></description>
		<content:encoded><![CDATA[<p>you search for that node and all those nodes which come in the path while searching are ancestors!! Right?<br />
So why complicate the code</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39532</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 14:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39532</guid>
		<description><![CDATA[is there  any problem in given code

void printAncestors( struct node *root, int num )
{
if ( root == NULL )
return ;
while(1)
{
if( root-&#062;val == num)
return ;

printf(&quot;%dt&quot;,root-&#062;val);
if( root-&#062;val &#062; num ) 
root = root-&#062;left ;
else 
root = root-&#062;right ;
}

}]]></description>
		<content:encoded><![CDATA[<p>is there  any problem in given code</p>
<p>void printAncestors( struct node *root, int num )<br />
{<br />
if ( root == NULL )<br />
return ;<br />
while(1)<br />
{<br />
if( root-&gt;val == num)<br />
return ;</p>
<p>printf(&#8220;%dt&#8221;,root-&gt;val);<br />
if( root-&gt;val &gt; num )<br />
root = root-&gt;left ;<br />
else<br />
root = root-&gt;right ;<br />
}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jannat</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39334</link>
		<dc:creator><![CDATA[jannat]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 09:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39334</guid>
		<description><![CDATA[time complexity in this case is O(2n) which is equal to O(n)....and one more thing if you use a normal array on place of stack then time complexity will be O(n)]]></description>
		<content:encoded><![CDATA[<p>time complexity in this case is O(2n) which is equal to O(n)&#8230;.and one more thing if you use a normal array on place of stack then time complexity will be O(n)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jannat</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-39333</link>
		<dc:creator><![CDATA[jannat]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 09:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-39333</guid>
		<description><![CDATA[what about this function --

void ancestorutil(struct node *root, int key, std::stack&#038; s)

{

    if(root==NULL)

        return;

        if(root-&#062;data==key)

        printstack(s);

        s.push(root-&#062;data);

        ancestorutil(root-&#062;left,key,s);

        s.pop();

        if(root-&#062;right)

            {

                s.push(root-&#062;data);

                ancestorutil(root-&#062;right,key,s);

            }

}]]></description>
		<content:encoded><![CDATA[<p>what about this function &#8212;</p>
<p>void ancestorutil(struct node *root, int key, std::stack&amp; s)</p>
<p>{</p>
<p>    if(root==NULL)</p>
<p>        return;</p>
<p>        if(root-&gt;data==key)</p>
<p>        printstack(s);</p>
<p>        s.push(root-&gt;data);</p>
<p>        ancestorutil(root-&gt;left,key,s);</p>
<p>        s.pop();</p>
<p>        if(root-&gt;right)</p>
<p>            {</p>
<p>                s.push(root-&gt;data);</p>
<p>                ancestorutil(root-&gt;right,key,s);</p>
<p>            }</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-38994</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 04:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-38994</guid>
		<description><![CDATA[Not at all. We&#039;re not enumerating all root to leaf paths in the array. As soon as the required node is found, we print the contents of the array. We&#039;ll get the ancestors in root to node order
http://ideone.com/Rgl3pf]]></description>
		<content:encoded><![CDATA[<p>Not at all. We&#8217;re not enumerating all root to leaf paths in the array. As soon as the required node is found, we print the contents of the array. We&#8217;ll get the ancestors in root to node order<br />
<a href="http://ideone.com/Rgl3pf" rel="nofollow">http://ideone.com/Rgl3pf</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: MK</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-38984</link>
		<dc:creator><![CDATA[MK]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 21:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-38984</guid>
		<description><![CDATA[But that requires checking each of the arrays, once all paths are enumerated into arrays right?? More work after recursion, if I am not wrong.]]></description>
		<content:encoded><![CDATA[<p>But that requires checking each of the arrays, once all paths are enumerated into arrays right?? More work after recursion, if I am not wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Suvodip Bhattacharya</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-38603</link>
		<dc:creator><![CDATA[Suvodip Bhattacharya]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 19:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-38603</guid>
		<description><![CDATA[#include
using namespace std;

struct tree {
    int data;
    struct tree *lc,*rc;
    };


tree* newNode(int n)
{
    struct tree *temp=new tree;
    temp-&#062;lc=temp-&#062;rc=NULL;
    temp-&#062;data=n;

    return temp;
}

void AllAncestor(struct tree *root,int *num)
{
    if(root == NULL &#124;&#124; ( root-&#062;lc==NULL &#038;&#038; root-&#062;rc==NULL) ) return;
    
    

    AllAncestor(root-&#062;lc,num);
    AllAncestor(root-&#062;rc,num);

    if( (root-&#062;lc &#038;&#038; root-&#062;lc-&#062;data == *num ) &#124;&#124; (root-&#062;rc &#038;&#038; root-&#062;rc-&#062;data == *num) )
    {
        cout&#060;data&#060;&#060;&#034; &#034;&#060;data;
    }
}

int main()
{
    struct tree *root;
    int num=7;
    root=newNode(1);
    root-&#062;lc=newNode(2);
    root-&#062;rc=newNode(3);
    root-&#062;lc-&#062;lc=newNode(4);
    root-&#062;lc-&#062;rc=newNode(5);
    root-&#062;rc-&#062;lc=newNode(6);
    root-&#062;rc-&#062;rc=newNode(7);
    root-&#062;rc-&#062;rc-&#062;rc=newNode(8);

    AllAncestor(root,&#038;num);
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
using namespace std;</p>
<p>struct tree {<br />
    int data;<br />
    struct tree *lc,*rc;<br />
    };</p>
<p>tree* newNode(int n)<br />
{<br />
    struct tree *temp=new tree;<br />
    temp-&gt;lc=temp-&gt;rc=NULL;<br />
    temp-&gt;data=n;</p>
<p>    return temp;<br />
}</p>
<p>void AllAncestor(struct tree *root,int *num)<br />
{<br />
    if(root == NULL || ( root-&gt;lc==NULL &amp;&amp; root-&gt;rc==NULL) ) return;</p>
<p>    AllAncestor(root-&gt;lc,num);<br />
    AllAncestor(root-&gt;rc,num);</p>
<p>    if( (root-&gt;lc &amp;&amp; root-&gt;lc-&gt;data == *num ) || (root-&gt;rc &amp;&amp; root-&gt;rc-&gt;data == *num) )<br />
    {<br />
        cout&lt;data&lt;&lt;&quot; &quot;&lt;data;<br />
    }<br />
}</p>
<p>int main()<br />
{<br />
    struct tree *root;<br />
    int num=7;<br />
    root=newNode(1);<br />
    root-&gt;lc=newNode(2);<br />
    root-&gt;rc=newNode(3);<br />
    root-&gt;lc-&gt;lc=newNode(4);<br />
    root-&gt;lc-&gt;rc=newNode(5);<br />
    root-&gt;rc-&gt;lc=newNode(6);<br />
    root-&gt;rc-&gt;rc=newNode(7);<br />
    root-&gt;rc-&gt;rc-&gt;rc=newNode(8);</p>
<p>    AllAncestor(root,&amp;num);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-38185</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 09:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-38185</guid>
		<description><![CDATA[We can use a method similar to that used in http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/ for root to leaf paths. It&#039;ll print the ancestors in a root to node fashion though.]]></description>
		<content:encoded><![CDATA[<p>We can use a method similar to that used in <a href="http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/" rel="nofollow">http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/</a> for root to leaf paths. It&#8217;ll print the ancestors in a root to node fashion though.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: aMUchbetteraproach</title>
		<link>http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/#comment-34259</link>
		<dc:creator><![CDATA[aMUchbetteraproach]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 15:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10988#comment-34259</guid>
		<description><![CDATA[#include

#include

#include

using namespace std;

/* A binary tree node has data, pointer to left child

   and a pointer to right child */

struct node

{

   int data;

   struct node* left;

   struct node* right;

};

/* Helper function that allocates a new node with the

   given data and NULL left and right pointers. */

struct node* newnode(int data)

{

  struct node* node = (struct node*)

                       malloc(sizeof(struct node));

  node-&#062;data = data;

  node-&#062;left = NULL;

  node-&#062;right = NULL;

  return(node);

}

void printAncestors(struct node *node,int data){

    if(node == NULL){

        printf(&quot;tree is empty...n&quot;);

        return;

    }

    if(node-&#062;data == data){

        //printf(&quot;%d &quot;,node-&#062;data);

        return;

    }

    if(node-&#062;dataleft,data);

    else

        printAncestors(node-&#062;right,data);

    printf(&quot;%d &quot;,node-&#062;data);

}

/* Driver program to test above functions*/

int main()

{

  /* Construct the following binary tree

              1

            /   

          2      3

        /  

      4     5

     /

    7

  */

  struct node *root = newnode(1);

  root-&#062;left        = newnode(2);

  root-&#062;right       = newnode(3);

  root-&#062;left-&#062;left  = newnode(4);

  root-&#062;left-&#062;right = newnode(5);

  root-&#062;left-&#062;left-&#062;left  = newnode(7);

  printAncestors(root, 7);

  getchar();

  return 0;

}]]></description>
		<content:encoded><![CDATA[<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>/* A binary tree node has data, pointer to left child</p>
<p>   and a pointer to right child */</p>
<p>struct node</p>
<p>{</p>
<p>   int data;</p>
<p>   struct node* left;</p>
<p>   struct node* right;</p>
<p>};</p>
<p>/* Helper function that allocates a new node with the</p>
<p>   given data and NULL left and right pointers. */</p>
<p>struct node* newnode(int data)</p>
<p>{</p>
<p>  struct node* node = (struct node*)</p>
<p>                       malloc(sizeof(struct node));</p>
<p>  node-&gt;data = data;</p>
<p>  node-&gt;left = NULL;</p>
<p>  node-&gt;right = NULL;</p>
<p>  return(node);</p>
<p>}</p>
<p>void printAncestors(struct node *node,int data){</p>
<p>    if(node == NULL){</p>
<p>        printf(&#8220;tree is empty&#8230;n&#8221;);</p>
<p>        return;</p>
<p>    }</p>
<p>    if(node-&gt;data == data){</p>
<p>        //printf(&#8220;%d &#8220;,node-&gt;data);</p>
<p>        return;</p>
<p>    }</p>
<p>    if(node-&gt;dataleft,data);</p>
<p>    else</p>
<p>        printAncestors(node-&gt;right,data);</p>
<p>    printf(&#8220;%d &#8220;,node-&gt;data);</p>
<p>}</p>
<p>/* Driver program to test above functions*/</p>
<p>int main()</p>
<p>{</p>
<p>  /* Construct the following binary tree</p>
<p>              1</p>
<p>            /   </p>
<p>          2      3</p>
<p>        /  </p>
<p>      4     5</p>
<p>     /</p>
<p>    7</p>
<p>  */</p>
<p>  struct node *root = newnode(1);</p>
<p>  root-&gt;left        = newnode(2);</p>
<p>  root-&gt;right       = newnode(3);</p>
<p>  root-&gt;left-&gt;left  = newnode(4);</p>
<p>  root-&gt;left-&gt;right = newnode(5);</p>
<p>  root-&gt;left-&gt;left-&gt;left  = newnode(7);</p>
<p>  printAncestors(root, 7);</p>
<p>  getchar();</p>
<p>  return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.049 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:04:00 -->

<!-- Compression = gzip -->