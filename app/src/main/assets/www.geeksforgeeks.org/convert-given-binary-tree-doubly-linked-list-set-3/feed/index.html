<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Convert a given Binary Tree to Doubly Linked List &#124; Set 3</title>
	<atom:link href="http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Goutham</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-38727</link>
		<dc:creator><![CDATA[Goutham]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 17:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-38727</guid>
		<description><![CDATA[is the space complexity O(1) ?]]></description>
		<content:encoded><![CDATA[<p>is the space complexity O(1) ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Issac Newton</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-38007</link>
		<dc:creator><![CDATA[Issac Newton]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 13:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-38007</guid>
		<description><![CDATA[How is this inplace?]]></description>
		<content:encoded><![CDATA[<p>How is this inplace?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Archit</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-36271</link>
		<dc:creator><![CDATA[Archit]]></dc:creator>
		<pubDate>Mon, 19 May 2014 12:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-36271</guid>
		<description><![CDATA[Implementation of this code without using static-
Here is the link-
http://ideone.com/5rVl0E]]></description>
		<content:encoded><![CDATA[<p>Implementation of this code without using static-<br />
Here is the link-<br />
<a href="http://ideone.com/5rVl0E" rel="nofollow">http://ideone.com/5rVl0E</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-35251</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 19:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-35251</guid>
		<description><![CDATA[It has been taken care as initially *prev points to NULL]]></description>
		<content:encoded><![CDATA[<p>It has been taken care as initially *prev points to NULL</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pranav Sawant</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-34534</link>
		<dc:creator><![CDATA[Pranav Sawant]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 20:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-34534</guid>
		<description><![CDATA[Don&#039;t we need to set the left of head to null??]]></description>
		<content:encoded><![CDATA[<p>Don&#8217;t we need to set the left of head to null??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jonathan</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-34380</link>
		<dc:creator><![CDATA[Jonathan]]></dc:creator>
		<pubDate>Sun, 06 Apr 2014 18:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-34380</guid>
		<description><![CDATA[With level-order traversal we would get the wrong DLL.


The instructions say we should end up with a list that is the same as an inorder traversal of the tree, not level order. Thus, we do an inorder traversal.]]></description>
		<content:encoded><![CDATA[<p>With level-order traversal we would get the wrong DLL.</p>
<p>The instructions say we should end up with a list that is the same as an inorder traversal of the tree, not level order. Thus, we do an inorder traversal.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-34372</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Sun, 06 Apr 2014 11:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-34372</guid>
		<description><![CDATA[why should we do inorder traversal alone for this ?? cant we do a level order traversal and just create a DLL ??????]]></description>
		<content:encoded><![CDATA[<p>why should we do inorder traversal alone for this ?? cant we do a level order traversal and just create a DLL ??????</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Alien</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-34170</link>
		<dc:creator><![CDATA[Alien]]></dc:creator>
		<pubDate>Tue, 01 Apr 2014 18:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-34170</guid>
		<description><![CDATA[Amazingly simple solution !!! Thank you geeksforgeeks]]></description>
		<content:encoded><![CDATA[<p>Amazingly simple solution !!! Thank you geeksforgeeks</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ravi</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-33971</link>
		<dc:creator><![CDATA[Ravi]]></dc:creator>
		<pubDate>Fri, 28 Mar 2014 07:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-33971</guid>
		<description><![CDATA[In java, your root&#039;s reference is wrapped inside a class tree.  When you pass a tree, you actually pass a reference to tree object.  So you can change root.]]></description>
		<content:encoded><![CDATA[<p>In java, your root&#8217;s reference is wrapped inside a class tree.  When you pass a tree, you actually pass a reference to tree object.  So you can change root.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek Kumar</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-33609</link>
		<dc:creator><![CDATA[Abhishek Kumar]]></dc:creator>
		<pubDate>Mon, 17 Mar 2014 13:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-33609</guid>
		<description><![CDATA[thiz iz an awesome for conversion of BT to DLL..!!!!!]]></description>
		<content:encoded><![CDATA[<p>thiz iz an awesome for conversion of BT to DLL..!!!!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aj</title>
		<link>http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/#comment-33259</link>
		<dc:creator><![CDATA[Aj]]></dc:creator>
		<pubDate>Thu, 06 Mar 2014 19:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=126854#comment-33259</guid>
		<description><![CDATA[The way I tried to do it was maintaining the tree structure while creating the linked list. I tried doing it for singly linked list and my node looked is like

struct node
{
	int data;
	node *right;
	node *left;
	node *next; // I&#039;m not touching right and left pointer for sake of maintaining tree structure. Using a new next pointer for linked list.
};

So if you want to traverse the tree, pass the root node to inorder routine and if you want to print the linked list just past the head pointer to it.

Code
----------------
#include 
#include 
#include 
#include 
#include 
#include 

using namespace std;

struct node
{
	int data;
	node *right;
	node *left;
	node *next;
};

node * createNode(int n)
{
	node *new_node = (node *)malloc(sizeof(node));
	new_node-&#062;data = n;
	new_node-&#062;right = NULL;
	new_node-&#062;left = NULL;
	new_node-&#062;next = NULL;
	return new_node;
}

void inOrder(node *n)
{
	if(n==NULL)
		return;
	inOrder(n-&#062;left);
	printf(&quot;%dn&quot;,n-&#062;data);
	inOrder(n-&#062;right);
}

void  bstToList(node *root, node **head)
{
	if(root == NULL)
		return;
	static node *prev = NULL;
	bstToList(root-&#062;left, head);

	if(prev == NULL)
	{
		*head=root;
	}
	else
	{
		prev-&#062;next = root;
	}

	prev=root;

	bstToList(root-&#062;right, head);
}

void printList(node *node)
{
    while (node!=NULL)
    {
        cout &#060;data &#060;next;
    }

}

int main(int argc, char *argv[])
{
	struct node *root = createNode(10);
	root-&#062;left = createNode(8);
	root-&#062;right = createNode(12);
	root-&#062;left-&#062;left = createNode(6);
	root-&#062;left-&#062;right = createNode(9);
	root-&#062;right-&#062;left = createNode(11);
	root-&#062;right-&#062;right = createNode(13);

	inOrder(root);
	node *head = NULL;
	bstToList(root, &#038;head);
	printList(head);

	return 0;
}]]></description>
		<content:encoded><![CDATA[<p>The way I tried to do it was maintaining the tree structure while creating the linked list. I tried doing it for singly linked list and my node looked is like</p>
<p>struct node<br />
{<br />
	int data;<br />
	node *right;<br />
	node *left;<br />
	node *next; // I&#8217;m not touching right and left pointer for sake of maintaining tree structure. Using a new next pointer for linked list.<br />
};</p>
<p>So if you want to traverse the tree, pass the root node to inorder routine and if you want to print the linked list just past the head pointer to it.</p>
<p>Code<br />
&#8212;&#8212;&#8212;&#8212;&#8212;-<br />
#include<br />
#include<br />
#include<br />
#include<br />
#include<br />
#include </p>
<p>using namespace std;</p>
<p>struct node<br />
{<br />
	int data;<br />
	node *right;<br />
	node *left;<br />
	node *next;<br />
};</p>
<p>node * createNode(int n)<br />
{<br />
	node *new_node = (node *)malloc(sizeof(node));<br />
	new_node-&gt;data = n;<br />
	new_node-&gt;right = NULL;<br />
	new_node-&gt;left = NULL;<br />
	new_node-&gt;next = NULL;<br />
	return new_node;<br />
}</p>
<p>void inOrder(node *n)<br />
{<br />
	if(n==NULL)<br />
		return;<br />
	inOrder(n-&gt;left);<br />
	printf(&#8220;%dn&#8221;,n-&gt;data);<br />
	inOrder(n-&gt;right);<br />
}</p>
<p>void  bstToList(node *root, node **head)<br />
{<br />
	if(root == NULL)<br />
		return;<br />
	static node *prev = NULL;<br />
	bstToList(root-&gt;left, head);</p>
<p>	if(prev == NULL)<br />
	{<br />
		*head=root;<br />
	}<br />
	else<br />
	{<br />
		prev-&gt;next = root;<br />
	}</p>
<p>	prev=root;</p>
<p>	bstToList(root-&gt;right, head);<br />
}</p>
<p>void printList(node *node)<br />
{<br />
    while (node!=NULL)<br />
    {<br />
        cout &lt;data &lt;next;<br />
    }</p>
<p>}</p>
<p>int main(int argc, char *argv[])<br />
{<br />
	struct node *root = createNode(10);<br />
	root-&gt;left = createNode(8);<br />
	root-&gt;right = createNode(12);<br />
	root-&gt;left-&gt;left = createNode(6);<br />
	root-&gt;left-&gt;right = createNode(9);<br />
	root-&gt;right-&gt;left = createNode(11);<br />
	root-&gt;right-&gt;right = createNode(13);</p>
<p>	inOrder(root);<br />
	node *head = NULL;<br />
	bstToList(root, &amp;head);<br />
	printList(head);</p>
<p>	return 0;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:11 -->

<!-- Compression = gzip -->