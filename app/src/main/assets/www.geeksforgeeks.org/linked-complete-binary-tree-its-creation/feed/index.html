<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Linked complete binary tree &#038; its creation</title>
	<atom:link href="http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Dheeraj Arya</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-39446</link>
		<dc:creator><![CDATA[Dheeraj Arya]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 11:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-39446</guid>
		<description><![CDATA[This question can also be done with the use of array, see this solution also.
http://dj8aprilwrites.blogspot.in/2014/02/create-complete-binary-tree-from-set-of.html]]></description>
		<content:encoded><![CDATA[<p>This question can also be done with the use of array, see this solution also.<br />
<a href="http://dj8aprilwrites.blogspot.in/2014/02/create-complete-binary-tree-from-set-of.html" rel="nofollow">http://dj8aprilwrites.blogspot.in/2014/02/create-complete-binary-tree-from-set-of.html</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vaibhav</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-39101</link>
		<dc:creator><![CDATA[vaibhav]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 04:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-39101</guid>
		<description><![CDATA[but how???... I am having the same doubt...i mean when front has both right and left child, how is the new node becoming the front-&#062;left-&#062;left??]]></description>
		<content:encoded><![CDATA[<p>but how???&#8230; I am having the same doubt&#8230;i mean when front has both right and left child, how is the new node becoming the front-&gt;left-&gt;left??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-38328</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 14:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-38328</guid>
		<description><![CDATA[nice :D]]></description>
		<content:encoded><![CDATA[<p>nice ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-37693</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 17:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-37693</guid>
		<description><![CDATA[the code is correct!]]></description>
		<content:encoded><![CDATA[<p>the code is correct!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-37691</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Thu, 05 Jun 2014 17:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-37691</guid>
		<description><![CDATA[very nice code @geeks ...my code would always start enquing from the root for a new insert but ur code (Y)]]></description>
		<content:encoded><![CDATA[<p>very nice code @geeks &#8230;my code would always start enquing from the root for a new insert but ur code (Y)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: SS</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-31400</link>
		<dc:creator><![CDATA[SS]]></dc:creator>
		<pubDate>Thu, 09 Jan 2014 13:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-31400</guid>
		<description><![CDATA[After looking at the program, it seems to be me that the insert functions seems incomplete/incorrect. When the front node is full with left and right already updated, we are just dequeueing it, dont we need to keep traversing the queue until one with either empty left or right is seen so that the newly created node can be added to it.]]></description>
		<content:encoded><![CDATA[<p>After looking at the program, it seems to be me that the insert functions seems incomplete/incorrect. When the front node is full with left and right already updated, we are just dequeueing it, dont we need to keep traversing the queue until one with either empty left or right is seen so that the newly created node can be added to it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: shaktiman</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-21105</link>
		<dc:creator><![CDATA[shaktiman]]></dc:creator>
		<pubDate>Wed, 03 Jul 2013 03:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-21105</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* 
#include &#060;iostream&#062;
#include &#060;queue&#062;
using namespace std;

struct node
{
    int data;
    struct node *right,*left;
};


// A utility function to create a new tree node
struct node* newNode(int data)
{
    struct node* temp = new (struct node);
    temp-&#062;data = data;
    temp-&#062;left = temp-&#062;right = NULL;
    return temp;
}

// A utility function to check if a tree node has both left and right children
int hasBothChild(struct node* temp)
{
    return temp &#038;&#038; temp-&#062;left &#038;&#038; temp-&#062;right;
}

// Function to insert a new node in complete binary tree
void insert(struct node **root, int data,queue&#060;struct node *&#062; &#038;myqueue )
{
    // Create a new node for given data
    struct node *temp = newNode(data);

    // If the tree is empty, initialize the root with new node.
    if (*root == NULL)
        *root = temp;

    else
    {
        // get the front node of the queue.
        struct node* front = myqueue.front();

        // If the left child of this front node doesnâ€™t exist, set the
        // left child as the new node
        if (!front-&#062;left)
            front-&#062;left = temp;

        // If the right child of this front node doesnâ€™t exist, set the
        // right child as the new node
        else if (!front-&#062;right)
            front-&#062;right = temp;

        // If the front node has both the left child and right child,
        // Dequeue() it.
        if (hasBothChild(front))
            myqueue.pop();
    }

    // Enqueue() the new node for later insertions
    myqueue.push(temp);
}

void clear(queue&#060;struct node *&#062; &#038;q )
{
   while(!q.empty())
	   q.pop();
}

// Standard level order traversal to test above function
void levelOrder(struct node* root)
{
	queue&#060;struct node *&#062; myqueue;

    myqueue.push(root);

    while (!myqueue.empty())
    {
        struct node* temp = myqueue.front();
        myqueue.pop();

        printf(&#034;%d &#034;, temp-&#062;data);

        if (temp-&#062;left)
            myqueue.push(temp-&#062;left);

        if (temp-&#062;right)
        	myqueue.push(temp-&#062;right);
    }
}

// Driver program to test above functions
int main()
{
    struct node* root = NULL;
    queue&#060;struct node*&#062; myqueue;

    int i;

    for(i = 1; i &#060;= 12; ++i)
        insert(&#038;root, i,myqueue);

    levelOrder(root);

    return 0;
}

 */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
/* 
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

struct node
{
    int data;
    struct node *right,*left;
};


// A utility function to create a new tree node
struct node* newNode(int data)
{
    struct node* temp = new (struct node);
    temp-&gt;data = data;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// A utility function to check if a tree node has both left and right children
int hasBothChild(struct node* temp)
{
    return temp &amp;&amp; temp-&gt;left &amp;&amp; temp-&gt;right;
}

// Function to insert a new node in complete binary tree
void insert(struct node **root, int data,queue&lt;struct node *&gt; &amp;myqueue )
{
    // Create a new node for given data
    struct node *temp = newNode(data);

    // If the tree is empty, initialize the root with new node.
    if (*root == NULL)
        *root = temp;

    else
    {
        // get the front node of the queue.
        struct node* front = myqueue.front();

        // If the left child of this front node doesnâ€™t exist, set the
        // left child as the new node
        if (!front-&gt;left)
            front-&gt;left = temp;

        // If the right child of this front node doesnâ€™t exist, set the
        // right child as the new node
        else if (!front-&gt;right)
            front-&gt;right = temp;

        // If the front node has both the left child and right child,
        // Dequeue() it.
        if (hasBothChild(front))
            myqueue.pop();
    }

    // Enqueue() the new node for later insertions
    myqueue.push(temp);
}

void clear(queue&lt;struct node *&gt; &amp;q )
{
   while(!q.empty())
	   q.pop();
}

// Standard level order traversal to test above function
void levelOrder(struct node* root)
{
	queue&lt;struct node *&gt; myqueue;

    myqueue.push(root);

    while (!myqueue.empty())
    {
        struct node* temp = myqueue.front();
        myqueue.pop();

        printf(&quot;%d &quot;, temp-&gt;data);

        if (temp-&gt;left)
            myqueue.push(temp-&gt;left);

        if (temp-&gt;right)
        	myqueue.push(temp-&gt;right);
    }
}

// Driver program to test above functions
int main()
{
    struct node* root = NULL;
    queue&lt;struct node*&gt; myqueue;

    int i;

    for(i = 1; i &lt;= 12; ++i)
        insert(&amp;root, i,myqueue);

    levelOrder(root);

    return 0;
}

 */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-18479</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Wed, 22 May 2013 19:21:46 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-18479</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Narendra Soni</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-26428</link>
		<dc:creator><![CDATA[Narendra Soni]]></dc:creator>
		<pubDate>Wed, 27 Feb 2013 22:20:24 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-26428</guid>
		<description><![CDATA[Thank you.]]></description>
		<content:encoded><![CDATA[<p>Thank you.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Madhav</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-15159</link>
		<dc:creator><![CDATA[Madhav]]></dc:creator>
		<pubDate>Sun, 10 Feb 2013 14:11:49 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-15159</guid>
		<description><![CDATA[Thanks.
Passing level seems to do the trick many times.]]></description>
		<content:encoded><![CDATA[<p>Thanks.<br />
Passing level seems to do the trick many times.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aashish</title>
		<link>http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/#comment-15156</link>
		<dc:creator><![CDATA[Aashish]]></dc:creator>
		<pubDate>Sun, 10 Feb 2013 13:45:30 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=29216#comment-15156</guid>
		<description><![CDATA[Traverse the tree in such a way that it only outputs the data level by level i.e. data in next level are traversed, only when the traversal of the data items at current level is finished. This can be done as follows:
Do inorder traversal of the tree level by level. Modify the standard inorder traversal where an extra argument will be passed to indicate the level. Call inorder traversal starting from the level 0, 1.... last level.

This approach takes O(N^2) time.]]></description>
		<content:encoded><![CDATA[<p>Traverse the tree in such a way that it only outputs the data level by level i.e. data in next level are traversed, only when the traversal of the data items at current level is finished. This can be done as follows:<br />
Do inorder traversal of the tree level by level. Modify the standard inorder traversal where an extra argument will be passed to indicate the level. Call inorder traversal starting from the level 0, 1&#8230;. last level.</p>
<p>This approach takes O(N^2) time.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:38 -->

<!-- Compression = gzip -->