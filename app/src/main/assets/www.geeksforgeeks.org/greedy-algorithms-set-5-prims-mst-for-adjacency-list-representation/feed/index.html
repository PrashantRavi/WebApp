<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Greedy Algorithms &#124; Set 6 (Primâ€™s MST for Adjacency List Representation)</title>
	<atom:link href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-39690</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 19:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-39690</guid>
		<description><![CDATA[we are updating the key in the heap ...as if we find a another smaller edge through which the already visted vertices MST can be connected]]></description>
		<content:encoded><![CDATA[<p>we are updating the key in the heap &#8230;as if we find a another smaller edge through which the already visted vertices MST can be connected</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: lilly</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-39344</link>
		<dc:creator><![CDATA[lilly]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 11:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-39344</guid>
		<description><![CDATA[could  you explain why we are using &quot;decreaseKey(minHeap, v, key[v])&quot; method?
thank you]]></description>
		<content:encoded><![CDATA[<p>could  you explain why we are using &#8220;decreaseKey(minHeap, v, key[v])&#8221; method?<br />
thank you</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Stormey</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-30971</link>
		<dc:creator><![CDATA[Stormey]]></dc:creator>
		<pubDate>Mon, 23 Dec 2013 18:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-30971</guid>
		<description><![CDATA[Shouldn&#039;t it be: &quot;Key is updated if the a vertex is in Min Heap and previous key value
 is greater than the weight of edge from X to the adjacent&quot;?
Since you DO want to update vertex&#039;s key ONLY if they are in the MinHeap...]]></description>
		<content:encoded><![CDATA[<p>Shouldn&#8217;t it be: &#8220;Key is updated if the a vertex is in Min Heap and previous key value<br />
 is greater than the weight of edge from X to the adjacent&#8221;?<br />
Since you DO want to update vertex&#8217;s key ONLY if they are in the MinHeap&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-27965</link>
		<dc:creator><![CDATA[Abhishek]]></dc:creator>
		<pubDate>Sat, 21 Sep 2013 13:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-27965</guid>
		<description><![CDATA[I agree. We don&#039;t need two 2 key arrays.
Inside the PrimMST function call :
while (pCrawl != NULL)
        {
..
key[v] = pCrawl-&#062;weight;
.....
decreaseKey(minHeap, v, key[v]);
}
}

We update the key values twice. 

key[v] =
as well as inside the decreaseKey() function call
minHeap-&#062;array[i]-&#062;key = key;

At any point of time, they will have equal values.]]></description>
		<content:encoded><![CDATA[<p>I agree. We don&#8217;t need two 2 key arrays.<br />
Inside the PrimMST function call :<br />
while (pCrawl != NULL)<br />
        {<br />
..<br />
key[v] = pCrawl-&gt;weight;<br />
&#8230;..<br />
decreaseKey(minHeap, v, key[v]);<br />
}<br />
}</p>
<p>We update the key values twice. </p>
<p>key[v] =<br />
as well as inside the decreaseKey() function call<br />
minHeap-&gt;array[i]-&gt;key = key;</p>
<p>At any point of time, they will have equal values.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Asap</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-22192</link>
		<dc:creator><![CDATA[Asap]]></dc:creator>
		<pubDate>Mon, 15 Jul 2013 14:23:04 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-22192</guid>
		<description><![CDATA[I think we dont need 2 key arrays.
Correct me if i am wrong.]]></description>
		<content:encoded><![CDATA[<p>I think we dont need 2 key arrays.<br />
Correct me if i am wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kumar Vikram</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-20406</link>
		<dc:creator><![CDATA[Kumar Vikram]]></dc:creator>
		<pubDate>Sun, 23 Jun 2013 06:08:41 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-20406</guid>
		<description><![CDATA[Another implementation using Adjancency list in c++.

[sourcecode language=&quot;C++&quot;]
#include&#060;iostream&#062;
#include &#060;list&#062;
#include &#060;limits.h&#062;

using namespace std;
 
class AdjListNode
{
    int v;
    int weight;
public:
    AdjListNode(int _v, int _w)  { v = _v;  weight = _w;}
    int getV()       {  return v;  }
    int getWeight()  {  return weight; }
};
 
class Graph
{
    int V;    // No. of vertices&#039;
    // Pointer to an array containing adjacency lists
    list&#060;AdjListNode&#062; *adj;
 
    
    public:
    Graph(int V);   // Constructor
 
    // function to add an edge to graph
    void addEdge(int u, int v, int weight);
    void prims_mst();
    void print_mst(int parent[]);
    int min_dist(int dist[],bool sptSet[]);
    
    
};
 
Graph::Graph(int V)
{
    this-&#062;V = V;
    adj = new list&#060;AdjListNode&#062;[V];
}
 
void Graph::addEdge(int u, int v, int weight)
{
    AdjListNode node(v, weight);
    adj[u].push_back(node); // Add v to u&#039;s list
}

int Graph::min_dist(int dist[],bool sptSet[])
{
	int min = INT_MAX, min_index;
 
   for (int v = 0; v &#060; V; v++)
     if (sptSet[v] == false &#038;&#038; dist[v] &#060;= min)
         min = dist[v], min_index = v;
 
   return min_index;
}

void Graph::print_mst(int parent[])
{
	cout&#060;&#060;&#034;edges in the MST are&#034;&#060;&#060;endl;
	for(int i=1;i&#060;V;i++)
		{
		cout&#060;&#060;parent[i]&#060;&#060;&#034;---&#034;&#060;&#060;i;
		cout&#060;&#060;endl;
		}
}

void Graph::prims_mst()
{
	int parent[V]; // Array to store constructed MST
     int key[V];   // Key values used to pick minimum weight edge in cut
     bool mstSet[V];  // To represent set of vertices not yet included in MST

     // Initialize all keys as INFINITE
     for (int i = 0; i &#060; V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

     // Always include first 1st vertex in MST.
     key[0] = 0;     // Make key 0 so that this vertex is picked as first vertex
     parent[0] = -1; // First node is always root of MST
	for(int v=0;v&#060;V;v++)
	{
		int u=min_dist(key,mstSet);
		mstSet[u]=true;
		list&#060;AdjListNode&#062;::iterator i;
		for(i=adj[u].begin();i!=adj[u].end();i++)
		{
			if(mstSet[i-&#062;getV()]==false &#038;&#038; i-&#062;getWeight() &#060; key[i-&#062;getV()])
				parent[i-&#062;getV()]=u,key[i-&#062;getV()]=i-&#062;getWeight();
		}
	}
	print_mst(parent);
}

int main()
{
    
    Graph g(9);
    g.addEdge(0, 1, 4);
    g.addEdge(1, 0, 4);
    g.addEdge(0, 7, 8);
    g.addEdge(7, 0, 8);
    g.addEdge(1, 2, 8);
    g.addEdge(2, 1, 8);
    g.addEdge(1, 7, 11);
    g.addEdge(7, 1, 11);
    g.addEdge(2, 3, 7);
    g.addEdge(3, 2, 7);
    g.addEdge(2, 8, 2);
    g.addEdge(8, 2, 2);
    g.addEdge(2, 5, 4);
    g.addEdge(5, 2, 4);
    g.addEdge(3, 4, 9);
    g.addEdge(4, 3, 9);
    g.addEdge(3, 5, 14);
    g.addEdge(5, 3, 14);
    g.addEdge(4, 5, 10);
    g.addEdge(5, 4, 10);
    g.addEdge(5, 6, 2);
    g.addEdge(6, 5, 2);
    g.addEdge(6, 7, 1);
    g.addEdge(7, 6, 1);
    g.addEdge(6, 8, 6);
    g.addEdge(8, 6, 6);
    g.addEdge(7, 8, 7);
    g.addEdge(8, 7, 7);
 
   
    g.prims_mst();
 
    return 0;
} 
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Another implementation using Adjancency list in c++.</p>
<p>#include&lt;iostream&gt;<br />
#include &lt;list&gt;<br />
#include &lt;limits.h&gt;</p>
<p>using namespace std;</p>
<p>class AdjListNode<br />
{<br />
    int v;<br />
    int weight;<br />
public:<br />
    AdjListNode(int _v, int _w)  { v = _v;  weight = _w;}<br />
    int getV()       {  return v;  }<br />
    int getWeight()  {  return weight; }<br />
};</p>
<p>class Graph<br />
{<br />
    int V;    // No. of vertices&#8217;<br />
    // Pointer to an array containing adjacency lists<br />
    list&lt;AdjListNode&gt; *adj;</p>
<p>    public:<br />
    Graph(int V);   // Constructor</p>
<p>    // function to add an edge to graph<br />
    void addEdge(int u, int v, int weight);<br />
    void prims_mst();<br />
    void print_mst(int parent[]);<br />
    int min_dist(int dist[],bool sptSet[]);</p>
<p>};</p>
<p>Graph::Graph(int V)<br />
{<br />
    this-&gt;V = V;<br />
    adj = new list&lt;AdjListNode&gt;[V];<br />
}</p>
<p>void Graph::addEdge(int u, int v, int weight)<br />
{<br />
    AdjListNode node(v, weight);<br />
    adj[u].push_back(node); // Add v to u&#8217;s list<br />
}</p>
<p>int Graph::min_dist(int dist[],bool sptSet[])<br />
{<br />
	int min = INT_MAX, min_index;</p>
<p>   for (int v = 0; v &lt; V; v++)<br />
     if (sptSet[v] == false &amp;&amp; dist[v] &lt;= min)<br />
         min = dist[v], min_index = v;</p>
<p>   return min_index;<br />
}</p>
<p>void Graph::print_mst(int parent[])<br />
{<br />
	cout&lt;&lt;&quot;edges in the MST are&quot;&lt;&lt;endl;<br />
	for(int i=1;i&lt;V;i++)<br />
		{<br />
		cout&lt;&lt;parent[i]&lt;&lt;&quot;&#8212;&quot;&lt;&lt;i;<br />
		cout&lt;&lt;endl;<br />
		}<br />
}</p>
<p>void Graph::prims_mst()<br />
{<br />
	int parent[V]; // Array to store constructed MST<br />
     int key[V];   // Key values used to pick minimum weight edge in cut<br />
     bool mstSet[V];  // To represent set of vertices not yet included in MST</p>
<p>     // Initialize all keys as INFINITE<br />
     for (int i = 0; i &lt; V; i++)<br />
        key[i] = INT_MAX, mstSet[i] = false;</p>
<p>     // Always include first 1st vertex in MST.<br />
     key[0] = 0;     // Make key 0 so that this vertex is picked as first vertex<br />
     parent[0] = -1; // First node is always root of MST<br />
	for(int v=0;v&lt;V;v++)<br />
	{<br />
		int u=min_dist(key,mstSet);<br />
		mstSet[u]=true;<br />
		list&lt;AdjListNode&gt;::iterator i;<br />
		for(i=adj[u].begin();i!=adj[u].end();i++)<br />
		{<br />
			if(mstSet[i-&gt;getV()]==false &amp;&amp; i-&gt;getWeight() &lt; key[i-&gt;getV()])<br />
				parent[i-&gt;getV()]=u,key[i-&gt;getV()]=i-&gt;getWeight();<br />
		}<br />
	}<br />
	print_mst(parent);<br />
}</p>
<p>int main()<br />
{</p>
<p>    Graph g(9);<br />
    g.addEdge(0, 1, 4);<br />
    g.addEdge(1, 0, 4);<br />
    g.addEdge(0, 7, 8);<br />
    g.addEdge(7, 0, 8);<br />
    g.addEdge(1, 2, 8);<br />
    g.addEdge(2, 1, 8);<br />
    g.addEdge(1, 7, 11);<br />
    g.addEdge(7, 1, 11);<br />
    g.addEdge(2, 3, 7);<br />
    g.addEdge(3, 2, 7);<br />
    g.addEdge(2, 8, 2);<br />
    g.addEdge(8, 2, 2);<br />
    g.addEdge(2, 5, 4);<br />
    g.addEdge(5, 2, 4);<br />
    g.addEdge(3, 4, 9);<br />
    g.addEdge(4, 3, 9);<br />
    g.addEdge(3, 5, 14);<br />
    g.addEdge(5, 3, 14);<br />
    g.addEdge(4, 5, 10);<br />
    g.addEdge(5, 4, 10);<br />
    g.addEdge(5, 6, 2);<br />
    g.addEdge(6, 5, 2);<br />
    g.addEdge(6, 7, 1);<br />
    g.addEdge(7, 6, 1);<br />
    g.addEdge(6, 8, 6);<br />
    g.addEdge(8, 6, 6);<br />
    g.addEdge(7, 8, 7);<br />
    g.addEdge(8, 7, 7);</p>
<p>    g.prims_mst();</p>
<p>    return 0;<br />
} </p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jaskaran1</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-19522</link>
		<dc:creator><![CDATA[jaskaran1]]></dc:creator>
		<pubDate>Mon, 10 Jun 2013 20:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-19522</guid>
		<description><![CDATA[Coded up a shorter implementation using STL and found another MST
0-1
1-2
2-8
2-5
5-6
6-7
2-3
3-4


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Coded up a shorter implementation using STL and found another MST<br />
0-1<br />
1-2<br />
2-8<br />
2-5<br />
5-6<br />
6-7<br />
2-3<br />
3-4</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sandeep Jain</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-26283</link>
		<dc:creator><![CDATA[Sandeep Jain]]></dc:creator>
		<pubDate>Wed, 08 May 2013 02:06:58 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-26283</guid>
		<description><![CDATA[Parent value -1 indicates root of MST.  There should be only one -1 for a connected undirected graph..  If the graph is disconnected, then output is a forest (more than one -1 values)]]></description>
		<content:encoded><![CDATA[<p>Parent value -1 indicates root of MST.  There should be only one -1 for a connected undirected graph..  If the graph is disconnected, then output is a forest (more than one -1 values)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Somnath Dutta</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-26282</link>
		<dc:creator><![CDATA[Somnath Dutta]]></dc:creator>
		<pubDate>Tue, 07 May 2013 06:03:39 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-26282</guid>
		<description><![CDATA[I am using the code to build a mst having around 300 vertices but some of the values of parent array has value -1, iam confused , can anybody suggest me something?]]></description>
		<content:encoded><![CDATA[<p>I am using the code to build a mst having around 300 vertices but some of the values of parent array has value -1, iam confused , can anybody suggest me something?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pushkar</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-12808</link>
		<dc:creator><![CDATA[Pushkar]]></dc:creator>
		<pubDate>Fri, 23 Nov 2012 09:09:08 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-12808</guid>
		<description><![CDATA[it needs programming skills :)]]></description>
		<content:encoded><![CDATA[<p>it needs programming skills ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: golu</title>
		<link>http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/#comment-12807</link>
		<dc:creator><![CDATA[golu]]></dc:creator>
		<pubDate>Fri, 23 Nov 2012 08:47:21 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=27580#comment-12807</guid>
		<description><![CDATA[i tried so many times to implement it, but failed

it really needs courage to write such a program]]></description>
		<content:encoded><![CDATA[<p>i tried so many times to implement it, but failed</p>
<p>it really needs courage to write such a program</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.045 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 12:41:01 -->

<!-- Compression = gzip -->