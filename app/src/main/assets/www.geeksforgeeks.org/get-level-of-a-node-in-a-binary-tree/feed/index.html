<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Get Level of a node in a Binary Tree</title>
	<atom:link href="http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-39192</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 19:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-39192</guid>
		<description><![CDATA[in searching , the search stops once the node to be searched is found but in this case , every node has to be visited so simply , t(n) will be O(n) only...]]></description>
		<content:encoded><![CDATA[<p>in searching , the search stops once the node to be searched is found but in this case , every node has to be visited so simply , t(n) will be O(n) only&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Uma Trika</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-30957</link>
		<dc:creator><![CDATA[Uma Trika]]></dc:creator>
		<pubDate>Mon, 23 Dec 2013 12:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-30957</guid>
		<description><![CDATA[void getLevelUtil(struct node *node, int h, int *level, int key)
{
        if(node == NULL)
        return ;

        if(node-&#062;data == key)
        {
                *level = h ;
        }

        getLevelUtil(node-&#062;left, h+1, level, key);
        getLevelUtil(node-&#062;right, h+1, level, key);
}]]></description>
		<content:encoded><![CDATA[<p>void getLevelUtil(struct node *node, int h, int *level, int key)<br />
{<br />
        if(node == NULL)<br />
        return ;</p>
<p>        if(node-&gt;data == key)<br />
        {<br />
                *level = h ;<br />
        }</p>
<p>        getLevelUtil(node-&gt;left, h+1, level, key);<br />
        getLevelUtil(node-&gt;right, h+1, level, key);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Pranav</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-30851</link>
		<dc:creator><![CDATA[Pranav]]></dc:creator>
		<pubDate>Thu, 19 Dec 2013 06:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-30851</guid>
		<description><![CDATA[Its O(n) because if you look closely you will find that getLevelUtil() first check for current node, than left sub tree and finally right sub  tree.
So every node is visited exactly once.]]></description>
		<content:encoded><![CDATA[<p>Its O(n) because if you look closely you will find that getLevelUtil() first check for current node, than left sub tree and finally right sub  tree.<br />
So every node is visited exactly once.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: hhh</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-30578</link>
		<dc:creator><![CDATA[hhh]]></dc:creator>
		<pubDate>Mon, 09 Dec 2013 08:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-30578</guid>
		<description><![CDATA[I think it is O(n*logn) - getLevelUntil is O(logn) and when we run it for each element in an array, total execution time will be O(n*logn)]]></description>
		<content:encoded><![CDATA[<p>I think it is O(n*logn) &#8211; getLevelUntil is O(logn) and when we run it for each element in an array, total execution time will be O(n*logn)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: DarkProtocol</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-28676</link>
		<dc:creator><![CDATA[DarkProtocol]]></dc:creator>
		<pubDate>Thu, 10 Oct 2013 18:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-28676</guid>
		<description><![CDATA[How is this T(n)= O(n)... it basically does searching and which should be O(logn).. Any inputs or ideas?]]></description>
		<content:encoded><![CDATA[<p>How is this T(n)= O(n)&#8230; it basically does searching and which should be O(logn).. Any inputs or ideas?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: cool_dude</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-28330</link>
		<dc:creator><![CDATA[cool_dude]]></dc:creator>
		<pubDate>Tue, 01 Oct 2013 18:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-28330</guid>
		<description><![CDATA[&lt;code&gt;

#include
#include


struct node 
{
struct node *left;
struct node *right;
int data;
};

struct node *create_node(int num)
{
struct node *temp=(struct node*)malloc(sizeof(struct node ));
temp-&#062;left=NULL;
temp-&#062;right=NULL;
temp-&#062;data=num;
return temp;
}

void level(struct node *tree,int num,int h,int *i)
{
if(tree==NULL) return;


	level(tree-&#062;left,num,h+1,i);

	if(tree-&#062;data==num)
	{
	printf(&quot;level=%d &quot;,h);
	*i=1;
	}
level(tree-&#062;right,num,h+1,i);

	

}

int main()
{
struct node *tree;
tree=create_node(5);
tree-&#062;left=create_node(4);
tree-&#062;right=create_node(7);
tree-&#062;left-&#062;left=create_node(6);
tree-&#062;left-&#062;right=create_node(3);
tree-&#062;right-&#062;right=create_node(9);


int h=1, i=0;
level(tree,2,h,&#038;i);


if(i==0)
printf(&quot;level=0&quot;);

	return 0;

}

&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p><code></p>
<p>#include<br />
#include</p>
<p>struct node<br />
{<br />
struct node *left;<br />
struct node *right;<br />
int data;<br />
};</p>
<p>struct node *create_node(int num)<br />
{<br />
struct node *temp=(struct node*)malloc(sizeof(struct node ));<br />
temp-&gt;left=NULL;<br />
temp-&gt;right=NULL;<br />
temp-&gt;data=num;<br />
return temp;<br />
}</p>
<p>void level(struct node *tree,int num,int h,int *i)<br />
{<br />
if(tree==NULL) return;</p>
<p>	level(tree-&gt;left,num,h+1,i);</p>
<p>	if(tree-&gt;data==num)<br />
	{<br />
	printf("level=%d ",h);<br />
	*i=1;<br />
	}<br />
level(tree-&gt;right,num,h+1,i);</p>
<p>}</p>
<p>int main()<br />
{<br />
struct node *tree;<br />
tree=create_node(5);<br />
tree-&gt;left=create_node(4);<br />
tree-&gt;right=create_node(7);<br />
tree-&gt;left-&gt;left=create_node(6);<br />
tree-&gt;left-&gt;right=create_node(3);<br />
tree-&gt;right-&gt;right=create_node(9);</p>
<p>int h=1, i=0;<br />
level(tree,2,h,&amp;i);</p>
<p>if(i==0)<br />
printf("level=0");</p>
<p>	return 0;</p>
<p>}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: cool_dude</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-28329</link>
		<dc:creator><![CDATA[cool_dude]]></dc:creator>
		<pubDate>Tue, 01 Oct 2013 18:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-28329</guid>
		<description><![CDATA[#include

#include

struct node 

{

	struct node *left;

	struct node *right;

	int data;

};

struct node *create_node(int num)

{

	struct node *temp=(struct node*)malloc(sizeof(struct node ));

	temp-&#062;left=NULL;

	temp-&#062;right=NULL;

	temp-&#062;data=num;

	return temp;

}

void level(struct node *tree,int num,int h,int *i)

{

	

	if(tree==NULL)

	return;

	

	level(tree-&#062;left,num,h+1,i);

	if(tree-&#062;data==num)

	{

	printf(&quot;level=%d &quot;,h);

	*i=1;

	}

	level(tree-&#062;right,num,h+1,i);

	

}

int main()

{

	struct node *tree;

	tree=create_node(5);

	tree-&#062;left=create_node(4);

	tree-&#062;right=create_node(7);

	tree-&#062;left-&#062;left=create_node(6);

	tree-&#062;left-&#062;right=create_node(3);

    tree-&#062;right-&#062;right=create_node(9);

	int h=1;

	int i=0;

	level(tree,2,h,&#038;i);

	if(i==0)

	printf(&quot;level=0&quot;);

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>#include</p>
<p>#include</p>
<p>struct node </p>
<p>{</p>
<p>	struct node *left;</p>
<p>	struct node *right;</p>
<p>	int data;</p>
<p>};</p>
<p>struct node *create_node(int num)</p>
<p>{</p>
<p>	struct node *temp=(struct node*)malloc(sizeof(struct node ));</p>
<p>	temp-&gt;left=NULL;</p>
<p>	temp-&gt;right=NULL;</p>
<p>	temp-&gt;data=num;</p>
<p>	return temp;</p>
<p>}</p>
<p>void level(struct node *tree,int num,int h,int *i)</p>
<p>{</p>
<p>	if(tree==NULL)</p>
<p>	return;</p>
<p>	level(tree-&gt;left,num,h+1,i);</p>
<p>	if(tree-&gt;data==num)</p>
<p>	{</p>
<p>	printf(&#8220;level=%d &#8220;,h);</p>
<p>	*i=1;</p>
<p>	}</p>
<p>	level(tree-&gt;right,num,h+1,i);</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>	struct node *tree;</p>
<p>	tree=create_node(5);</p>
<p>	tree-&gt;left=create_node(4);</p>
<p>	tree-&gt;right=create_node(7);</p>
<p>	tree-&gt;left-&gt;left=create_node(6);</p>
<p>	tree-&gt;left-&gt;right=create_node(3);</p>
<p>    tree-&gt;right-&gt;right=create_node(9);</p>
<p>	int h=1;</p>
<p>	int i=0;</p>
<p>	level(tree,2,h,&amp;i);</p>
<p>	if(i==0)</p>
<p>	printf(&#8220;level=0&#8221;);</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: aditya</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-27963</link>
		<dc:creator><![CDATA[aditya]]></dc:creator>
		<pubDate>Sat, 21 Sep 2013 10:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-27963</guid>
		<description><![CDATA[this is not  a bst]]></description>
		<content:encoded><![CDATA[<p>this is not  a bst</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vandal</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-27245</link>
		<dc:creator><![CDATA[Vandal]]></dc:creator>
		<pubDate>Sun, 01 Sep 2013 12:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-27245</guid>
		<description><![CDATA[/* A much simpler Implementation  It returns 0 if key not found*/





int keyLevel(int key, tNode* n, int count)
{

    if(n == NULL)
        return 0;
    
    if( n-&#062;data == key)
        return count;
    else
    {
        return max(keyLevel(key, n-&#062;left, count+1), keyLevel(key, n-&#062;right, count+1));
        
    }
            
}]]></description>
		<content:encoded><![CDATA[<p>/* A much simpler Implementation  It returns 0 if key not found*/</p>
<p>int keyLevel(int key, tNode* n, int count)<br />
{</p>
<p>    if(n == NULL)<br />
        return 0;</p>
<p>    if( n-&gt;data == key)<br />
        return count;<br />
    else<br />
    {<br />
        return max(keyLevel(key, n-&gt;left, count+1), keyLevel(key, n-&gt;right, count+1));</p>
<p>    }</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-21613</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Sun, 07 Jul 2013 09:07:46 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-21613</guid>
		<description><![CDATA[@Sunil: We have updated the code to avoid confusion. 

The bitwise or was used to return integer value, rather than boolean value. Please note that the old code also works for trees with all distinct keys, but may fail for same key in left and right subtree. 
Following is old code for record.

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;

/* A tree node structure */
struct node
{
  int data;
  struct node *left;
  struct node *right;
};

/*
   Helper function for getLevel().  It returns level of the data if data is
   present in tree, otherwise returns 0.
*/
int getLevelUtil(struct node *node, int data, int level)
{
  if ( node == NULL )
    return 0;

  if ( node-&#062;data == data )
    return level;

  return getLevelUtil ( node-&#062;left, data, level+1) &#124;
         getLevelUtil ( node-&#062;right, data, level+1);
}

/* Returns level of given data value */
int getLevel(struct node *node, int data)
{
  return getLevelUtil(node,data,1);
}

/* Utility function to create a new Binary Tree node */
struct node* newNode(int data)
{
  struct node *temp = new struct node;
  temp-&#062;data = data;
  temp-&#062;left = NULL;
  temp-&#062;right = NULL;

  return temp;
}

/* Driver function to test above functions */
int main()
{
  struct node *root = new struct node;
  int x;

  /* Constructing tree given in the above figure */
  root = newNode(3);
  root-&#062;left = newNode(2);
  root-&#062;right = newNode(5);
  root-&#062;left-&#062;left = newNode(1);
  root-&#062;left-&#062;right = newNode(4);

  x = 3;
  printf(&#034; Level of %d is %d&#034;, x, getLevel(root, x));

  x = 4;
  printf(&#034;\n Level of %d is %d&#034;, x, getLevel(root, x));

  getchar();
  return 0;
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>@Sunil: We have updated the code to avoid confusion. </p>
<p>The bitwise or was used to return integer value, rather than boolean value. Please note that the old code also works for trees with all distinct keys, but may fail for same key in left and right subtree.<br />
Following is old code for record.</p>
<pre> <code language="C">
#include&lt;stdio.h&gt;

/* A tree node structure */
struct node
{
  int data;
  struct node *left;
  struct node *right;
};

/*
   Helper function for getLevel().  It returns level of the data if data is
   present in tree, otherwise returns 0.
*/
int getLevelUtil(struct node *node, int data, int level)
{
  if ( node == NULL )
    return 0;

  if ( node-&gt;data == data )
    return level;

  return getLevelUtil ( node-&gt;left, data, level+1) |
         getLevelUtil ( node-&gt;right, data, level+1);
}

/* Returns level of given data value */
int getLevel(struct node *node, int data)
{
  return getLevelUtil(node,data,1);
}

/* Utility function to create a new Binary Tree node */
struct node* newNode(int data)
{
  struct node *temp = new struct node;
  temp-&gt;data = data;
  temp-&gt;left = NULL;
  temp-&gt;right = NULL;

  return temp;
}

/* Driver function to test above functions */
int main()
{
  struct node *root = new struct node;
  int x;

  /* Constructing tree given in the above figure */
  root = newNode(3);
  root-&gt;left = newNode(2);
  root-&gt;right = newNode(5);
  root-&gt;left-&gt;left = newNode(1);
  root-&gt;left-&gt;right = newNode(4);

  x = 3;
  printf(&quot; Level of %d is %d&quot;, x, getLevel(root, x));

  x = 4;
  printf(&quot;\n Level of %d is %d&quot;, x, getLevel(root, x));

  getchar();
  return 0;
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sunil</title>
		<link>http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/#comment-21612</link>
		<dc:creator><![CDATA[Sunil]]></dc:creator>
		<pubDate>Sun, 07 Jul 2013 08:35:25 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=10962#comment-21612</guid>
		<description><![CDATA[Why is a bitwise or used instead of logical or in  the following line?
return getLevelUtil ( node-&#062;left, data, level+1) &#124;
         getLevelUtil ( node-&#062;right, data, level+1);

I compiled the program using &#039;logical or&#039; for input=4 with the same binary tree, I get level=1 as the output.]]></description>
		<content:encoded><![CDATA[<p>Why is a bitwise or used instead of logical or in  the following line?<br />
return getLevelUtil ( node-&gt;left, data, level+1) |<br />
         getLevelUtil ( node-&gt;right, data, level+1);</p>
<p>I compiled the program using &#8216;logical or&#8217; for input=4 with the same binary tree, I get level=1 as the output.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.077 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:35 -->

<!-- Compression = gzip -->