<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Lexicographic rank of a string</title>
	<atom:link href="http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-39033</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 10:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-39033</guid>
		<description><![CDATA[How to include duplicates?]]></description>
		<content:encoded><![CDATA[<p>How to include duplicates?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: toughtimes</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-38863</link>
		<dc:creator><![CDATA[toughtimes]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 17:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-38863</guid>
		<description><![CDATA[same for 2nd method also..since we have the constraint that max no. of character are 256in a string(as all characters are diff) so n*256 is the ans....basically the length cant be more than 256...and hence both method have same complexity]]></description>
		<content:encoded><![CDATA[<p>same for 2nd method also..since we have the constraint that max no. of character are 256in a string(as all characters are diff) so n*256 is the ans&#8230;.basically the length cant be more than 256&#8230;and hence both method have same complexity</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul kr patel</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-33895</link>
		<dc:creator><![CDATA[Rahul kr patel]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 19:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-33895</guid>
		<description><![CDATA[for only non-repeated char]]></description>
		<content:encoded><![CDATA[<p>for only non-repeated char</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul kr patel</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-33893</link>
		<dc:creator><![CDATA[Rahul kr patel]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 19:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-33893</guid>
		<description><![CDATA[#include
#include  
#include
using namespace std;
char data[18],ch;
int smallest(char *copy)
{
    
     unsigned long int fact[]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200}; 
     int len=strlen(copy);
     int c=0,i=0,j=0,c1=0,sum=0;
     while(copy[i]!=&#039;&#039;)
     {
          j=i;
          while(data[j]!=&#039;&#039;)
          {
                     if(data[i]&#062;data[j])
                    c++;
                  j++; 
           }
           int a=len-++c1;
           sum+=c*fact[a];
           c=0;
           i++;
     }     
     cout&#060;&#062;data;
    smallest(data);    
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
using namespace std;<br />
char data[18],ch;<br />
int smallest(char *copy)<br />
{</p>
<p>     unsigned long int fact[]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200};<br />
     int len=strlen(copy);<br />
     int c=0,i=0,j=0,c1=0,sum=0;<br />
     while(copy[i]!=&#8221;)<br />
     {<br />
          j=i;<br />
          while(data[j]!=&#8221;)<br />
          {<br />
                     if(data[i]&gt;data[j])<br />
                    c++;<br />
                  j++;<br />
           }<br />
           int a=len-++c1;<br />
           sum+=c*fact[a];<br />
           c=0;<br />
           i++;<br />
     }<br />
     cout&lt;&gt;data;<br />
    smallest(data);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul kr patel</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-33892</link>
		<dc:creator><![CDATA[Rahul kr patel]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 19:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-33892</guid>
		<description><![CDATA[only for non-repeated char]]></description>
		<content:encoded><![CDATA[<p>only for non-repeated char</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul kr patel</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-33891</link>
		<dc:creator><![CDATA[Rahul kr patel]]></dc:creator>
		<pubDate>Wed, 26 Mar 2014 19:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-33891</guid>
		<description><![CDATA[#include
#include
char data[18],ch;
int smallest(char *copy)
{
    int hash[60]={0,0};
    unsigned long long fact[]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000};
 int 
 len=strlen(copy);
     int c=0,i=0,j=0,c1=0,sum=0;
     while(copy[i]!=&#039;&#039;)
     {
         hash[copy[i]]++;         
          j=i;
          while(data[j]!=&#039;&#039;)
          {
                     if(data[i]&#062;data[j])
                      c++;
                    j++; 
           }
           int a=len-++c1;
           sum+=c*fact[a];
           c=0;
           i++;
     }
     int s=0;
   /* for(int i=48;i1)
          {
              s+=fact[hash[i]];
          }
    } 
    s=++sum/s;*/
     printf(&quot;%dn&quot;,sum);
}
int main()
{
  int t;
  scanf(&quot;%d&quot;,&#038;t);
 while(t--)
  {     
     scanf(&quot;%s&quot;,data);
     smallest(data);    
    
  }
   return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
char data[18],ch;<br />
int smallest(char *copy)<br />
{<br />
    int hash[60]={0,0};<br />
    unsigned long long fact[]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000};<br />
 int<br />
 len=strlen(copy);<br />
     int c=0,i=0,j=0,c1=0,sum=0;<br />
     while(copy[i]!=&#8221;)<br />
     {<br />
         hash[copy[i]]++;<br />
          j=i;<br />
          while(data[j]!=&#8221;)<br />
          {<br />
                     if(data[i]&gt;data[j])<br />
                      c++;<br />
                    j++;<br />
           }<br />
           int a=len-++c1;<br />
           sum+=c*fact[a];<br />
           c=0;<br />
           i++;<br />
     }<br />
     int s=0;<br />
   /* for(int i=48;i1)<br />
          {<br />
              s+=fact[hash[i]];<br />
          }<br />
    }<br />
    s=++sum/s;*/<br />
     printf(&#8220;%dn&#8221;,sum);<br />
}<br />
int main()<br />
{<br />
  int t;<br />
  scanf(&#8220;%d&#8221;,&amp;t);<br />
 while(t&#8211;)<br />
  {<br />
     scanf(&#8220;%s&#8221;,data);<br />
     smallest(data);    </p>
<p>  }<br />
   return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: alien</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-33554</link>
		<dc:creator><![CDATA[alien]]></dc:creator>
		<pubDate>Sat, 15 Mar 2014 23:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-33554</guid>
		<description><![CDATA[The logic for finding mul is very good..]]></description>
		<content:encoded><![CDATA[<p>The logic for finding mul is very good..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Javed</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-30900</link>
		<dc:creator><![CDATA[Javed]]></dc:creator>
		<pubDate>Sat, 21 Dec 2013 08:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-30900</guid>
		<description><![CDATA[MAX_CHAR doesnt depend on the length of the input string, its a constant which is 256. So the complexity is O(n) only.]]></description>
		<content:encoded><![CDATA[<p>MAX_CHAR doesnt depend on the length of the input string, its a constant which is 256. So the complexity is O(n) only.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: codKaichu</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-30237</link>
		<dc:creator><![CDATA[codKaichu]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 23:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-30237</guid>
		<description><![CDATA[how is updateCount not O(n^2) and linear instead. It goes from i=ch to MaxArray for over n times]]></description>
		<content:encoded><![CDATA[<p>how is updateCount not O(n^2) and linear instead. It goes from i=ch to MaxArray for over n times</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anand Mohan Sinha</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-29535</link>
		<dc:creator><![CDATA[Anand Mohan Sinha]]></dc:creator>
		<pubDate>Mon, 04 Nov 2013 04:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-29535</guid>
		<description><![CDATA[to put number of elements smaller than i in count[i]]]></description>
		<content:encoded><![CDATA[<p>to put number of elements smaller than i in count[i]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: George</title>
		<link>http://www.geeksforgeeks.org/lexicographic-rank-of-a-string/#comment-28889</link>
		<dc:creator><![CDATA[George]]></dc:creator>
		<pubDate>Tue, 15 Oct 2013 07:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24899#comment-28889</guid>
		<description><![CDATA[A small mistake in the brute force solution. Time complexity will be factorial, not exponential.]]></description>
		<content:encoded><![CDATA[<p>A small mistake in the brute force solution. Time complexity will be factorial, not exponential.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.051 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:10:38 -->

<!-- Compression = gzip -->