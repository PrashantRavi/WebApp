<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 16 (Floyd Warshall Algorithm)</title>
	<atom:link href="http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-37823</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Sat, 07 Jun 2014 10:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-37823</guid>
		<description><![CDATA[apart from apsp floyd warshal can be used as
-bipartite checking
-maximin and minimax path
-transitive closure]]></description>
		<content:encoded><![CDATA[<p>apart from apsp floyd warshal can be used as<br />
-bipartite checking<br />
-maximin and minimax path<br />
-transitive closure</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ankunath</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-36862</link>
		<dc:creator><![CDATA[ankunath]]></dc:creator>
		<pubDate>Mon, 26 May 2014 09:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-36862</guid>
		<description><![CDATA[my code for the optimal solution of this is

http://ideone.com/e.js/b44uZQ]]></description>
		<content:encoded><![CDATA[<p>my code for the optimal solution of this is</p>
<p><a href="http://ideone.com/e.js/b44uZQ" rel="nofollow">http://ideone.com/e.js/b44uZQ</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: natalcoder</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-36115</link>
		<dc:creator><![CDATA[natalcoder]]></dc:creator>
		<pubDate>Fri, 16 May 2014 07:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-36115</guid>
		<description><![CDATA[&quot;We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix&quot;. I&#039;m a little confused here, what to store in the matrix and how to process that matrix in order to get the shortest path?
Thanks!]]></description>
		<content:encoded><![CDATA[<p>&#8220;We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix&#8221;. I&#8217;m a little confused here, what to store in the matrix and how to process that matrix in order to get the shortest path?<br />
Thanks!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-35868</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Sat, 10 May 2014 11:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-35868</guid>
		<description><![CDATA[its a bottom up dynamaic programming ques
there is two possibility for a path to exist between vertex i and j using intermediate vertex 0,1,2,,,,,k 
1- using intermediate vertices 0,1,2....k-1  ie excluding k
2-including k as intermediate vertex ie path from i to k and k to j 
D[I][J]=MIN (P[I][J],P[I][K]+P[K][J]) where p one level low matrix thn d 
create D0,D1,D2,,,,D(n-1) recursively and fill the entries
D(n-1) is the resultant matrix]]></description>
		<content:encoded><![CDATA[<p>its a bottom up dynamaic programming ques<br />
there is two possibility for a path to exist between vertex i and j using intermediate vertex 0,1,2,,,,,k<br />
1- using intermediate vertices 0,1,2&#8230;.k-1  ie excluding k<br />
2-including k as intermediate vertex ie path from i to k and k to j<br />
D[I][J]=MIN (P[I][J],P[I][K]+P[K][J]) where p one level low matrix thn d<br />
create D0,D1,D2,,,,D(n-1) recursively and fill the entries<br />
D(n-1) is the resultant matrix</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-35867</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Sat, 10 May 2014 11:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-35867</guid>
		<description><![CDATA[#include
#define n 5
#define infinity 9999
#define max 20
#define temp 0
#define size 50
int adj[max][max];
int dist[max][max];
int status[max];
using namespace std;
struct queue
{
	int front;
	int rear;
	int arr[size];
	void insert(int);
	int del();
	queue();
}q;
queue::queue()
{
	front=-1;
	rear=-1;
}
int queue::del()
{
 
	if(front!=-1)
	{
		int f=arr[front];
		if(front==rear)
		{
			front=-1;
			rear=-1;
		}
		else
		{
		  front=(front+1)%size;
	    }
		return f;
   }
 
}
void queue::insert(int f)
{
	   rear=(rear+1)%size;
	   arr[rear]=f;
	   if(front==-1)
	     front=0;	   
}
void floyd_warshal(int k)
{
	for(int i=0;i&#060;n;i++)
		{
			for(int j=0;j&#060;n;j++)
			{
				dist[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);
			}
		}
}
int main()
{ 
    int time=0;int v1,v2,wt,vi;
	int m=n*(n-1);
	for(int i=0;i&#060;n;i++)
	{
		for(int j=0;j&#060;n;j++)
		{
			adj[i][j]=infinity;
		}
	}
	for(int i=0;i&#060;m;i++)
	{
		cout&#060;&#062;v1&#062;&#062;v2&#062;&#062;wt;
		if((v1==-1)&#038;&#038;(v2==-1))
		   break;
		adj[v1][v2]=wt;
	}
	for(int i=0;i&#060;n;i++)
	{
		floyd_warshal(i);
		for(int i=0;i&#060;n;i++)
		{
			for(int j=0;j&#060;n;j++)
			{
				adj[i][j]=dist[i][j];
			}
		}
	}
	for(int i=0;i&#060;n;i++)
		{
			for(int j=0;j&#060;n;j++)
			{
				if(dist[i][j]==infinity)
				  cout&#060;&#060;&#034;null&#034;&#060;&#060;&#034; &#034;;
				else
				cout&#060;&#060;dist[i][j]&#060;&#060;&#034; &#034;;
			}
			cout&#060;&#060;&#034;n&#034;;
		}
		return 0;
    }]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#define n 5<br />
#define infinity 9999<br />
#define max 20<br />
#define temp 0<br />
#define size 50<br />
int adj[max][max];<br />
int dist[max][max];<br />
int status[max];<br />
using namespace std;<br />
struct queue<br />
{<br />
	int front;<br />
	int rear;<br />
	int arr[size];<br />
	void insert(int);<br />
	int del();<br />
	queue();<br />
}q;<br />
queue::queue()<br />
{<br />
	front=-1;<br />
	rear=-1;<br />
}<br />
int queue::del()<br />
{</p>
<p>	if(front!=-1)<br />
	{<br />
		int f=arr[front];<br />
		if(front==rear)<br />
		{<br />
			front=-1;<br />
			rear=-1;<br />
		}<br />
		else<br />
		{<br />
		  front=(front+1)%size;<br />
	    }<br />
		return f;<br />
   }</p>
<p>}<br />
void queue::insert(int f)<br />
{<br />
	   rear=(rear+1)%size;<br />
	   arr[rear]=f;<br />
	   if(front==-1)<br />
	     front=0;<br />
}<br />
void floyd_warshal(int k)<br />
{<br />
	for(int i=0;i&lt;n;i++)<br />
		{<br />
			for(int j=0;j&lt;n;j++)<br />
			{<br />
				dist[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);<br />
			}<br />
		}<br />
}<br />
int main()<br />
{<br />
    int time=0;int v1,v2,wt,vi;<br />
	int m=n*(n-1);<br />
	for(int i=0;i&lt;n;i++)<br />
	{<br />
		for(int j=0;j&lt;n;j++)<br />
		{<br />
			adj[i][j]=infinity;<br />
		}<br />
	}<br />
	for(int i=0;i&lt;m;i++)<br />
	{<br />
		cout&lt;&gt;v1&gt;&gt;v2&gt;&gt;wt;<br />
		if((v1==-1)&amp;&amp;(v2==-1))<br />
		   break;<br />
		adj[v1][v2]=wt;<br />
	}<br />
	for(int i=0;i&lt;n;i++)<br />
	{<br />
		floyd_warshal(i);<br />
		for(int i=0;i&lt;n;i++)<br />
		{<br />
			for(int j=0;j&lt;n;j++)<br />
			{<br />
				adj[i][j]=dist[i][j];<br />
			}<br />
		}<br />
	}<br />
	for(int i=0;i&lt;n;i++)<br />
		{<br />
			for(int j=0;j&lt;n;j++)<br />
			{<br />
				if(dist[i][j]==infinity)<br />
				  cout&lt;&lt;&quot;null&quot;&lt;&lt;&quot; &quot;;<br />
				else<br />
				cout&lt;&lt;dist[i][j]&lt;&lt;&quot; &quot;;<br />
			}<br />
			cout&lt;&lt;&quot;n&quot;;<br />
		}<br />
		return 0;<br />
    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mohamad</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-34463</link>
		<dc:creator><![CDATA[Mohamad]]></dc:creator>
		<pubDate>Tue, 08 Apr 2014 09:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-34463</guid>
		<description><![CDATA[Hey guys,

Here&#039;s an implementation of Floyd-Warshall algorithm in C++ which finds the minimum weights along with the actual paths

http://cs-and-design.blogspot.com/2014/04/floyd-warshall-algorithm.html]]></description>
		<content:encoded><![CDATA[<p>Hey guys,</p>
<p>Here&#8217;s an implementation of Floyd-Warshall algorithm in C++ which finds the minimum weights along with the actual paths</p>
<p><a href="http://cs-and-design.blogspot.com/2014/04/floyd-warshall-algorithm.html" rel="nofollow">http://cs-and-design.blogspot.com/2014/04/floyd-warshall-algorithm.html</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: h</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-33698</link>
		<dc:creator><![CDATA[h]]></dc:creator>
		<pubDate>Thu, 20 Mar 2014 14:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-33698</guid>
		<description><![CDATA[that is just an LCS problem . find out LCS . if LCS== length of array. then anagram]]></description>
		<content:encoded><![CDATA[<p>that is just an LCS problem . find out LCS . if LCS== length of array. then anagram</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nickpsar</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-32906</link>
		<dc:creator><![CDATA[nickpsar]]></dc:creator>
		<pubDate>Sun, 23 Feb 2014 19:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-32906</guid>
		<description><![CDATA[thanks guys!!! 

now with this example i can say that i finally managed to fill up all the blanks about floyd warshall algorithm. But............hmm

How can modify the code If i want in the solution graph to change all the distances up to 2 with 1 and all the other with 0 (sorry i forgot to say that my graph has weight 1 for each edge) ?]]></description>
		<content:encoded><![CDATA[<p>thanks guys!!! </p>
<p>now with this example i can say that i finally managed to fill up all the blanks about floyd warshall algorithm. But&#8230;&#8230;&#8230;&#8230;hmm</p>
<p>How can modify the code If i want in the solution graph to change all the distances up to 2 with 1 and all the other with 0 (sorry i forgot to say that my graph has weight 1 for each edge) ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sanidhya</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-30230</link>
		<dc:creator><![CDATA[Sanidhya]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 17:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-30230</guid>
		<description><![CDATA[Can you please code one to find the actual path taken by the above algorithm to calculate the shortest path, need it to implement Chinese Postman]]></description>
		<content:encoded><![CDATA[<p>Can you please code one to find the actual path taken by the above algorithm to calculate the shortest path, need it to implement Chinese Postman</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kartik</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-29754</link>
		<dc:creator><![CDATA[kartik]]></dc:creator>
		<pubDate>Mon, 11 Nov 2013 08:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-29754</guid>
		<description><![CDATA[Yes, you can get path.  You need to maintain chosen k in a separate 2D array.]]></description>
		<content:encoded><![CDATA[<p>Yes, you can get path.  You need to maintain chosen k in a separate 2D array.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: praveen</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/#comment-29749</link>
		<dc:creator><![CDATA[praveen]]></dc:creator>
		<pubDate>Mon, 11 Nov 2013 05:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=19772#comment-29749</guid>
		<description><![CDATA[can i get the path by this algorithm]]></description>
		<content:encoded><![CDATA[<p>can i get the path by this algorithm</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:09 -->

<!-- Compression = gzip -->