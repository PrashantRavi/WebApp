<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Lowest Common Ancestor in a Binary Tree &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: MK</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-39771</link>
		<dc:creator><![CDATA[MK]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 11:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-39771</guid>
		<description><![CDATA[Why is this necessary in 3rd method?

v1 &#038;&#038; find(lca, n2) &#124;&#124; v2 &#038;&#038; find(lca, n1)   ( in if condition at last)



Is it not enough to check v1&#038;&#038;v2 ??]]></description>
		<content:encoded><![CDATA[<p>Why is this necessary in 3rd method?</p>
<p>v1 &amp;&amp; find(lca, n2) || v2 &amp;&amp; find(lca, n1)   ( in if condition at last)</p>
<p>Is it not enough to check v1&amp;&amp;v2 ??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Programmer</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-39277</link>
		<dc:creator><![CDATA[Programmer]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 17:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-39277</guid>
		<description><![CDATA[Logicaly we are doing post order traversal]]></description>
		<content:encoded><![CDATA[<p>Logicaly we are doing post order traversal</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Programmer</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-39276</link>
		<dc:creator><![CDATA[Programmer]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 17:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-39276</guid>
		<description><![CDATA[How many times node visited of tree...
Means linear time. or .polynomial time...
Here we visit tree node only once so O(n) time complexity]]></description>
		<content:encoded><![CDATA[<p>How many times node visited of tree&#8230;<br />
Means linear time. or .polynomial time&#8230;<br />
Here we visit tree node only once so O(n) time complexity</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tweety</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-39251</link>
		<dc:creator><![CDATA[tweety]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 13:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-39251</guid>
		<description><![CDATA[hello everyone..... can anybody please tell me how to calculate the complexity of a recursive function....]]></description>
		<content:encoded><![CDATA[<p>hello everyone&#8230;.. can anybody please tell me how to calculate the complexity of a recursive function&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hero</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-38765</link>
		<dc:creator><![CDATA[Hero]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 02:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-38765</guid>
		<description><![CDATA[This posted Algorithms didn&#039;t need that assumption.
It already search for the presentation of both n1 and n2.]]></description>
		<content:encoded><![CDATA[<p>This posted Algorithms didn&#8217;t need that assumption.<br />
It already search for the presentation of both n1 and n2.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hero</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-38764</link>
		<dc:creator><![CDATA[Hero]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 02:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-38764</guid>
		<description><![CDATA[Your calculation is incorrect, check that again.
Even if extremely unbalanced tree, it will run in O(n).]]></description>
		<content:encoded><![CDATA[<p>Your calculation is incorrect, check that again.<br />
Even if extremely unbalanced tree, it will run in O(n).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vivek</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-38267</link>
		<dc:creator><![CDATA[Vivek]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 05:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-38267</guid>
		<description><![CDATA[we can do this using post order traversal, 

we maintain two boolean variables one for each key,both initialized to false;
we set the respective boolean variables true as soon as the key is found.
As soon as both the boolean variables become true, we get the 
LCA.]]></description>
		<content:encoded><![CDATA[<p>we can do this using post order traversal, </p>
<p>we maintain two boolean variables one for each key,both initialized to false;<br />
we set the respective boolean variables true as soon as the key is found.<br />
As soon as both the boolean variables become true, we get the<br />
LCA.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-38165</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 05:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-38165</guid>
		<description><![CDATA[2ND Approach,Easy Code
bool lowestCommonAncestor(node* &#038;root,node*&#038; LCA,int x,int y)

{

    if(root==NULL)

        return false;

    if(root-&#062;data==x &#124;&#124; root-&#062;data==y)

    {

           LCA=root;

           return true;

     }

    bool a=lowestCommonAncestor(root-&#062;left,LCA,x,y);

    bool b=lowestCommonAncestor(root-&#062;right,LCA,x,y);

    if(a&#038;&#038;b){

    LCA=root;

    return true;

    }

    return(a?a:b);

}]]></description>
		<content:encoded><![CDATA[<p>2ND Approach,Easy Code<br />
bool lowestCommonAncestor(node* &amp;root,node*&amp; LCA,int x,int y)</p>
<p>{</p>
<p>    if(root==NULL)</p>
<p>        return false;</p>
<p>    if(root-&gt;data==x || root-&gt;data==y)</p>
<p>    {</p>
<p>           LCA=root;</p>
<p>           return true;</p>
<p>     }</p>
<p>    bool a=lowestCommonAncestor(root-&gt;left,LCA,x,y);</p>
<p>    bool b=lowestCommonAncestor(root-&gt;right,LCA,x,y);</p>
<p>    if(a&amp;&amp;b){</p>
<p>    LCA=root;</p>
<p>    return true;</p>
<p>    }</p>
<p>    return(a?a:b);</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Suvodip Bhattacharya</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-38074</link>
		<dc:creator><![CDATA[Suvodip Bhattacharya]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 09:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-38074</guid>
		<description><![CDATA[#include
#include
#include
#include
using namespace std;

struct tree {

    struct tree *lc;
    int data;
    int lvl;
    struct tree *rc;
};

void insert(struct tree **root,int num,int lvl)
{
    struct tree *temp=*root;

    if(temp==NULL)
    {
        (*root)=(struct tree *)malloc(sizeof(struct tree));
        (*root)-&#062;data=num;
        (*root)-&#062;lvl=lvl;
        (*root)-&#062;rc=NULL;
        (*root)-&#062;lc=NULL;
        //*root=temp;
    }

    else
    {
    if( num data )
    insert( &#038;(temp-&#062;lc),num,lvl+1 );
    else
    insert( &#038;(temp-&#062;rc),num,lvl+1 );
    }

}

void LowestCommonAncestorUtil(struct tree *root,int num1,int num2,int *x)
{

    if(root==NULL) return ;
    if(root-&#062;data== num1 &#124;&#124; root-&#062;data == num2) { (*x)=(*x)+1; }
    
    LowestCommonAncestorUtil(root-&#062;lc,num1,num2,&#038;(*x) );
    LowestCommonAncestorUtil(root-&#062;rc,num1,num2,&#038;(*x) );
}    

void LowestCommonAncestor(struct tree *root,struct tree **parent,int num1,int num2)
{
    //int x=0;
    if(root == NULL)return ;
    int x=0;
    LowestCommonAncestorUtil( root,num1,num2,&#038;x);
    
    if(x==2 &#038;&#038; ( (*parent)-&#062;lvllvl ) )
    { *parent=root; }

    LowestCommonAncestor(root-&#062;lc,&#038;(*parent),num1,num2);
    LowestCommonAncestor(root-&#062;rc,&#038;(*parent),num1,num2);
}
    
int main()
{
struct tree *root=NULL,*great;
//great=root;
int arr[]={20,8,22,4,12,21,27,10,14,11};
int size=sizeof(arr)/sizeof(arr[0]);

for(int i=0 ; i&#060;size ; i++)
insert(&#038;root,arr[i],0);
great=root;

LowestCommonAncestor(root,&#038;great,12,11);
cout&#060;data&#060;&#060;endl;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
#include<br />
using namespace std;</p>
<p>struct tree {</p>
<p>    struct tree *lc;<br />
    int data;<br />
    int lvl;<br />
    struct tree *rc;<br />
};</p>
<p>void insert(struct tree **root,int num,int lvl)<br />
{<br />
    struct tree *temp=*root;</p>
<p>    if(temp==NULL)<br />
    {<br />
        (*root)=(struct tree *)malloc(sizeof(struct tree));<br />
        (*root)-&gt;data=num;<br />
        (*root)-&gt;lvl=lvl;<br />
        (*root)-&gt;rc=NULL;<br />
        (*root)-&gt;lc=NULL;<br />
        //*root=temp;<br />
    }</p>
<p>    else<br />
    {<br />
    if( num data )<br />
    insert( &amp;(temp-&gt;lc),num,lvl+1 );<br />
    else<br />
    insert( &amp;(temp-&gt;rc),num,lvl+1 );<br />
    }</p>
<p>}</p>
<p>void LowestCommonAncestorUtil(struct tree *root,int num1,int num2,int *x)<br />
{</p>
<p>    if(root==NULL) return ;<br />
    if(root-&gt;data== num1 || root-&gt;data == num2) { (*x)=(*x)+1; }</p>
<p>    LowestCommonAncestorUtil(root-&gt;lc,num1,num2,&amp;(*x) );<br />
    LowestCommonAncestorUtil(root-&gt;rc,num1,num2,&amp;(*x) );<br />
}    </p>
<p>void LowestCommonAncestor(struct tree *root,struct tree **parent,int num1,int num2)<br />
{<br />
    //int x=0;<br />
    if(root == NULL)return ;<br />
    int x=0;<br />
    LowestCommonAncestorUtil( root,num1,num2,&amp;x);</p>
<p>    if(x==2 &amp;&amp; ( (*parent)-&gt;lvllvl ) )<br />
    { *parent=root; }</p>
<p>    LowestCommonAncestor(root-&gt;lc,&amp;(*parent),num1,num2);<br />
    LowestCommonAncestor(root-&gt;rc,&amp;(*parent),num1,num2);<br />
}</p>
<p>int main()<br />
{<br />
struct tree *root=NULL,*great;<br />
//great=root;<br />
int arr[]={20,8,22,4,12,21,27,10,14,11};<br />
int size=sizeof(arr)/sizeof(arr[0]);</p>
<p>for(int i=0 ; i&lt;size ; i++)<br />
insert(&amp;root,arr[i],0);<br />
great=root;</p>
<p>LowestCommonAncestor(root,&amp;great,12,11);<br />
cout&lt;data&lt;&lt;endl;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Manikanta karanam</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-37625</link>
		<dc:creator><![CDATA[Manikanta karanam]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 19:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-37625</guid>
		<description><![CDATA[How can the complexity of the second method be O(n). It is only O(n) if the tree is balanced, otherwise we get O(n2).


For example in worst case Binary tree is a Linked List with all children being in left or right nodes. So recurrence is
T(n) = T(n-1)+1 ==&#062; O(n2)


If the tree is balanced then we have at every step nodes reduced by half...
n + n/2 + n/4....~= 2n ==&#062; O(n).


I don&#039;t see balanced anywhere so the time complexity is wrong and solution is inefficient on random binary trees.]]></description>
		<content:encoded><![CDATA[<p>How can the complexity of the second method be O(n). It is only O(n) if the tree is balanced, otherwise we get O(n2).</p>
<p>For example in worst case Binary tree is a Linked List with all children being in left or right nodes. So recurrence is<br />
T(n) = T(n-1)+1 ==&gt; O(n2)</p>
<p>If the tree is balanced then we have at every step nodes reduced by half&#8230;<br />
n + n/2 + n/4&#8230;.~= 2n ==&gt; O(n).</p>
<p>I don&#8217;t see balanced anywhere so the time complexity is wrong and solution is inefficient on random binary trees.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gautam Goyal</title>
		<link>http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/#comment-37622</link>
		<dc:creator><![CDATA[Gautam Goyal]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 17:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=127045#comment-37622</guid>
		<description><![CDATA[do an inorder traversal, all values between n1 and n2 are candidates for LCA, whichever value is the root of the sub-tree containing these values is the LCA. Do a post order traversal, store in array. Whichever value in inorder candidates occur at the largest index in postorder, is the solution.]]></description>
		<content:encoded><![CDATA[<p>do an inorder traversal, all values between n1 and n2 are candidates for LCA, whichever value is the root of the sub-tree containing these values is the LCA. Do a post order traversal, store in array. Whichever value in inorder candidates occur at the largest index in postorder, is the solution.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:25 -->

<!-- Compression = gzip -->