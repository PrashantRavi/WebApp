<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Level Order Tree Traversal</title>
	<atom:link href="http://www.geeksforgeeks.org/level-order-tree-traversal/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/level-order-tree-traversal/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Jun</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-39541</link>
		<dc:creator><![CDATA[Jun]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 16:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-39541</guid>
		<description><![CDATA[Can anybody pleaz tell tell me how come the Time complexity of Method 1 is O(n^2)...I have a bit conflicting viewpoint]]></description>
		<content:encoded><![CDATA[<p>Can anybody pleaz tell tell me how come the Time complexity of Method 1 is O(n^2)&#8230;I have a bit conflicting viewpoint</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tweety</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-39464</link>
		<dc:creator><![CDATA[tweety]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 14:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-39464</guid>
		<description><![CDATA[here is another method by maintaining hash table on the basis of levels....

and then printing that table.... 

can somebody tell me complexity of the code.... and plz tell me whether my code is efficient or not....as i just did it but don&#039;t know much about how to improve complexity and make a efficient code....

#include

#include

#include

struct node

{

       int data,level;

       struct node* left,*right;

}*root=NULL;

struct level

{

       int data,l;

       struct level* next,*list;

}*start=NULL;

struct node* newnode(int x)

{

       struct node*p=(struct node*)malloc(sizeof(struct node));

       p-&#062;data=x;

       p-&#062;left=p-&#062;right=NULL;

       return p;

};

void traverse(struct node*p,int);

void insert(int,int);

void print();

int main()

{

    root=newnode(1);

    root-&#062;left=newnode(2);

    root-&#062;right=newnode(3);

    root-&#062;left-&#062;left=newnode(7);

    root-&#062;left-&#062;right=newnode(8);

    root-&#062;left-&#062;right-&#062;left=newnode(9);

    root-&#062;left-&#062;right-&#062;left-&#062;right=newnode(10);

    root-&#062;right-&#062;right=newnode(4);

    root-&#062;right-&#062;left=newnode(5);

    root-&#062;right-&#062;left-&#062;right=newnode(6);

    traverse(root,1);

    print();

    getch();

}

void traverse(struct node*p,int l)

{

     if(p!=NULL)

     {

                insert(p-&#062;data,l);

                traverse(p-&#062;left,l+1);

                traverse(p-&#062;right,l+1);

                

     }

}

void insert(int x,int l)

{

     static struct level *q;

     struct level *r,*s,* p= (struct level*)malloc(sizeof(struct level));

     p-&#062;l=l;

     p-&#062;data=x;

     p-&#062;next=p-&#062;list=NULL;

     if(start==NULL)

                    q=start=p;

     else

     {

         for(r=start;r!=NULL;r=r-&#062;next)

                                       if(r-&#062;l==l)

                                                  break;

         if(r==NULL)

         {

             q-&#062;next=p;

             q=p;

         }

         else

         {       

                 while(r!=NULL)

                 {

                               s=r;

                               r=r-&#062;list;

                 }

                 s-&#062;list=p;

         }

     }     

 }

 void print()

 {

      struct level*p,*q,*s;

      for(p=start;p!=NULL;p=p-&#062;next)

      {

                                    for(q=p;q!=NULL;q=q-&#062;list)

                                    {

                                                              s=q;

                                    }

                                    printf(&quot;%dn&quot;,s-&#062;data);

      }                                                              

 }]]></description>
		<content:encoded><![CDATA[<p>here is another method by maintaining hash table on the basis of levels&#8230;.</p>
<p>and then printing that table&#8230;. </p>
<p>can somebody tell me complexity of the code&#8230;. and plz tell me whether my code is efficient or not&#8230;.as i just did it but don&#8217;t know much about how to improve complexity and make a efficient code&#8230;.</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>struct node</p>
<p>{</p>
<p>       int data,level;</p>
<p>       struct node* left,*right;</p>
<p>}*root=NULL;</p>
<p>struct level</p>
<p>{</p>
<p>       int data,l;</p>
<p>       struct level* next,*list;</p>
<p>}*start=NULL;</p>
<p>struct node* newnode(int x)</p>
<p>{</p>
<p>       struct node*p=(struct node*)malloc(sizeof(struct node));</p>
<p>       p-&gt;data=x;</p>
<p>       p-&gt;left=p-&gt;right=NULL;</p>
<p>       return p;</p>
<p>};</p>
<p>void traverse(struct node*p,int);</p>
<p>void insert(int,int);</p>
<p>void print();</p>
<p>int main()</p>
<p>{</p>
<p>    root=newnode(1);</p>
<p>    root-&gt;left=newnode(2);</p>
<p>    root-&gt;right=newnode(3);</p>
<p>    root-&gt;left-&gt;left=newnode(7);</p>
<p>    root-&gt;left-&gt;right=newnode(8);</p>
<p>    root-&gt;left-&gt;right-&gt;left=newnode(9);</p>
<p>    root-&gt;left-&gt;right-&gt;left-&gt;right=newnode(10);</p>
<p>    root-&gt;right-&gt;right=newnode(4);</p>
<p>    root-&gt;right-&gt;left=newnode(5);</p>
<p>    root-&gt;right-&gt;left-&gt;right=newnode(6);</p>
<p>    traverse(root,1);</p>
<p>    print();</p>
<p>    getch();</p>
<p>}</p>
<p>void traverse(struct node*p,int l)</p>
<p>{</p>
<p>     if(p!=NULL)</p>
<p>     {</p>
<p>                insert(p-&gt;data,l);</p>
<p>                traverse(p-&gt;left,l+1);</p>
<p>                traverse(p-&gt;right,l+1);</p>
<p>     }</p>
<p>}</p>
<p>void insert(int x,int l)</p>
<p>{</p>
<p>     static struct level *q;</p>
<p>     struct level *r,*s,* p= (struct level*)malloc(sizeof(struct level));</p>
<p>     p-&gt;l=l;</p>
<p>     p-&gt;data=x;</p>
<p>     p-&gt;next=p-&gt;list=NULL;</p>
<p>     if(start==NULL)</p>
<p>                    q=start=p;</p>
<p>     else</p>
<p>     {</p>
<p>         for(r=start;r!=NULL;r=r-&gt;next)</p>
<p>                                       if(r-&gt;l==l)</p>
<p>                                                  break;</p>
<p>         if(r==NULL)</p>
<p>         {</p>
<p>             q-&gt;next=p;</p>
<p>             q=p;</p>
<p>         }</p>
<p>         else</p>
<p>         {       </p>
<p>                 while(r!=NULL)</p>
<p>                 {</p>
<p>                               s=r;</p>
<p>                               r=r-&gt;list;</p>
<p>                 }</p>
<p>                 s-&gt;list=p;</p>
<p>         }</p>
<p>     }     </p>
<p> }</p>
<p> void print()</p>
<p> {</p>
<p>      struct level*p,*q,*s;</p>
<p>      for(p=start;p!=NULL;p=p-&gt;next)</p>
<p>      {</p>
<p>                                    for(q=p;q!=NULL;q=q-&gt;list)</p>
<p>                                    {</p>
<p>                                                              s=q;</p>
<p>                                    }</p>
<p>                                    printf(&#8220;%dn&#8221;,s-&gt;data);</p>
<p>      }                                                              </p>
<p> }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-39269</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 16:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-39269</guid>
		<description><![CDATA[Sorry, posted in wrong thread :)]]></description>
		<content:encoded><![CDATA[<p>Sorry, posted in wrong thread ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Deepak Malik</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-39018</link>
		<dc:creator><![CDATA[Deepak Malik]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 07:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-39018</guid>
		<description><![CDATA[input    10
           /   
         5     15
       / 
      2    8
wrong output
10 5 2 8 15
 
#include 

#include 

#include 

typedef struct TREE

{

struct TREE *left,*right;

int info;

}TREE;

int height(TREE *temp,int h);

void print(TREE *node,int l);

void printout(TREE *m);

TREE *insert(int val,TREE *p);

void main()

{

clrscr();

TREE *start=NULL,*last,*temp;

int a,b,data;

printf(&quot;how many nodes u want to enter&quot;);

scanf(&quot;%d&quot;,&#038;a);

for(b=0;b&#060;a;b++)

{

if(b==0)

{

printf(&#034;n enter data&#034;);

scanf(&#034;%d&#034;,&#038;data);

start=insert(data,start);

}

else

{

printf(&#034;n enter data&#034;);

scanf(&#034;%d&#034;,&#038;data);

insert(data,start);

}

}

int c,d=0,i,n;

printout(start);

c=height(start,d);

n=c;

for(i=0;iinfo=val;

p-&#062;left=NULL;

p-&#062;right=NULL;

return(p);

}

if(p-&#062;info&#062;val)

p-&#062;left=insert(val,p-&#062;left);

if(p-&#062;inforight=insert(val,p-&#062;right);

return(p);

}

void printout(TREE *m)

{

if(m-&#062;left!=NULL)

{

 printout(m-&#062;left);

}

printf(&quot;	%d&quot;,m-&#062;info);

if(m-&#062;right!=NULL)

{

printout(m-&#062;right);

}

}

int height(TREE *temp,int h)

 {

   if(temp-&#062;left)

    { h++;

     height(temp-&#062;left,h);

    }

    if(temp-&#062;right)

    { h++;

     height(temp-&#062;right,h);

    }

    return(h);

 }

 void print(TREE *node,int l)

  {

   int e;

   e=l;

   if(l==0)

   printf(&quot;n%d&quot;,node-&#062;info);

   if(node-&#062;left&#038;&#038;l&#062;0)

   print(node-&#062;left,l--);

   if(node-&#062;right&#038;&#038;l&#062;0)

   print(node-&#062;right,l--);

  }]]></description>
		<content:encoded><![CDATA[<p>input    10<br />
           /<br />
         5     15<br />
       /<br />
      2    8<br />
wrong output<br />
10 5 2 8 15</p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>typedef struct TREE</p>
<p>{</p>
<p>struct TREE *left,*right;</p>
<p>int info;</p>
<p>}TREE;</p>
<p>int height(TREE *temp,int h);</p>
<p>void print(TREE *node,int l);</p>
<p>void printout(TREE *m);</p>
<p>TREE *insert(int val,TREE *p);</p>
<p>void main()</p>
<p>{</p>
<p>clrscr();</p>
<p>TREE *start=NULL,*last,*temp;</p>
<p>int a,b,data;</p>
<p>printf(&#8220;how many nodes u want to enter&#8221;);</p>
<p>scanf(&#8220;%d&#8221;,&amp;a);</p>
<p>for(b=0;b&lt;a;b++)</p>
<p>{</p>
<p>if(b==0)</p>
<p>{</p>
<p>printf(&quot;n enter data&quot;);</p>
<p>scanf(&quot;%d&quot;,&amp;data);</p>
<p>start=insert(data,start);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf(&quot;n enter data&quot;);</p>
<p>scanf(&quot;%d&quot;,&amp;data);</p>
<p>insert(data,start);</p>
<p>}</p>
<p>}</p>
<p>int c,d=0,i,n;</p>
<p>printout(start);</p>
<p>c=height(start,d);</p>
<p>n=c;</p>
<p>for(i=0;iinfo=val;</p>
<p>p-&gt;left=NULL;</p>
<p>p-&gt;right=NULL;</p>
<p>return(p);</p>
<p>}</p>
<p>if(p-&gt;info&gt;val)</p>
<p>p-&gt;left=insert(val,p-&gt;left);</p>
<p>if(p-&gt;inforight=insert(val,p-&gt;right);</p>
<p>return(p);</p>
<p>}</p>
<p>void printout(TREE *m)</p>
<p>{</p>
<p>if(m-&gt;left!=NULL)</p>
<p>{</p>
<p> printout(m-&gt;left);</p>
<p>}</p>
<p>printf(&#8221;	%d&#8221;,m-&gt;info);</p>
<p>if(m-&gt;right!=NULL)</p>
<p>{</p>
<p>printout(m-&gt;right);</p>
<p>}</p>
<p>}</p>
<p>int height(TREE *temp,int h)</p>
<p> {</p>
<p>   if(temp-&gt;left)</p>
<p>    { h++;</p>
<p>     height(temp-&gt;left,h);</p>
<p>    }</p>
<p>    if(temp-&gt;right)</p>
<p>    { h++;</p>
<p>     height(temp-&gt;right,h);</p>
<p>    }</p>
<p>    return(h);</p>
<p> }</p>
<p> void print(TREE *node,int l)</p>
<p>  {</p>
<p>   int e;</p>
<p>   e=l;</p>
<p>   if(l==0)</p>
<p>   printf(&#8220;n%d&#8221;,node-&gt;info);</p>
<p>   if(node-&gt;left&amp;&amp;l&gt;0)</p>
<p>   print(node-&gt;left,l&#8211;);</p>
<p>   if(node-&gt;right&amp;&amp;l&gt;0)</p>
<p>   print(node-&gt;right,l&#8211;);</p>
<p>  }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Karshit Jaiswal</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-37598</link>
		<dc:creator><![CDATA[Karshit Jaiswal]]></dc:creator>
		<pubDate>Wed, 04 Jun 2014 11:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-37598</guid>
		<description><![CDATA[SImple Code for BFS (level order traversal) implementation.
Only method : http://ideone.com/Au1WOU]]></description>
		<content:encoded><![CDATA[<p>SImple Code for BFS (level order traversal) implementation.<br />
Only method : <a href="http://ideone.com/Au1WOU" rel="nofollow">http://ideone.com/Au1WOU</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sunil</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-35229</link>
		<dc:creator><![CDATA[Sunil]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 10:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-35229</guid>
		<description><![CDATA[Implementation using HashMap is below:

private void getLevelOrder(Node root, HashMap&#060;Integer, List&#062; map, int level) {

		

		if(root == null)

			return;

		

		if(map.get(level) == null) {

			map.put(Integer.valueOf(level), new ArrayList());

		}

		map.get(Integer.valueOf(level)).add(root.data);

		

		getLevelOrder(root.left, map, level + 1);

		getLevelOrder(root.right, map, level + 1);

	}

Function call: getLevelOrder(root, map, 0);



Time complexity: O(n)
Space complexity: O(n)


If you feel i am wrong, please correct me. send me an email at &quot;sunilebiz2007@gmail.com&quot;]]></description>
		<content:encoded><![CDATA[<p>Implementation using HashMap is below:</p>
<p>private void getLevelOrder(Node root, HashMap&lt;Integer, List&gt; map, int level) {</p>
<p>		if(root == null)</p>
<p>			return;</p>
<p>		if(map.get(level) == null) {</p>
<p>			map.put(Integer.valueOf(level), new ArrayList());</p>
<p>		}</p>
<p>		map.get(Integer.valueOf(level)).add(root.data);</p>
<p>		getLevelOrder(root.left, map, level + 1);</p>
<p>		getLevelOrder(root.right, map, level + 1);</p>
<p>	}</p>
<p>Function call: getLevelOrder(root, map, 0);</p>
<p>Time complexity: O(n)<br />
Space complexity: O(n)</p>
<p>If you feel i am wrong, please correct me. send me an email at &#8220;sunilebiz2007@gmail.com&#8221;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vaibhav</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-34778</link>
		<dc:creator><![CDATA[vaibhav]]></dc:creator>
		<pubDate>Thu, 17 Apr 2014 15:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-34778</guid>
		<description><![CDATA[see in right skewed tree every time a node is seen at new level , all the previous level nodes are visited b4 getting to it....]]></description>
		<content:encoded><![CDATA[<p>see in right skewed tree every time a node is seen at new level , all the previous level nodes are visited b4 getting to it&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: yewD</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-34746</link>
		<dc:creator><![CDATA[yewD]]></dc:creator>
		<pubDate>Wed, 16 Apr 2014 20:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-34746</guid>
		<description><![CDATA[queue.enQueue(root);
queue.enQueue(null);
while(!queue.isEmpty){
temp = queue.deQueue();
if(temp==null) 
            queue.deQueue();
            break line;
             queue.enQueue(null);
}else {
      print(temp.data);
       if(temp.left!=null) queue.enQueue(temp.left);
       if(temp.right!=null) queue.enQueue(temp.right);
}


}]]></description>
		<content:encoded><![CDATA[<p>queue.enQueue(root);<br />
queue.enQueue(null);<br />
while(!queue.isEmpty){<br />
temp = queue.deQueue();<br />
if(temp==null)<br />
            queue.deQueue();<br />
            break line;<br />
             queue.enQueue(null);<br />
}else {<br />
      print(temp.data);<br />
       if(temp.left!=null) queue.enQueue(temp.left);<br />
       if(temp.right!=null) queue.enQueue(temp.right);<br />
}</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Secord</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-34739</link>
		<dc:creator><![CDATA[Secord]]></dc:creator>
		<pubDate>Wed, 16 Apr 2014 09:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-34739</guid>
		<description><![CDATA[Please I need the implementation of level order traversal into source please help me 

#include

#include

#include

#include

#include

#include

using namespace std;

class Node

{

public:

	int value;

	Node* left;

	Node* right;

	Node(int value, Node* left = NULL, Node* right = NULL)

	{

		this-&#062;left = left;

		this-&#062;right = right;

		this-&#062;value = value;

	}

	~Node();

private:

};

class Btree

{

public:

	Btree()

	{

		root = NULL;

	}

	void print_subtree(Node* x)

	{

		if (x != NULL)

		{

			print_subtree(x-&#062;left);

			cout &#060;value &#060;&#060; &#034; &#034; &#060;right);

		}

	}

	void print()

	{

		print_subtree(root);

	}

	void insert(int new_value)

	{

		if (root == NULL)

		{

			root = new Node(new_value);

		}

		else

		{

			insert_node(new_value,root);

		}

	}

	void insert_node(int new_value, Node* c)

	{

		if (c-&#062;value &#062; new_value)

		{

			if (c-&#062;left == NULL)

			{

				c-&#062;left = new Node(new_value);

				return;

			}

			else

			{

				insert_node(new_value, c-&#062;left);

			}

		}

		else

		{

			if (c-&#062;right == NULL)

			{

				c-&#062;right = new Node(new_value);

					return;

			}

			else

			{

				insert_node(new_value, c-&#062;right);

			}

		}

	}

	~Btree();

private:

	Node* root;

};

int main()

{

	Btree* v = new Btree();

	v-&#062;insert(10);

	v-&#062;insert(7);

	v-&#062;insert(15);

	v-&#062;insert(6);

	v-&#062;insert(17);

	v-&#062;insert(8);

	v-&#062;insert(16);

	v-&#062;insert(19);

	v-&#062;print();

	

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Please I need the implementation of level order traversal into source please help me </p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>class Node</p>
<p>{</p>
<p>public:</p>
<p>	int value;</p>
<p>	Node* left;</p>
<p>	Node* right;</p>
<p>	Node(int value, Node* left = NULL, Node* right = NULL)</p>
<p>	{</p>
<p>		this-&gt;left = left;</p>
<p>		this-&gt;right = right;</p>
<p>		this-&gt;value = value;</p>
<p>	}</p>
<p>	~Node();</p>
<p>private:</p>
<p>};</p>
<p>class Btree</p>
<p>{</p>
<p>public:</p>
<p>	Btree()</p>
<p>	{</p>
<p>		root = NULL;</p>
<p>	}</p>
<p>	void print_subtree(Node* x)</p>
<p>	{</p>
<p>		if (x != NULL)</p>
<p>		{</p>
<p>			print_subtree(x-&gt;left);</p>
<p>			cout &lt;value &lt;&lt; &quot; &quot; &lt;right);</p>
<p>		}</p>
<p>	}</p>
<p>	void print()</p>
<p>	{</p>
<p>		print_subtree(root);</p>
<p>	}</p>
<p>	void insert(int new_value)</p>
<p>	{</p>
<p>		if (root == NULL)</p>
<p>		{</p>
<p>			root = new Node(new_value);</p>
<p>		}</p>
<p>		else</p>
<p>		{</p>
<p>			insert_node(new_value,root);</p>
<p>		}</p>
<p>	}</p>
<p>	void insert_node(int new_value, Node* c)</p>
<p>	{</p>
<p>		if (c-&gt;value &gt; new_value)</p>
<p>		{</p>
<p>			if (c-&gt;left == NULL)</p>
<p>			{</p>
<p>				c-&gt;left = new Node(new_value);</p>
<p>				return;</p>
<p>			}</p>
<p>			else</p>
<p>			{</p>
<p>				insert_node(new_value, c-&gt;left);</p>
<p>			}</p>
<p>		}</p>
<p>		else</p>
<p>		{</p>
<p>			if (c-&gt;right == NULL)</p>
<p>			{</p>
<p>				c-&gt;right = new Node(new_value);</p>
<p>					return;</p>
<p>			}</p>
<p>			else</p>
<p>			{</p>
<p>				insert_node(new_value, c-&gt;right);</p>
<p>			}</p>
<p>		}</p>
<p>	}</p>
<p>	~Btree();</p>
<p>private:</p>
<p>	Node* root;</p>
<p>};</p>
<p>int main()</p>
<p>{</p>
<p>	Btree* v = new Btree();</p>
<p>	v-&gt;insert(10);</p>
<p>	v-&gt;insert(7);</p>
<p>	v-&gt;insert(15);</p>
<p>	v-&gt;insert(6);</p>
<p>	v-&gt;insert(17);</p>
<p>	v-&gt;insert(8);</p>
<p>	v-&gt;insert(16);</p>
<p>	v-&gt;insert(19);</p>
<p>	v-&gt;print();</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-34322</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 09:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-34322</guid>
		<description><![CDATA[here is the implementation of level order traversal using linked list queue




#include
#include
#include
struct Treenode
{
	int data;
	struct Treenode * left;
	struct Treenode *right;
};
struct Treenode* newnode(int data)
{
	struct Treenode* temp=(struct Treenode *)malloc(sizeof(struct Treenode));
	temp-&#062;data=data;
	temp-&#062;left=NULL;
	temp-&#062;right=NULL;
	return temp;
}
struct List
{
	struct Treenode* node;
	struct List *next;
};
struct queue
{
 	struct List * front;
	 struct List *rear;	
};
struct queue* createqueue()
{
	struct queue* ptr= (struct queue *)malloc(sizeof(struct queue));
	if(!ptr)return NULL;
	ptr-&#062;front= NULL;
	ptr-&#062;rear=NULL;
	return ptr;
}
void enqueue(struct queue* q,struct Treenode *root )
{
	struct List *newnode=(struct List *)malloc(sizeof(struct List));
	newnode-&#062;node=root;
	newnode-&#062;next=NULL;
	if(q-&#062;rear==NULL)
	{
			q-&#062;rear=newnode;
	}
	else
	{	
		q-&#062;rear-&#062;next=newnode;
		q-&#062;rear=newnode;	
	}
	if(q-&#062;front==NULL)
		q-&#062;front=q-&#062;rear;
}
int isempty(struct queue* q)
{
	return (q-&#062;front==NULL);
}
struct Treenode* dequeue(struct queue* q)
{
	struct Treenode* dq;
	struct List *temp;
	if(isempty(q))
	{
		printf(&quot;No elements in queue&quot;);
		return NULL;
	}
	else
	{
		temp=q-&#062;front;
		dq=q-&#062;front-&#062;node;
		q-&#062;front=q-&#062;front-&#062;next;
		free(temp);
	}
	return dq;
} 
void levelordertraversal(struct Treenode *root)
{
	struct Treenode* temp;
	struct queue* q=createqueue();
	enqueue(q,root);
	while(!isempty(q))
	{
		temp=dequeue(q);
		printf(&quot; %d-&#062;&quot;,temp-&#062;data);
		if(temp-&#062;left)
		{
			enqueue(q,temp-&#062;left);
		}
		if(temp-&#062;right)
		{
			enqueue(q,temp-&#062;right);
		}
	}
}
int main()
{
	struct Treenode* root=newnode(5);
	root-&#062;left 			 =newnode(1);
	root-&#062;right			 =newnode(7);
	root-&#062;left-&#062;right	 =newnode(4);
	root-&#062;left-&#062;left     =newnode(9);
	root-&#062;right-&#062;left    =newnode(10);
	root-&#062;right-&#062;right   =newnode(3);
	levelordertraversal(root);
	return 0;
}]]></description>
		<content:encoded><![CDATA[<p>here is the implementation of level order traversal using linked list queue</p>
<p>#include<br />
#include<br />
#include<br />
struct Treenode<br />
{<br />
	int data;<br />
	struct Treenode * left;<br />
	struct Treenode *right;<br />
};<br />
struct Treenode* newnode(int data)<br />
{<br />
	struct Treenode* temp=(struct Treenode *)malloc(sizeof(struct Treenode));<br />
	temp-&gt;data=data;<br />
	temp-&gt;left=NULL;<br />
	temp-&gt;right=NULL;<br />
	return temp;<br />
}<br />
struct List<br />
{<br />
	struct Treenode* node;<br />
	struct List *next;<br />
};<br />
struct queue<br />
{<br />
 	struct List * front;<br />
	 struct List *rear;<br />
};<br />
struct queue* createqueue()<br />
{<br />
	struct queue* ptr= (struct queue *)malloc(sizeof(struct queue));<br />
	if(!ptr)return NULL;<br />
	ptr-&gt;front= NULL;<br />
	ptr-&gt;rear=NULL;<br />
	return ptr;<br />
}<br />
void enqueue(struct queue* q,struct Treenode *root )<br />
{<br />
	struct List *newnode=(struct List *)malloc(sizeof(struct List));<br />
	newnode-&gt;node=root;<br />
	newnode-&gt;next=NULL;<br />
	if(q-&gt;rear==NULL)<br />
	{<br />
			q-&gt;rear=newnode;<br />
	}<br />
	else<br />
	{<br />
		q-&gt;rear-&gt;next=newnode;<br />
		q-&gt;rear=newnode;<br />
	}<br />
	if(q-&gt;front==NULL)<br />
		q-&gt;front=q-&gt;rear;<br />
}<br />
int isempty(struct queue* q)<br />
{<br />
	return (q-&gt;front==NULL);<br />
}<br />
struct Treenode* dequeue(struct queue* q)<br />
{<br />
	struct Treenode* dq;<br />
	struct List *temp;<br />
	if(isempty(q))<br />
	{<br />
		printf(&#8220;No elements in queue&#8221;);<br />
		return NULL;<br />
	}<br />
	else<br />
	{<br />
		temp=q-&gt;front;<br />
		dq=q-&gt;front-&gt;node;<br />
		q-&gt;front=q-&gt;front-&gt;next;<br />
		free(temp);<br />
	}<br />
	return dq;<br />
}<br />
void levelordertraversal(struct Treenode *root)<br />
{<br />
	struct Treenode* temp;<br />
	struct queue* q=createqueue();<br />
	enqueue(q,root);<br />
	while(!isempty(q))<br />
	{<br />
		temp=dequeue(q);<br />
		printf(&#8221; %d-&gt;&#8221;,temp-&gt;data);<br />
		if(temp-&gt;left)<br />
		{<br />
			enqueue(q,temp-&gt;left);<br />
		}<br />
		if(temp-&gt;right)<br />
		{<br />
			enqueue(q,temp-&gt;right);<br />
		}<br />
	}<br />
}<br />
int main()<br />
{<br />
	struct Treenode* root=newnode(5);<br />
	root-&gt;left 			 =newnode(1);<br />
	root-&gt;right			 =newnode(7);<br />
	root-&gt;left-&gt;right	 =newnode(4);<br />
	root-&gt;left-&gt;left     =newnode(9);<br />
	root-&gt;right-&gt;left    =newnode(10);<br />
	root-&gt;right-&gt;right   =newnode(3);<br />
	levelordertraversal(root);<br />
	return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ankit</title>
		<link>http://www.geeksforgeeks.org/level-order-tree-traversal/#comment-33300</link>
		<dc:creator><![CDATA[Ankit]]></dc:creator>
		<pubDate>Sat, 08 Mar 2014 14:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=2686#comment-33300</guid>
		<description><![CDATA[while(front&#060;=rear) should be used instead of while(temp_node) in second method]]></description>
		<content:encoded><![CDATA[<p>while(front&lt;=rear) should be used instead of while(temp_node) in second method</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:03:28 -->

<!-- Compression = gzip -->