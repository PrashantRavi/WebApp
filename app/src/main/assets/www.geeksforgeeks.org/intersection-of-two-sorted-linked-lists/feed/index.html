<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Intersection of two Sorted Linked Lists</title>
	<atom:link href="http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-39915</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 20:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-39915</guid>
		<description><![CDATA[But it is more efficient if Lists are unsorted, in sorting we are adding an overhead of space complexity to the problem with this method..]]></description>
		<content:encoded><![CDATA[<p>But it is more efficient if Lists are unsorted, in sorting we are adding an overhead of space complexity to the problem with this method..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-39914</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 20:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-39914</guid>
		<description><![CDATA[More efficient if List is Unsorted..]]></description>
		<content:encoded><![CDATA[<p>More efficient if List is Unsorted..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: dhiru</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-39371</link>
		<dc:creator><![CDATA[dhiru]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 17:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-39371</guid>
		<description><![CDATA[what is the time complexity?]]></description>
		<content:encoded><![CDATA[<p>what is the time complexity?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mittal</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-38993</link>
		<dc:creator><![CDATA[Mittal]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 04:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-38993</guid>
		<description><![CDATA[Why do we want to create the list at its tail ?
Why can&#039;t the simple list creation work ? I mean the question doesn&#039;t ask to maintain the ascending order]]></description>
		<content:encoded><![CDATA[<p>Why do we want to create the list at its tail ?<br />
Why can&#8217;t the simple list creation work ? I mean the question doesn&#8217;t ask to maintain the ascending order</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-38992</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 04:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-38992</guid>
		<description><![CDATA[In Method 1, since we are stopping as soon as one node finishes, should not the time complexity be O(n) where n is the number of nodes in smaller list ?]]></description>
		<content:encoded><![CDATA[<p>In Method 1, since we are stopping as soon as one node finishes, should not the time complexity be O(n) where n is the number of nodes in smaller list ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mittal</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-38978</link>
		<dc:creator><![CDATA[Mittal]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 19:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-38978</guid>
		<description><![CDATA[Yes, this should work.
But will have O(m+n) time complexity and O(n) auxillary space complexity too due to hash]]></description>
		<content:encoded><![CDATA[<p>Yes, this should work.<br />
But will have O(m+n) time complexity and O(n) auxillary space complexity too due to hash</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Heracles</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-38168</link>
		<dc:creator><![CDATA[Heracles]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 06:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-38168</guid>
		<description><![CDATA[Can we use this method :

Traverse the first list - add the elements to the hash table. 
Traverse the second list - whenever we find that the elements of the second list are in the hash table - we create a node with that element and we create a list that way by connecting such nodes. 


Will this work?]]></description>
		<content:encoded><![CDATA[<p>Can we use this method :</p>
<p>Traverse the first list &#8211; add the elements to the hash table.<br />
Traverse the second list &#8211; whenever we find that the elements of the second list are in the hash table &#8211; we create a node with that element and we create a list that way by connecting such nodes. </p>
<p>Will this work?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: anon</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-36341</link>
		<dc:creator><![CDATA[anon]]></dc:creator>
		<pubDate>Tue, 20 May 2014 16:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-36341</guid>
		<description><![CDATA[here, with changing the original list

the intersected list is the list passed as 1st argument to function

struct A{

int a;

struct A *b;

}

void intersect(struct A **a, struct A **b)
{
    struct A *c;

    while (*a) {
        while (*b &#038;&#038; (*b)-&#062;a a)
            b = &#038;((*b)-&#062;b);
        if(*b == 0)
            *a = 0;
        else if((*a)-&#062;a == (*b)-&#062;a) {
            c = (*a)-&#062;b;
            while (c &#038;&#038; c-&#062;a == (*a)-&#062;a)
                c = c-&#062;b;
            (*a)-&#062;b = c;
            a = &#038;((*a)-&#062;b);
        } else {
            c = (*a)-&#062;b;
            while (c &#038;&#038; c-&#062;a a)
                c = c-&#062;b;
            *a = c;
        }
    }
}]]></description>
		<content:encoded><![CDATA[<p>here, with changing the original list</p>
<p>the intersected list is the list passed as 1st argument to function</p>
<p>struct A{</p>
<p>int a;</p>
<p>struct A *b;</p>
<p>}</p>
<p>void intersect(struct A **a, struct A **b)<br />
{<br />
    struct A *c;</p>
<p>    while (*a) {<br />
        while (*b &amp;&amp; (*b)-&gt;a a)<br />
            b = &amp;((*b)-&gt;b);<br />
        if(*b == 0)<br />
            *a = 0;<br />
        else if((*a)-&gt;a == (*b)-&gt;a) {<br />
            c = (*a)-&gt;b;<br />
            while (c &amp;&amp; c-&gt;a == (*a)-&gt;a)<br />
                c = c-&gt;b;<br />
            (*a)-&gt;b = c;<br />
            a = &amp;((*a)-&gt;b);<br />
        } else {<br />
            c = (*a)-&gt;b;<br />
            while (c &amp;&amp; c-&gt;a a)<br />
                c = c-&gt;b;<br />
            *a = c;<br />
        }<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: LePiaf</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-36074</link>
		<dc:creator><![CDATA[LePiaf]]></dc:creator>
		<pubDate>Thu, 15 May 2014 11:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-36074</guid>
		<description><![CDATA[Hi all,

you can also maintain circular linked list, and at the end make it regular linked list, returning first node.]]></description>
		<content:encoded><![CDATA[<p>Hi all,</p>
<p>you can also maintain circular linked list, and at the end make it regular linked list, returning first node.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vignesh</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-35318</link>
		<dc:creator><![CDATA[vignesh]]></dc:creator>
		<pubDate>Wed, 30 Apr 2014 10:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-35318</guid>
		<description><![CDATA[#include
#include&quot;lcreate.h&quot;

void intersection(struct node *head1,struct node *head2,struct node **newlink)
{
int first=1;
while(head1!=NULL &#038;&#038; head2!=NULL)
{
if(head1-&#062;data==head2-&#062;data)
{
if(first)
{
push(newlink,head1-&#062;data);
first=0;
}
else
{
append(*newlink,head1-&#062;data);
}
head1=head1-&#062;next;
head2=head2-&#062;next;
}
else if(head1-&#062;data&#062;head2-&#062;data)
{
head2=head2-&#062;next;
}
else if(head1-&#062;datadata)
{
head1=head1-&#062;next;
}
}
}

void main()
{
struct node *head1=NULL;
struct node *head2=NULL;
struct node *newlink=NULL;
push(&#038;head1,1);
append(head1,2);
append(head1,3);
append(head1,4);
append(head1,6);
append(head1,6);
push(&#038;head2,2);
append(head2,4);
append(head2,6);
append(head2,8);
intersection(head2,head1,&#038;newlink);
display(newlink);
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include&#8221;lcreate.h&#8221;</p>
<p>void intersection(struct node *head1,struct node *head2,struct node **newlink)<br />
{<br />
int first=1;<br />
while(head1!=NULL &amp;&amp; head2!=NULL)<br />
{<br />
if(head1-&gt;data==head2-&gt;data)<br />
{<br />
if(first)<br />
{<br />
push(newlink,head1-&gt;data);<br />
first=0;<br />
}<br />
else<br />
{<br />
append(*newlink,head1-&gt;data);<br />
}<br />
head1=head1-&gt;next;<br />
head2=head2-&gt;next;<br />
}<br />
else if(head1-&gt;data&gt;head2-&gt;data)<br />
{<br />
head2=head2-&gt;next;<br />
}<br />
else if(head1-&gt;datadata)<br />
{<br />
head1=head1-&gt;next;<br />
}<br />
}<br />
}</p>
<p>void main()<br />
{<br />
struct node *head1=NULL;<br />
struct node *head2=NULL;<br />
struct node *newlink=NULL;<br />
push(&amp;head1,1);<br />
append(head1,2);<br />
append(head1,3);<br />
append(head1,4);<br />
append(head1,6);<br />
append(head1,6);<br />
push(&amp;head2,2);<br />
append(head2,4);<br />
append(head2,6);<br />
append(head2,8);<br />
intersection(head2,head1,&amp;newlink);<br />
display(newlink);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/#comment-35128</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Fri, 25 Apr 2014 20:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=7488#comment-35128</guid>
		<description><![CDATA[Yeah exactly we can do like this way]]></description>
		<content:encoded><![CDATA[<p>Yeah exactly we can do like this way</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.053 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:13:49 -->

<!-- Compression = gzip -->