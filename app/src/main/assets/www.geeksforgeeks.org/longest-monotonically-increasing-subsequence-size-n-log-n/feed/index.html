<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Longest Increasing Subsequence Size (N log N)</title>
	<atom:link href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Sandeep Albert Mathias</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-38913</link>
		<dc:creator><![CDATA[Sandeep Albert Mathias]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 08:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-38913</guid>
		<description><![CDATA[Won&#039;t the cloning of the lists also take time?

Supposing we have n/2 elements (without any discard, and with only cloning). For each of these elements, we require to do a clone operation, of the earlier list. This clone operation is dependent on the length of the earlier list. Hence, the time complexity would be 1+2+3+4+…+n/2 which is O(N^2).

Is there a way to do the cloning faster?]]></description>
		<content:encoded><![CDATA[<p>Won&#8217;t the cloning of the lists also take time?</p>
<p>Supposing we have n/2 elements (without any discard, and with only cloning). For each of these elements, we require to do a clone operation, of the earlier list. This clone operation is dependent on the length of the earlier list. Hence, the time complexity would be 1+2+3+4+…+n/2 which is O(N^2).</p>
<p>Is there a way to do the cloning faster?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Neha Garg</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-38843</link>
		<dc:creator><![CDATA[Neha Garg]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 12:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-38843</guid>
		<description><![CDATA[i think code is ok to get the size but tailtable is not longest monotonic incresing array???
isn&#039;t it????]]></description>
		<content:encoded><![CDATA[<p>i think code is ok to get the size but tailtable is not longest monotonic incresing array???<br />
isn&#8217;t it????</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rushil Ahuja</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-38705</link>
		<dc:creator><![CDATA[Rushil Ahuja]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 15:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-38705</guid>
		<description><![CDATA[not working for
{200,300,100,112,113,114,115}]]></description>
		<content:encoded><![CDATA[<p>not working for<br />
{200,300,100,112,113,114,115}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: lol</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-34885</link>
		<dc:creator><![CDATA[lol]]></dc:creator>
		<pubDate>Sat, 19 Apr 2014 17:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-34885</guid>
		<description><![CDATA[I stopped reading after the invalid statement 
1. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.

Why should it being less than all end candidates mean it is also less than the first elements of all lists?]]></description>
		<content:encoded><![CDATA[<p>I stopped reading after the invalid statement<br />
1. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.</p>
<p>Why should it being less than all end candidates mean it is also less than the first elements of all lists?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prateek Jain</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-33157</link>
		<dc:creator><![CDATA[Prateek Jain]]></dc:creator>
		<pubDate>Mon, 03 Mar 2014 12:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-33157</guid>
		<description><![CDATA[Have made it very Simple , Think of above implementing like a Binary 
Tree (Not Binary Search Tree) and the implementation becomes very simple
 and keep discarding the child nodes with larger value and same depth in
 tree.

Root is an empty container to hold the reference values, as there can be more than two child nodes.

Below is the Java code implementation.

http://ideone.com/e.js/W1rcXp]]></description>
		<content:encoded><![CDATA[<p>Have made it very Simple , Think of above implementing like a Binary<br />
Tree (Not Binary Search Tree) and the implementation becomes very simple<br />
 and keep discarding the child nodes with larger value and same depth in<br />
 tree.</p>
<p>Root is an empty container to hold the reference values, as there can be more than two child nodes.</p>
<p>Below is the Java code implementation.</p>
<p><a href="http://ideone.com/e.js/W1rcXp" rel="nofollow">http://ideone.com/e.js/W1rcXp</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prateek Jain</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-33156</link>
		<dc:creator><![CDATA[Prateek Jain]]></dc:creator>
		<pubDate>Mon, 03 Mar 2014 12:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-33156</guid>
		<description><![CDATA[Have made it very Simple , Think of above implementing like a Binary Tree (Not Binary Search Tree) and the implementation becomes very simple and keep discarding the child nodes with larger value and same depth in tree.

Root is an empty container to hold the reference values, as there can be more than two child nodes..

]]></description>
		<content:encoded><![CDATA[<p>Have made it very Simple , Think of above implementing like a Binary Tree (Not Binary Search Tree) and the implementation becomes very simple and keep discarding the child nodes with larger value and same depth in tree.</p>
<p>Root is an empty container to hold the reference values, as there can be more than two child nodes..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Robin Keskisärkkä</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-32389</link>
		<dc:creator><![CDATA[Robin Keskisärkkä]]></dc:creator>
		<pubDate>Sun, 09 Feb 2014 16:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-32389</guid>
		<description><![CDATA[That&#039;s right, we don&#039;t get [2,5] because any continuation sequence that is possible from [2,5] is also reachable from [2,3]. For example: 3, 4, 1, 2, 3 is solved as:
3
--
3
3, 4
--
1 (more &quot;potential&quot; than 3)
3, 4
--
1
1, 2 (more &quot;potential&quot; than 3, 4)
--
1
1, 2
1, 2, 3]]></description>
		<content:encoded><![CDATA[<p>That&#8217;s right, we don&#8217;t get [2,5] because any continuation sequence that is possible from [2,5] is also reachable from [2,3]. For example: 3, 4, 1, 2, 3 is solved as:<br />
3<br />
&#8212;<br />
3<br />
3, 4<br />
&#8212;<br />
1 (more &#8220;potential&#8221; than 3)<br />
3, 4<br />
&#8212;<br />
1<br />
1, 2 (more &#8220;potential&#8221; than 3, 4)<br />
&#8212;<br />
1<br />
1, 2<br />
1, 2, 3</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kraken</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-31606</link>
		<dc:creator><![CDATA[kraken]]></dc:creator>
		<pubDate>Sat, 18 Jan 2014 14:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-31606</guid>
		<description><![CDATA[Will we get all the longest subsequence?
Because if we take the example {2 5 3}

Then

2 : Clone =&#062; 
2

5 : Clone and Extend =&#062; 
2
2 5

3 : Clone Extend Discard
2
2 3

We dont get 2 and 5 using this approach?]]></description>
		<content:encoded><![CDATA[<p>Will we get all the longest subsequence?<br />
Because if we take the example {2 5 3}</p>
<p>Then</p>
<p>2 : Clone =&gt;<br />
2</p>
<p>5 : Clone and Extend =&gt;<br />
2<br />
2 5</p>
<p>3 : Clone Extend Discard<br />
2<br />
2 3</p>
<p>We dont get 2 and 5 using this approach?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: OP</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-31030</link>
		<dc:creator><![CDATA[OP]]></dc:creator>
		<pubDate>Thu, 26 Dec 2013 05:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-31030</guid>
		<description><![CDATA[Time complexity = O(nlogn)
for each element we are doing one binary searh, so for total n elements it will be O(nlogn)

Space complexity = O(n)]]></description>
		<content:encoded><![CDATA[<p>Time complexity = O(nlogn)<br />
for each element we are doing one binary searh, so for total n elements it will be O(nlogn)</p>
<p>Space complexity = O(n)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: OP</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-31029</link>
		<dc:creator><![CDATA[OP]]></dc:creator>
		<pubDate>Thu, 26 Dec 2013 05:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-31029</guid>
		<description><![CDATA[Because len is always equals to the maximum length of monotonic sub sequence we have found so far.]]></description>
		<content:encoded><![CDATA[<p>Because len is always equals to the maximum length of monotonic sub sequence we have found so far.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul</title>
		<link>http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/#comment-30870</link>
		<dc:creator><![CDATA[Rahul]]></dc:creator>
		<pubDate>Thu, 19 Dec 2013 23:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=9591#comment-30870</guid>
		<description><![CDATA[Java solution for this is here : http://ideone.com/CwlFq3 .

for case 3: I am not sure why we need to do the binary search, Can&#039;t we just place the element in the &quot;len&quot; position of the tailtable. 

If A[i] wants to be current end candidate of an existing subsequence It will replace last value in the len table.

This can be done by tailTable[len] = A[i]. 


Complexity can be O(n) in that case right? Am I missing something?]]></description>
		<content:encoded><![CDATA[<p>Java solution for this is here : <a href="http://ideone.com/CwlFq3" rel="nofollow">http://ideone.com/CwlFq3</a> .</p>
<p>for case 3: I am not sure why we need to do the binary search, Can&#8217;t we just place the element in the &#8220;len&#8221; position of the tailtable. </p>
<p>If A[i] wants to be current end candidate of an existing subsequence It will replace last value in the len table.</p>
<p>This can be done by tailTable[len] = A[i]. </p>
<p>Complexity can be O(n) in that case right? Am I missing something?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:13:31 -->

<!-- Compression = gzip -->