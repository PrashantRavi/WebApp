<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Clone a linked list with next and random pointer &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: vikash</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-38922</link>
		<dc:creator><![CDATA[vikash]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 09:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-38922</guid>
		<description><![CDATA[in 1st method for each node it stores its next and arbitrary address in an array. so space complexity is o(n). 
mayb u can use a struct to store them.]]></description>
		<content:encoded><![CDATA[<p>in 1st method for each node it stores its next and arbitrary address in an array. so space complexity is o(n).<br />
mayb u can use a struct to store them.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-38630</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 06:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-38630</guid>
		<description><![CDATA[Wow very simple, easy to understand and effective solution.]]></description>
		<content:encoded><![CDATA[<p>Wow very simple, easy to understand and effective solution.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-38629</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 06:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-38629</guid>
		<description><![CDATA[I agree with you one should develop approach without modifying input data. And hence I do not agree with both the solutions.]]></description>
		<content:encoded><![CDATA[<p>I agree with you one should develop approach without modifying input data. And hence I do not agree with both the solutions.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: MK</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-38605</link>
		<dc:creator><![CDATA[MK]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 20:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-38605</guid>
		<description><![CDATA[Why is the space complexity of first algo O(n) and that of second O(1)??


Also what is the best way to store node and its next ptrs in first method 2nd step?


Please enlighten.]]></description>
		<content:encoded><![CDATA[<p>Why is the space complexity of first algo O(n) and that of second O(1)??</p>
<p>Also what is the best way to store node and its next ptrs in first method 2nd step?</p>
<p>Please enlighten.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Suraj Singh</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-36560</link>
		<dc:creator><![CDATA[Suraj Singh]]></dc:creator>
		<pubDate>Sat, 24 May 2014 04:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-36560</guid>
		<description><![CDATA[implementation of second method:

#include

#include

using namespace std;

struct node

{

    int a;

    node *next,*arb;

}*top = NULL;

int main()

{

    int t,n,i;

    cout&#060;&#062;n;

    for(i=0;    i&#062;t;

        temp-&#062;a = t;

        temp-&#062;next = temp-&#062;arb = NULL;

        if( top == NULL )

            top = temp;

        else

        {

            temp-&#062;next = top;

            top = temp;

        }

    }

    getch();

    cout&#060;&#062;t&#062;&#062;i;

        node *holdT = top,*holdI = top;

        while(holdT)

        {

            if(holdT-&#062;a == t)

                break;

            holdT = holdT-&#062;next;

        }

        while(holdI)

        {

            if(holdI-&#062;a == i)

                break;

            holdI = holdI-&#062;next;

        }

        holdT-&#062;arb = holdI;

    }

    getch();

    cout&#060;a = hold-&#062;a;

        temp-&#062;next = hold-&#062;next;

        hold-&#062;next = temp;

        hold = hold-&#062;next-&#062;next;

    }

    hold = top;

    while(hold)

    {

        hold-&#062;next-&#062;arb = hold-&#062;arb-&#062;next;

        hold = hold-&#062;next-&#062;next;

    }

    hold = top-&#062;next;

    while(hold)

    {

        cout&#060;a&#060;next)

            cout&#060;next-&#062;a&#060;&#060;&#034; &#038; &#034;;

        cout&#060;arb-&#062;a&#060;next == NULL)

            break;

        hold = hold-&#062;next-&#062;next;

    }

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>implementation of second method:</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>struct node</p>
<p>{</p>
<p>    int a;</p>
<p>    node *next,*arb;</p>
<p>}*top = NULL;</p>
<p>int main()</p>
<p>{</p>
<p>    int t,n,i;</p>
<p>    cout&lt;&gt;n;</p>
<p>    for(i=0;    i&gt;t;</p>
<p>        temp-&gt;a = t;</p>
<p>        temp-&gt;next = temp-&gt;arb = NULL;</p>
<p>        if( top == NULL )</p>
<p>            top = temp;</p>
<p>        else</p>
<p>        {</p>
<p>            temp-&gt;next = top;</p>
<p>            top = temp;</p>
<p>        }</p>
<p>    }</p>
<p>    getch();</p>
<p>    cout&lt;&gt;t&gt;&gt;i;</p>
<p>        node *holdT = top,*holdI = top;</p>
<p>        while(holdT)</p>
<p>        {</p>
<p>            if(holdT-&gt;a == t)</p>
<p>                break;</p>
<p>            holdT = holdT-&gt;next;</p>
<p>        }</p>
<p>        while(holdI)</p>
<p>        {</p>
<p>            if(holdI-&gt;a == i)</p>
<p>                break;</p>
<p>            holdI = holdI-&gt;next;</p>
<p>        }</p>
<p>        holdT-&gt;arb = holdI;</p>
<p>    }</p>
<p>    getch();</p>
<p>    cout&lt;a = hold-&gt;a;</p>
<p>        temp-&gt;next = hold-&gt;next;</p>
<p>        hold-&gt;next = temp;</p>
<p>        hold = hold-&gt;next-&gt;next;</p>
<p>    }</p>
<p>    hold = top;</p>
<p>    while(hold)</p>
<p>    {</p>
<p>        hold-&gt;next-&gt;arb = hold-&gt;arb-&gt;next;</p>
<p>        hold = hold-&gt;next-&gt;next;</p>
<p>    }</p>
<p>    hold = top-&gt;next;</p>
<p>    while(hold)</p>
<p>    {</p>
<p>        cout&lt;a&lt;next)</p>
<p>            cout&lt;next-&gt;a&lt;&lt;&quot; &amp; &quot;;</p>
<p>        cout&lt;arb-&gt;a&lt;next == NULL)</p>
<p>            break;</p>
<p>        hold = hold-&gt;next-&gt;next;</p>
<p>    }</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Zheng Luo</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-36011</link>
		<dc:creator><![CDATA[Zheng Luo]]></dc:creator>
		<pubDate>Wed, 14 May 2014 01:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-36011</guid>
		<description><![CDATA[http://ideone.com/lCl9E1]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/lCl9E1" rel="nofollow">http://ideone.com/lCl9E1</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: xgme</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-35755</link>
		<dc:creator><![CDATA[xgme]]></dc:creator>
		<pubDate>Wed, 07 May 2014 15:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-35755</guid>
		<description><![CDATA[When I first encountered this question I couldn&#039;t find the solution because I assumed the input is &quot;immutable&quot; as it is supposed to be in all software systems. I&#039;m glad I failed to answer because of a very good programming convention.]]></description>
		<content:encoded><![CDATA[<p>When I first encountered this question I couldn&#8217;t find the solution because I assumed the input is &#8220;immutable&#8221; as it is supposed to be in all software systems. I&#8217;m glad I failed to answer because of a very good programming convention.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pulkit mehra</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-33303</link>
		<dc:creator><![CDATA[pulkit mehra]]></dc:creator>
		<pubDate>Sat, 08 Mar 2014 17:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-33303</guid>
		<description><![CDATA[If the List has Read Only access then the above discussed methods will fail.

The method I came across uses  container of C++ STL. A map is actually an associative array which has a key and a value associated with that key.

Steps: (The code syntax isn&#039;t coming properly in comments so check online)

1. Copy the original list to new list with next pointers intact, leave arbit pointers for now

2. While copying make a map 
           &lt;code&gt;
           map  map_hash
            &lt;/code&gt;

In our case map will have the key as the original list node and value as copy list node

3 Map would be somewhat like this

           Original   --&#062;      Copy
            Node1    --&#062;      Node1(copy)
            Node2    --&#062;      Node2(copy)
            Node3    --&#062;      Node3(copy)

4 Start from head of copy list, corresponding to this copy list node we have the original list node in map. We can access it using an iterator.
            &lt;code&gt;
            map::iterator i
            i = map_hash.begin()
            copy_node-&#062;arbit = map_hash.at((*i).first-&#062;arbit)
            &lt;/code&gt;

Note:- (*i).first  =  original_List node
           (*i).first-&#062;arbit = arbitrary node pointed by (*i).first
           map_hash.at() gives the value stored at that key

What we are doing is for each copy_List node we take its corresponding original_List node then find its arbit node, next we use our map to find the node in our copy_List corresponding to this arbit node and assign it to the arbit pointer of the copy_List node

Hope this will help!!!]]></description>
		<content:encoded><![CDATA[<p>If the List has Read Only access then the above discussed methods will fail.</p>
<p>The method I came across uses  container of C++ STL. A map is actually an associative array which has a key and a value associated with that key.</p>
<p>Steps: (The code syntax isn&#8217;t coming properly in comments so check online)</p>
<p>1. Copy the original list to new list with next pointers intact, leave arbit pointers for now</p>
<p>2. While copying make a map<br />
           <code><br />
           map  map_hash<br />
            </code></p>
<p>In our case map will have the key as the original list node and value as copy list node</p>
<p>3 Map would be somewhat like this</p>
<p>           Original   &#8211;&gt;      Copy<br />
            Node1    &#8211;&gt;      Node1(copy)<br />
            Node2    &#8211;&gt;      Node2(copy)<br />
            Node3    &#8211;&gt;      Node3(copy)</p>
<p>4 Start from head of copy list, corresponding to this copy list node we have the original list node in map. We can access it using an iterator.<br />
            <code><br />
            map::iterator i<br />
            i = map_hash.begin()<br />
            copy_node-&gt;arbit = map_hash.at((*i).first-&gt;arbit)<br />
            </code></p>
<p>Note:- (*i).first  =  original_List node<br />
           (*i).first-&gt;arbit = arbitrary node pointed by (*i).first<br />
           map_hash.at() gives the value stored at that key</p>
<p>What we are doing is for each copy_List node we take its corresponding original_List node then find its arbit node, next we use our map to find the node in our copy_List corresponding to this arbit node and assign it to the arbit pointer of the copy_List node</p>
<p>Hope this will help!!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: darkpassenger</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-31586</link>
		<dc:creator><![CDATA[darkpassenger]]></dc:creator>
		<pubDate>Fri, 17 Jan 2014 15:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-31586</guid>
		<description><![CDATA[if we don&#039;t want to modify the original list the with the help of 2 hash maps u can clone it..........]]></description>
		<content:encoded><![CDATA[<p>if we don&#8217;t want to modify the original list the with the help of 2 hash maps u can clone it&#8230;&#8230;&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: neelabhsingh</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-30168</link>
		<dc:creator><![CDATA[neelabhsingh]]></dc:creator>
		<pubDate>Tue, 26 Nov 2013 20:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-30168</guid>
		<description><![CDATA[This problem can be done in two scan Linked List

1st Scan: In first scan change change next pointer of original LL to the corresponding same node in the new LL. and change random pointer of new LL to the corresponding same node of the original linked list.

current1 is pointing to the start node of the originalLL.

current2 is pointing to the start node of the newLL

current1=root1;// root node of the original node

current2=roott2// root node of the original node

while(current1!=NULL)

{

        temp=current1-&#062;next;

        current1-&#062;next=current2;

        current2-&#062;random=current1;

        current2=current2-&#062;next;

        current1=temp;

}

// Scan2

current1=root1;// root node of the original node
current2=roott2// root node of the original node

// current1-&#062;next is pointing to the new node so we can node use

while(current2!=NULL)
{
      current2-&#062;random=current2-&#062;random-&#062;random-&#062;next;
current2=current2-&#062;next

}]]></description>
		<content:encoded><![CDATA[<p>This problem can be done in two scan Linked List</p>
<p>1st Scan: In first scan change change next pointer of original LL to the corresponding same node in the new LL. and change random pointer of new LL to the corresponding same node of the original linked list.</p>
<p>current1 is pointing to the start node of the originalLL.</p>
<p>current2 is pointing to the start node of the newLL</p>
<p>current1=root1;// root node of the original node</p>
<p>current2=roott2// root node of the original node</p>
<p>while(current1!=NULL)</p>
<p>{</p>
<p>        temp=current1-&gt;next;</p>
<p>        current1-&gt;next=current2;</p>
<p>        current2-&gt;random=current1;</p>
<p>        current2=current2-&gt;next;</p>
<p>        current1=temp;</p>
<p>}</p>
<p>// Scan2</p>
<p>current1=root1;// root node of the original node<br />
current2=roott2// root node of the original node</p>
<p>// current1-&gt;next is pointing to the new node so we can node use</p>
<p>while(current2!=NULL)<br />
{<br />
      current2-&gt;random=current2-&gt;random-&gt;random-&gt;next;<br />
current2=current2-&gt;next</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pavansrinivas</title>
		<link>http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/#comment-29938</link>
		<dc:creator><![CDATA[pavansrinivas]]></dc:creator>
		<pubDate>Mon, 18 Nov 2013 07:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=1155#comment-29938</guid>
		<description><![CDATA[What if the Original list is read only???]]></description>
		<content:encoded><![CDATA[<p>What if the Original list is read only???</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.052 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:32:37 -->

<!-- Compression = gzip -->