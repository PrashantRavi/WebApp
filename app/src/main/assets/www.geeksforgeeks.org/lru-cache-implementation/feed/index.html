<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: LRU Cache Implementation</title>
	<atom:link href="http://www.geeksforgeeks.org/lru-cache-implementation/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/lru-cache-implementation/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: joy</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-36533</link>
		<dc:creator><![CDATA[joy]]></dc:creator>
		<pubDate>Fri, 23 May 2014 11:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-36533</guid>
		<description><![CDATA[I agree with Ritz,  also LFU does exist :) check out the ehcache library in Java]]></description>
		<content:encoded><![CDATA[<p>I agree with Ritz,  also LFU does exist ðŸ™‚ check out the ehcache library in Java</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Manish Gupta</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34415</link>
		<dc:creator><![CDATA[Manish Gupta]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 08:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34415</guid>
		<description><![CDATA[Great. Glad I could help :)]]></description>
		<content:encoded><![CDATA[<p>Great. Glad I could help ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34414</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 08:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34414</guid>
		<description><![CDATA[OK thanks for helping me out, It&#039;s clear now.... :)]]></description>
		<content:encoded><![CDATA[<p>OK thanks for helping me out, It&#8217;s clear now&#8230;. ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Manish Gupta</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34411</link>
		<dc:creator><![CDATA[Manish Gupta]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 07:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34411</guid>
		<description><![CDATA[Yes, but isn&#039;t it better to directly access the front and rear node when trying to add a new node to front of the queue/remove a node from rear of a queue. Even though we have prev and next pointers that facilitate us to traverse the queue, keeping these two additional pointers will ensure we don&#039;t have to traverse from the front all the way to the rear whenever a node from rear needs to be removed. In simple words, keeping them makes us able to do insertions and deletions in  O(1), as compared to O(n) when we have to traverse all the way front front till the rear end in order to remove the least recently used page. Hope this helps :)]]></description>
		<content:encoded><![CDATA[<p>Yes, but isn&#8217;t it better to directly access the front and rear node when trying to add a new node to front of the queue/remove a node from rear of a queue. Even though we have prev and next pointers that facilitate us to traverse the queue, keeping these two additional pointers will ensure we don&#8217;t have to traverse from the front all the way to the rear whenever a node from rear needs to be removed. In simple words, keeping them makes us able to do insertions and deletions in  O(1), as compared to O(n) when we have to traverse all the way front front till the rear end in order to remove the least recently used page. Hope this helps ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34410</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 06:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34410</guid>
		<description><![CDATA[That means we are having 4 pointers associated to each Qnode prev,next,front and rear right.... 
In the above implementation we are putting the MRU used page in front of queue and least recently used(LRU) on the rear end of queue. So, we need one front and rear for the queue only rather then specific front and rear for each node in queue.
This is because we already have next and prev associated with Qnode to move through different nodes inside Queue...]]></description>
		<content:encoded><![CDATA[<p>That means we are having 4 pointers associated to each Qnode prev,next,front and rear right&#8230;.<br />
In the above implementation we are putting the MRU used page in front of queue and least recently used(LRU) on the rear end of queue. So, we need one front and rear for the queue only rather then specific front and rear for each node in queue.<br />
This is because we already have next and prev associated with Qnode to move through different nodes inside Queue&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Manish Gupta</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34348</link>
		<dc:creator><![CDATA[Manish Gupta]]></dc:creator>
		<pubDate>Sun, 06 Apr 2014 02:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34348</guid>
		<description><![CDATA[Here, front and rear in themselves are pointers to particular nodes of the queue, which are of type Qnode*, where as Queue is a collection of various Qnode* type of nodes. So, they need to be Qnode*, not Queue *.
I hope things are clear now.]]></description>
		<content:encoded><![CDATA[<p>Here, front and rear in themselves are pointers to particular nodes of the queue, which are of type Qnode*, where as Queue is a collection of various Qnode* type of nodes. So, they need to be Qnode*, not Queue *.<br />
I hope things are clear now.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34267</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 18:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34267</guid>
		<description><![CDATA[We cannot use array queue because we need to remove the LRU page from the rear and then add the page to front, If we use array implementation then we need to traverse the array again and again to adjust the 0 and last index of array, so as to add the just used page in the front of array....which needs O(n) time and using Doubly Linked List we reduced it to O(1)...


This is one of the reason I could think of.]]></description>
		<content:encoded><![CDATA[<p>We cannot use array queue because we need to remove the LRU page from the rear and then add the page to front, If we use array implementation then we need to traverse the array again and again to adjust the 0 and last index of array, so as to add the just used page in the front of array&#8230;.which needs O(n) time and using Doubly Linked List we reduced it to O(1)&#8230;</p>
<p>This is one of the reason I could think of.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-34266</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 18:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-34266</guid>
		<description><![CDATA[typedef struct Queue
{
    unsigned count;  // Number of filled frames
    unsigned numberOfFrames; // total number of frames
    QNode *front, *rear;
} Queue;


I think it should be Queue *front, *rear instead of Qnode *front,*rear in above implementation.... Please correct me if I am 
wrong or misunderstanding the concept.]]></description>
		<content:encoded><![CDATA[<p>typedef struct Queue<br />
{<br />
    unsigned count;  // Number of filled frames<br />
    unsigned numberOfFrames; // total number of frames<br />
    QNode *front, *rear;<br />
} Queue;</p>
<p>I think it should be Queue *front, *rear instead of Qnode *front,*rear in above implementation&#8230;. Please correct me if I am<br />
wrong or misunderstanding the concept.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mari</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-33830</link>
		<dc:creator><![CDATA[Mari]]></dc:creator>
		<pubDate>Tue, 25 Mar 2014 12:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-33830</guid>
		<description><![CDATA[Thanks for the Java Implementation. there are some changes that need to be done. First, You are using ConcurrentLinkedQueue which is nothing but single linked list internally.  When we implement LRU, we normally use double linked list for efficiency.


Inside the put method, To remove the page from cache (queue), you have used queue.remove method, This will take o(n) in worst case. Rather A good implemetation should only take 6 pointe operations in worst case. The idea to avoid this extra time is to store the node inside the map and get the node from the map as required and change its next and previous. This is same idea as implemented above. 


Also you are removing the node from queue even it is accessed recently.]]></description>
		<content:encoded><![CDATA[<p>Thanks for the Java Implementation. there are some changes that need to be done. First, You are using ConcurrentLinkedQueue which is nothing but single linked list internally.  When we implement LRU, we normally use double linked list for efficiency.</p>
<p>Inside the put method, To remove the page from cache (queue), you have used queue.remove method, This will take o(n) in worst case. Rather A good implemetation should only take 6 pointe operations in worst case. The idea to avoid this extra time is to store the node inside the map and get the node from the map as required and change its next and previous. This is same idea as implemented above. </p>
<p>Also you are removing the node from queue even it is accessed recently.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nanda</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-32770</link>
		<dc:creator><![CDATA[nanda]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 21:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-32770</guid>
		<description><![CDATA[If the node is not deleted, won&#039;t there be wrong address in the hash table for the the older key?
For example, 8 is removed from tail and placed at head. Now the 8&#039;s address is still in hashtable. When 8 is referenced next time, 6 will found at the front at it will be returned.
Deletion from both linked list and hash table ensures this doesn&#039;t happen is what I understand.]]></description>
		<content:encoded><![CDATA[<p>If the node is not deleted, won&#8217;t there be wrong address in the hash table for the the older key?<br />
For example, 8 is removed from tail and placed at head. Now the 8&#8217;s address is still in hashtable. When 8 is referenced next time, 6 will found at the front at it will be returned.<br />
Deletion from both linked list and hash table ensures this doesn&#8217;t happen is what I understand.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ritz</title>
		<link>http://www.geeksforgeeks.org/lru-cache-implementation/#comment-32428</link>
		<dc:creator><![CDATA[ritz]]></dc:creator>
		<pubDate>Mon, 10 Feb 2014 22:06:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24498#comment-32428</guid>
		<description><![CDATA[Yes, you are missing something. Its an LRU cache, not an LFU(if it exists). The least RECENTLY used item has to be replaced and not the least FREQUENTLY used. So, its correct to replace C in your case.]]></description>
		<content:encoded><![CDATA[<p>Yes, you are missing something. Its an LRU cache, not an LFU(if it exists). The least RECENTLY used item has to be replaced and not the least FREQUENTLY used. So, its correct to replace C in your case.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:12:31 -->

<!-- Compression = gzip -->