<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Iterative Quick Sort</title>
	<atom:link href="http://www.geeksforgeeks.org/iterative-quick-sort/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/iterative-quick-sort/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: code_on</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-35566</link>
		<dc:creator><![CDATA[code_on]]></dc:creator>
		<pubDate>Sat, 03 May 2014 14:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-35566</guid>
		<description><![CDATA[1. To reduce the recursion depth, recur first for the smaller half of the array, and use a tail call to recurse into the other.

2. To reduce the stack size, first push the indexes of smaller half.

Please elaborate.
Thanks]]></description>
		<content:encoded><![CDATA[<p>1. To reduce the recursion depth, recur first for the smaller half of the array, and use a tail call to recurse into the other.</p>
<p>2. To reduce the stack size, first push the indexes of smaller half.</p>
<p>Please elaborate.<br />
Thanks</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Harman</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-35082</link>
		<dc:creator><![CDATA[Harman]]></dc:creator>
		<pubDate>Thu, 24 Apr 2014 20:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-35082</guid>
		<description><![CDATA[Quick Sort is a Sorting Algorithm based on Divide And Conquer Technique
I have also a good reference with Description, Program Example , Snapshot and Description of code .......its very simple explanation ..........

http://geeksprogrammings.blogspot.com/2014/02/algorithm-quick-sort-program.html]]></description>
		<content:encoded><![CDATA[<p>Quick Sort is a Sorting Algorithm based on Divide And Conquer Technique<br />
I have also a good reference with Description, Program Example , Snapshot and Description of code &#8230;&#8230;.its very simple explanation &#8230;&#8230;&#8230;.</p>
<p><a href="http://geeksprogrammings.blogspot.com/2014/02/algorithm-quick-sort-program.html" rel="nofollow">http://geeksprogrammings.blogspot.com/2014/02/algorithm-quick-sort-program.html</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nizamuddin Saifi</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-30199</link>
		<dc:creator><![CDATA[Nizamuddin Saifi]]></dc:creator>
		<pubDate>Thu, 28 Nov 2013 09:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-30199</guid>
		<description><![CDATA[ We can improve performance of partition function , by simple checking the a[j]!=a[++i] , it&#039;ll reduce number of time swap function will call. eg, 

&lt;code&gt;
int partition(int a[],int l,int h)
{
	int x=a[h];
	int i=l-1,j;

	for(j=l;j&#060;=h-1;++j)
	{
		if(a[j]&#060;x &#038;&#038; a[j]!=a[++i])
		{
			swap(&#038;a[j],&#038;a[i]);
		}
	}

	swap(&#038;a[i+1],&#038;a[h]);

	return i+1;
}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p> We can improve performance of partition function , by simple checking the a[j]!=a[++i] , it&#8217;ll reduce number of time swap function will call. eg, </p>
<p><code><br />
int partition(int a[],int l,int h)<br />
{<br />
	int x=a[h];<br />
	int i=l-1,j;</p>
<p>	for(j=l;j&lt;=h-1;++j)<br />
	{<br />
		if(a[j]&lt;x &amp;&amp; a[j]!=a[++i])<br />
		{<br />
			swap(&amp;a[j],&amp;a[i]);<br />
		}<br />
	}</p>
<p>	swap(&amp;a[i+1],&amp;a[h]);</p>
<p>	return i+1;<br />
}<br />
</code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: VIGY</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-28896</link>
		<dc:creator><![CDATA[VIGY]]></dc:creator>
		<pubDate>Tue, 15 Oct 2013 09:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-28896</guid>
		<description><![CDATA[THANK YOU SOOOOO MUCH :-)]]></description>
		<content:encoded><![CDATA[<p>THANK YOU SOOOOO MUCH ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksforGeeks</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-25465</link>
		<dc:creator><![CDATA[GeeksforGeeks]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 15:39:06 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-25465</guid>
		<description><![CDATA[It is a valid C99 syntax.  Please see http://en.wikipedia.org/wiki/C99]]></description>
		<content:encoded><![CDATA[<p>It is a valid C99 syntax.  Please see <a href="http://en.wikipedia.org/wiki/C99" rel="nofollow">http://en.wikipedia.org/wiki/C99</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sumit Gera</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-25464</link>
		<dc:creator><![CDATA[Sumit Gera]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 08:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-25464</guid>
		<description><![CDATA[Isn&#039;t using stack[h - l +1] an invalid syntax?]]></description>
		<content:encoded><![CDATA[<p>Isn&#039;t using stack[h &#8211; l +1] an invalid syntax?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kapil</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-16975</link>
		<dc:creator><![CDATA[kapil]]></dc:creator>
		<pubDate>Mon, 01 Apr 2013 11:52:36 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-16975</guid>
		<description><![CDATA[How will recursion depth be reduced if we recur smaller part of the array first?]]></description>
		<content:encoded><![CDATA[<p>How will recursion depth be reduced if we recur smaller part of the array first?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ???</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-25463</link>
		<dc:creator><![CDATA[???]]></dc:creator>
		<pubDate>Thu, 21 Feb 2013 15:43:29 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-25463</guid>
		<description><![CDATA[Not a kind explanation, but also terrific code I think! Thanks a lot!]]></description>
		<content:encoded><![CDATA[<p>Not a kind explanation, but also terrific code I think! Thanks a lot!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aashish Barnwal</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-25462</link>
		<dc:creator><![CDATA[Aashish Barnwal]]></dc:creator>
		<pubDate>Thu, 21 Feb 2013 03:41:48 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-25462</guid>
		<description><![CDATA[The boundaries high(h) and low(l) are not necessary to specify. However, the size of the array to be sorted is a must to pass as a parameter. So the method signature can be reduced to:
void quickSortIterative (int arr[], int size).]]></description>
		<content:encoded><![CDATA[<p>The boundaries high(h) and low(l) are not necessary to specify. However, the size of the array to be sorted is a must to pass as a parameter. So the method signature can be reduced to:<br />
void quickSortIterative (int arr[], int size).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aashish</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-15472</link>
		<dc:creator><![CDATA[Aashish]]></dc:creator>
		<pubDate>Thu, 21 Feb 2013 03:30:39 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-15472</guid>
		<description><![CDATA[The boundaries high(h) and low(l) are not necessary to specify. However, the size of the array to be sorted is a must to pass as a parameter.]]></description>
		<content:encoded><![CDATA[<p>The boundaries high(h) and low(l) are not necessary to specify. However, the size of the array to be sorted is a must to pass as a parameter.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kuldeep Tiwari</title>
		<link>http://www.geeksforgeeks.org/iterative-quick-sort/#comment-25461</link>
		<dc:creator><![CDATA[Kuldeep Tiwari]]></dc:creator>
		<pubDate>Wed, 20 Feb 2013 22:53:59 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=25294#comment-25461</guid>
		<description><![CDATA[With iterative implementation, we don&#039;t need parameters low(l) and high(h) in method Quicksort. Method signature reduces to - 
void quickSortIterative (int arr[]).]]></description>
		<content:encoded><![CDATA[<p>With iterative implementation, we don&#039;t need parameters low(l) and high(h) in method Quicksort. Method signature reduces to &#8211;<br />
void quickSortIterative (int arr[]).</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:08:23 -->

<!-- Compression = gzip -->