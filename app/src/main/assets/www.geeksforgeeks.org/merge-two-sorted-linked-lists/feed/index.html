<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Merge two sorted linked lists</title>
	<atom:link href="http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: thatsme</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-38242</link>
		<dc:creator><![CDATA[thatsme]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 19:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-38242</guid>
		<description><![CDATA[thanks for sharing...i liked your code :)]]></description>
		<content:encoded><![CDATA[<p>thanks for sharing&#8230;i liked your code ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nobody</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-37952</link>
		<dc:creator><![CDATA[nobody]]></dc:creator>
		<pubDate>Mon, 09 Jun 2014 04:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-37952</guid>
		<description><![CDATA[thanku :))]]></description>
		<content:encoded><![CDATA[<p>thanku :))</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: guest</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-37836</link>
		<dc:creator><![CDATA[guest]]></dc:creator>
		<pubDate>Sat, 07 Jun 2014 12:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-37836</guid>
		<description><![CDATA[download this pdf http://cslibrary.stanford.edu/105/LinkedListProblems.pdf
and read page 5-8]]></description>
		<content:encoded><![CDATA[<p>download this pdf <a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf" rel="nofollow">http://cslibrary.stanford.edu/105/LinkedListProblems.pdf</a><br />
and read page 5-8</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nobody</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-37791</link>
		<dc:creator><![CDATA[nobody]]></dc:creator>
		<pubDate>Sat, 07 Jun 2014 02:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-37791</guid>
		<description><![CDATA[Can sumone pls explain me  the dummy node concept? I dont get t at all . thanx]]></description>
		<content:encoded><![CDATA[<p>Can sumone pls explain me  the dummy node concept? I dont get t at all . thanx</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: typing..</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-36916</link>
		<dc:creator><![CDATA[typing..]]></dc:creator>
		<pubDate>Tue, 27 May 2014 14:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-36916</guid>
		<description><![CDATA[niceeeee...... I like dummy node concept.... but it is not required if the question demands in place merging..]]></description>
		<content:encoded><![CDATA[<p>niceeeee&#8230;&#8230; I like dummy node concept&#8230;. but it is not required if the question demands in place merging..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Gautam Goyal</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-36461</link>
		<dc:creator><![CDATA[Gautam Goyal]]></dc:creator>
		<pubDate>Thu, 22 May 2014 15:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-36461</guid>
		<description><![CDATA[Another clean solution, choose on the basis of head nodes, the final head and then from second list, insert wherever required.

Time complexity: O(m+n)

Space Complexity:O(1)

typedef struct node* Link;

Link sortedMerge(Link* head1, Link* head2){

	if(head1 == NULL)
		return *head2;

	if(head2 == NULL)
		return *head1;

	Link temp1,temp2,start,end,tempo,head;

	if((*head1)-&#062;data &#062; (*head2)-&#062;data){
		temp1 = *head2;
		temp2 = *head1;
		head = *head2;
	}

	else{
		temp1 = *head1;
		temp2 = *head2;
		head = *head1;
	}

	if(temp1-&#062;next == NULL){
		temp1-&#062;next = temp2;
		return head;
	}

	while(temp1 != NULL &#038;&#038; temp2 != NULL){
		if( temp1-&#062;next == NULL)
			break;
		end = temp2;
		while(end-&#062;next != NULL &#038;&#038; end-&#062;next-&#062;data next-&#062;data)			end = end-&#062;next;
		tempo = temp1-&#062;next;
		temp1-&#062;next = temp2;
                temp2 = end-&#062;next;
		end-&#062;next = tempo;
		temp1 = tempo;
		end = temp2;
		}

	if(temp1-&#062;next == NULL)
		temp1-&#062;next = temp2;

	return head;

	

}]]></description>
		<content:encoded><![CDATA[<p>Another clean solution, choose on the basis of head nodes, the final head and then from second list, insert wherever required.</p>
<p>Time complexity: O(m+n)</p>
<p>Space Complexity:O(1)</p>
<p>typedef struct node* Link;</p>
<p>Link sortedMerge(Link* head1, Link* head2){</p>
<p>	if(head1 == NULL)<br />
		return *head2;</p>
<p>	if(head2 == NULL)<br />
		return *head1;</p>
<p>	Link temp1,temp2,start,end,tempo,head;</p>
<p>	if((*head1)-&gt;data &gt; (*head2)-&gt;data){<br />
		temp1 = *head2;<br />
		temp2 = *head1;<br />
		head = *head2;<br />
	}</p>
<p>	else{<br />
		temp1 = *head1;<br />
		temp2 = *head2;<br />
		head = *head1;<br />
	}</p>
<p>	if(temp1-&gt;next == NULL){<br />
		temp1-&gt;next = temp2;<br />
		return head;<br />
	}</p>
<p>	while(temp1 != NULL &amp;&amp; temp2 != NULL){<br />
		if( temp1-&gt;next == NULL)<br />
			break;<br />
		end = temp2;<br />
		while(end-&gt;next != NULL &amp;&amp; end-&gt;next-&gt;data next-&gt;data)			end = end-&gt;next;<br />
		tempo = temp1-&gt;next;<br />
		temp1-&gt;next = temp2;<br />
                temp2 = end-&gt;next;<br />
		end-&gt;next = tempo;<br />
		temp1 = tempo;<br />
		end = temp2;<br />
		}</p>
<p>	if(temp1-&gt;next == NULL)<br />
		temp1-&gt;next = temp2;</p>
<p>	return head;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-36460</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 22 May 2014 15:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-36460</guid>
		<description><![CDATA[Another clean solution, choose on the basis of head nodes the final head and then from second list, insert wherever required.
Time complexity: O(m+n)

Space Complexity:O(1)
typedef struct node* Link;
Link sortedMerge(Link* head1, Link* head2){

	if(head1 == NULL)

		return *head2;

	if(head2 == NULL)

		return *head1;

	Link temp1,temp2,start,end,tempo,head;

	if((*head1)-&#062;data &#062; (*head2)-&#062;data){

		temp1 = *head2;

		temp2 = *head1;

		head = *head2;

	}

	else{

		temp1 = *head1;

		temp2 = *head2;

		head = *head1;

	}

	if(temp1-&#062;next == NULL){

		temp1-&#062;next = temp2;

		return head;

	}

	while(temp1 != NULL &#038;&#038; temp2 != NULL){

		if( temp1-&#062;next == NULL)

			break;

		start = temp2;

		end = temp2;

		while(end-&#062;next != NULL &#038;&#038; end-&#062;next-&#062;data next-&#062;data)

			end = end-&#062;next;

		

		temp2 = end-&#062;next;

		tempo = temp1-&#062;next;

		temp1-&#062;next = start;

		end-&#062;next = tempo;

		temp1 = tempo;

		end = temp2;

		start = temp2;

	}

	if(temp1-&#062;next == NULL)

		temp1-&#062;next = temp2;

	return head;

	

}]]></description>
		<content:encoded><![CDATA[<p>Another clean solution, choose on the basis of head nodes the final head and then from second list, insert wherever required.<br />
Time complexity: O(m+n)</p>
<p>Space Complexity:O(1)<br />
typedef struct node* Link;<br />
Link sortedMerge(Link* head1, Link* head2){</p>
<p>	if(head1 == NULL)</p>
<p>		return *head2;</p>
<p>	if(head2 == NULL)</p>
<p>		return *head1;</p>
<p>	Link temp1,temp2,start,end,tempo,head;</p>
<p>	if((*head1)-&gt;data &gt; (*head2)-&gt;data){</p>
<p>		temp1 = *head2;</p>
<p>		temp2 = *head1;</p>
<p>		head = *head2;</p>
<p>	}</p>
<p>	else{</p>
<p>		temp1 = *head1;</p>
<p>		temp2 = *head2;</p>
<p>		head = *head1;</p>
<p>	}</p>
<p>	if(temp1-&gt;next == NULL){</p>
<p>		temp1-&gt;next = temp2;</p>
<p>		return head;</p>
<p>	}</p>
<p>	while(temp1 != NULL &amp;&amp; temp2 != NULL){</p>
<p>		if( temp1-&gt;next == NULL)</p>
<p>			break;</p>
<p>		start = temp2;</p>
<p>		end = temp2;</p>
<p>		while(end-&gt;next != NULL &amp;&amp; end-&gt;next-&gt;data next-&gt;data)</p>
<p>			end = end-&gt;next;</p>
<p>		temp2 = end-&gt;next;</p>
<p>		tempo = temp1-&gt;next;</p>
<p>		temp1-&gt;next = start;</p>
<p>		end-&gt;next = tempo;</p>
<p>		temp1 = tempo;</p>
<p>		end = temp2;</p>
<p>		start = temp2;</p>
<p>	}</p>
<p>	if(temp1-&gt;next == NULL)</p>
<p>		temp1-&gt;next = temp2;</p>
<p>	return head;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Arun</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-35853</link>
		<dc:creator><![CDATA[Arun]]></dc:creator>
		<pubDate>Fri, 09 May 2014 23:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-35853</guid>
		<description><![CDATA[The idea is using a dummy node is the crux. Its smart! 

Rest of the code could be simple and straightforward as in  http://ideone.com/IvVXxL. 

Node * MergeLists( Node * headA, Node * headB ) {

    Node dummy;
Node * tail = &#038; dummy;
Node * pa = 0;
Node * pb = 0;

    for( pa = headA, pb = headB; pa &#038;&#038; pb; ) {

        if( pa-&#062;data data ) {
tail-&#062;next = pa;
tail = pa;
pa = pa-&#062;next;
}
else {
tail-&#062;next = pb;
tail = pb;
pb = pb-&#062;next;
}

    }

    tail-&#062;next = pa ? pa : pb;
return dummy.next;
}]]></description>
		<content:encoded><![CDATA[<p>The idea is using a dummy node is the crux. Its smart! </p>
<p>Rest of the code could be simple and straightforward as in  <a href="http://ideone.com/IvVXxL" rel="nofollow">http://ideone.com/IvVXxL</a>. </p>
<p>Node * MergeLists( Node * headA, Node * headB ) {</p>
<p>    Node dummy;<br />
Node * tail = &amp; dummy;<br />
Node * pa = 0;<br />
Node * pb = 0;</p>
<p>    for( pa = headA, pb = headB; pa &amp;&amp; pb; ) {</p>
<p>        if( pa-&gt;data data ) {<br />
tail-&gt;next = pa;<br />
tail = pa;<br />
pa = pa-&gt;next;<br />
}<br />
else {<br />
tail-&gt;next = pb;<br />
tail = pb;<br />
pb = pb-&gt;next;<br />
}</p>
<p>    }</p>
<p>    tail-&gt;next = pa ? pa : pb;<br />
return dummy.next;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AMIT JAMBOTKAR</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-35030</link>
		<dc:creator><![CDATA[AMIT JAMBOTKAR]]></dc:creator>
		<pubDate>Wed, 23 Apr 2014 14:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-35030</guid>
		<description><![CDATA[JAVA IMPLEMENTATION OF METHOD 1 AND METHOD 3



 * @author Virus

 */

public class LinkedList implements Cloneable {

    Node head = null;

    Node tail = null;

    // Adding at the End

    class Node {

        T value;

        Node nextReference;

        public Node(T value) {

            this.value = value;

            this.nextReference = null;

        }

        public Node(T value, Node ref) {

            this.value = value;

            this.nextReference = ref;

        }

        public Node() {

            // TODO Auto-generated constructor stub

        }

        public T getValue() {

            return value;

        }

        public void setValue(T value) {

            this.value = value;

        }

        public Node getNextReference() {

            return nextReference;

        }

        public void setNextReference(Node nextReference) {

            this.nextReference = nextReference;

        }

    }

    public void add(E value) {

        Node l = tail;

        Node node = new Node(value);

        tail = node;

        if (head == null) {

            head = node;

        } else {

            l.setNextReference(node);

        }

    }

    public void add(Node node) {

        if (validate(head)) {

            head = node;

        } else {

            tail.setNextReference(node);

        }

    }

    Node mergeTwoSortedLinkedList(LinkedList linkedList, LinkedList linkedList1) {

        LinkedList mergedList = new LinkedList();

        Node head1 = linkedList.head;//123 123345

        Node head2 = linkedList1.head;

        while (head1 != null &#038;&#038; head2 != null) {

            if (head1.getValue().doubleValue() &#060;= head2.getValue().doubleValue()) {

                mergedList.add(head1.getValue());

                head1 = head1.getNextReference();

            } else {

                mergedList.add(head2.getValue());

                head2 = head2.getNextReference();

            }

        }

        if (head1 == null) {

            mergedList.add(head2);

        }

        if (head2 == null) {

            mergedList.add(head1);

        }

        return mergedList.head;

    }

  

    void printAll(Node node) {

        while (node != null) {

            System.out.println(node.getValue());

            node = node.getNextReference();

        }

    }

    Node usingRecursive(Node head, Node head1) {

        Node result = null;// 134 3456

        if (head == null) {

            return head1;

        }

        if (head1 == null) {

            return head;

        }

        if (head.getValue().doubleValue() &#060;= head1.getValue().doubleValue()) { //true

            result = head;    //1 3 4

            result.nextReference = usingRecursive(head.getNextReference(), head1);

        } else {

            result = head1;

            result.nextReference = usingRecursive(head, head1.getNextReference());

        }

        return result;

    }

    Node recursiveCall(LinkedList linkedList, LinkedList linkedList1) {

        return usingRecursive(linkedList.head, linkedList1.head);

    }

    public boolean validate(Node head) {

        if (head == null) {

            return true;

        }

        return false;

    }

    public static void main(String[] args) {

        LinkedList linkedList = new LinkedList();

        LinkedList linkedList1 = new LinkedList();

        linkedList.add(1);

        linkedList.add(2);

        linkedList.add(3);

        System.out.println(&quot;List1&quot;);

        linkedList.printAll(linkedList.head);

        linkedList1.add(1);

        linkedList1.add(2);

        linkedList1.add(3);

        linkedList1.add(3);

        linkedList1.add(4);

        linkedList1.add(5);

        System.out.println(&quot;List2&quot;);

        linkedList1.printAll(linkedList1.head);

        linkedList.printAll(linkedList.mergeTwoSortedLinkedList(linkedList, linkedList1));

        linkedList.printAll(linkedList.recursiveCall(linkedList, linkedList1));

    }

}]]></description>
		<content:encoded><![CDATA[<p>JAVA IMPLEMENTATION OF METHOD 1 AND METHOD 3</p>
<p> * @author Virus</p>
<p> */</p>
<p>public class LinkedList implements Cloneable {</p>
<p>    Node head = null;</p>
<p>    Node tail = null;</p>
<p>    // Adding at the End</p>
<p>    class Node {</p>
<p>        T value;</p>
<p>        Node nextReference;</p>
<p>        public Node(T value) {</p>
<p>            this.value = value;</p>
<p>            this.nextReference = null;</p>
<p>        }</p>
<p>        public Node(T value, Node ref) {</p>
<p>            this.value = value;</p>
<p>            this.nextReference = ref;</p>
<p>        }</p>
<p>        public Node() {</p>
<p>            // TODO Auto-generated constructor stub</p>
<p>        }</p>
<p>        public T getValue() {</p>
<p>            return value;</p>
<p>        }</p>
<p>        public void setValue(T value) {</p>
<p>            this.value = value;</p>
<p>        }</p>
<p>        public Node getNextReference() {</p>
<p>            return nextReference;</p>
<p>        }</p>
<p>        public void setNextReference(Node nextReference) {</p>
<p>            this.nextReference = nextReference;</p>
<p>        }</p>
<p>    }</p>
<p>    public void add(E value) {</p>
<p>        Node l = tail;</p>
<p>        Node node = new Node(value);</p>
<p>        tail = node;</p>
<p>        if (head == null) {</p>
<p>            head = node;</p>
<p>        } else {</p>
<p>            l.setNextReference(node);</p>
<p>        }</p>
<p>    }</p>
<p>    public void add(Node node) {</p>
<p>        if (validate(head)) {</p>
<p>            head = node;</p>
<p>        } else {</p>
<p>            tail.setNextReference(node);</p>
<p>        }</p>
<p>    }</p>
<p>    Node mergeTwoSortedLinkedList(LinkedList linkedList, LinkedList linkedList1) {</p>
<p>        LinkedList mergedList = new LinkedList();</p>
<p>        Node head1 = linkedList.head;//123 123345</p>
<p>        Node head2 = linkedList1.head;</p>
<p>        while (head1 != null &amp;&amp; head2 != null) {</p>
<p>            if (head1.getValue().doubleValue() &lt;= head2.getValue().doubleValue()) {</p>
<p>                mergedList.add(head1.getValue());</p>
<p>                head1 = head1.getNextReference();</p>
<p>            } else {</p>
<p>                mergedList.add(head2.getValue());</p>
<p>                head2 = head2.getNextReference();</p>
<p>            }</p>
<p>        }</p>
<p>        if (head1 == null) {</p>
<p>            mergedList.add(head2);</p>
<p>        }</p>
<p>        if (head2 == null) {</p>
<p>            mergedList.add(head1);</p>
<p>        }</p>
<p>        return mergedList.head;</p>
<p>    }</p>
<p>    void printAll(Node node) {</p>
<p>        while (node != null) {</p>
<p>            System.out.println(node.getValue());</p>
<p>            node = node.getNextReference();</p>
<p>        }</p>
<p>    }</p>
<p>    Node usingRecursive(Node head, Node head1) {</p>
<p>        Node result = null;// 134 3456</p>
<p>        if (head == null) {</p>
<p>            return head1;</p>
<p>        }</p>
<p>        if (head1 == null) {</p>
<p>            return head;</p>
<p>        }</p>
<p>        if (head.getValue().doubleValue() &lt;= head1.getValue().doubleValue()) { //true</p>
<p>            result = head;    //1 3 4</p>
<p>            result.nextReference = usingRecursive(head.getNextReference(), head1);</p>
<p>        } else {</p>
<p>            result = head1;</p>
<p>            result.nextReference = usingRecursive(head, head1.getNextReference());</p>
<p>        }</p>
<p>        return result;</p>
<p>    }</p>
<p>    Node recursiveCall(LinkedList linkedList, LinkedList linkedList1) {</p>
<p>        return usingRecursive(linkedList.head, linkedList1.head);</p>
<p>    }</p>
<p>    public boolean validate(Node head) {</p>
<p>        if (head == null) {</p>
<p>            return true;</p>
<p>        }</p>
<p>        return false;</p>
<p>    }</p>
<p>    public static void main(String[] args) {</p>
<p>        LinkedList linkedList = new LinkedList();</p>
<p>        LinkedList linkedList1 = new LinkedList();</p>
<p>        linkedList.add(1);</p>
<p>        linkedList.add(2);</p>
<p>        linkedList.add(3);</p>
<p>        System.out.println(&#8220;List1&#8221;);</p>
<p>        linkedList.printAll(linkedList.head);</p>
<p>        linkedList1.add(1);</p>
<p>        linkedList1.add(2);</p>
<p>        linkedList1.add(3);</p>
<p>        linkedList1.add(3);</p>
<p>        linkedList1.add(4);</p>
<p>        linkedList1.add(5);</p>
<p>        System.out.println(&#8220;List2&#8221;);</p>
<p>        linkedList1.printAll(linkedList1.head);</p>
<p>        linkedList.printAll(linkedList.mergeTwoSortedLinkedList(linkedList, linkedList1));</p>
<p>        linkedList.printAll(linkedList.recursiveCall(linkedList, linkedList1));</p>
<p>    }</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-32314</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Fri, 07 Feb 2014 13:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-32314</guid>
		<description><![CDATA[For combined code we can refer to below Ideone link

http://ideone.com/wzxhi1]]></description>
		<content:encoded><![CDATA[<p>For combined code we can refer to below Ideone link</p>
<p><a href="http://ideone.com/wzxhi1" rel="nofollow">http://ideone.com/wzxhi1</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Himanshu Dagar</title>
		<link>http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/#comment-32315</link>
		<dc:creator><![CDATA[Himanshu Dagar]]></dc:creator>
		<pubDate>Fri, 07 Feb 2014 13:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=3622#comment-32315</guid>
		<description><![CDATA[For combined code we can refer to below Ideone link

http://ideone.com/wzxhi1]]></description>
		<content:encoded><![CDATA[<p>For combined code we can refer to below Ideone link</p>
<p><a href="http://ideone.com/wzxhi1" rel="nofollow">http://ideone.com/wzxhi1</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.102 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:59:45 -->

<!-- Compression = gzip -->