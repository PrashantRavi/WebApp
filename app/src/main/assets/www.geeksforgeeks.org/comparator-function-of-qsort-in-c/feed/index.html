<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Comparator function of qsort() in C</title>
	<atom:link href="http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: spider</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-35832</link>
		<dc:creator><![CDATA[spider]]></dc:creator>
		<pubDate>Fri, 09 May 2014 06:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-35832</guid>
		<description><![CDATA[plz publish some post regarding this question]]></description>
		<content:encoded><![CDATA[<p>plz publish some post regarding this question</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ronny</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20661</link>
		<dc:creator><![CDATA[Ronny]]></dc:creator>
		<pubDate>Wed, 26 Jun 2013 11:50:29 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20661</guid>
		<description><![CDATA[@aset Thank you very much.
I got to know a new approach/concept
Very nice explaination.
I was trying this for past few days and you cleared most of my doubts.
But I wanted to know one thing, if we were to sort, say even indices in increasing order and the odd indices in decreasing order,then  how do we go about it.

One approach would be to initially copy the matrix into another array, for the first array make the odd indices equal to 1 and sort in inc order. Similarly, for the second array, make the elements at the even indices to 1 and sort in decreasing order. Then copy odd indexed elements to original array.

Any other approach can you suggest. Something which does not involve creating another array, I mean inplace sorting.]]></description>
		<content:encoded><![CDATA[<p>@aset Thank you very much.<br />
I got to know a new approach/concept<br />
Very nice explaination.<br />
I was trying this for past few days and you cleared most of my doubts.<br />
But I wanted to know one thing, if we were to sort, say even indices in increasing order and the odd indices in decreasing order,then  how do we go about it.</p>
<p>One approach would be to initially copy the matrix into another array, for the first array make the odd indices equal to 1 and sort in inc order. Similarly, for the second array, make the elements at the even indices to 1 and sort in decreasing order. Then copy odd indexed elements to original array.</p>
<p>Any other approach can you suggest. Something which does not involve creating another array, I mean inplace sorting.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aset</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20604</link>
		<dc:creator><![CDATA[Aset]]></dc:creator>
		<pubDate>Tue, 25 Jun 2013 17:53:24 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20604</guid>
		<description><![CDATA[Hi,

&quot;xarr&quot; is used to retain the order of sorted elements with odd (if starting with 1) indices.

The approach is very simple: instead of sorting individual integers, it sorts the pairs, based on the first integer in pair.

5 4 3 2 1 9 would become seen to the algorithm as [5 4] [3 2] [1 9]
after sorting, the pairs will be reordered as follows:
[1 9] [3 2] [5 4]
1 9 3 2 5 4
The &quot;xarr&quot; array will store 1 9 3 2 5 4. The odd elements in it are sorted.
sorting internal pairs would give ya
1 [9 3] [2 5] [4 END]
1 [2 5] [4 END] [9 3]
1 2 5 4 END 9 3
merging this one with &quot;xarr&quot;
(1) 9 (3) 2 (5) 4
using only odd indexed members (in parentheses) will give you the result:
1 2 3 4 5 9]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>&#8220;xarr&#8221; is used to retain the order of sorted elements with odd (if starting with 1) indices.</p>
<p>The approach is very simple: instead of sorting individual integers, it sorts the pairs, based on the first integer in pair.</p>
<p>5 4 3 2 1 9 would become seen to the algorithm as [5 4] [3 2] [1 9]<br />
after sorting, the pairs will be reordered as follows:<br />
[1 9] [3 2] [5 4]<br />
1 9 3 2 5 4<br />
The &#8220;xarr&#8221; array will store 1 9 3 2 5 4. The odd elements in it are sorted.<br />
sorting internal pairs would give ya<br />
1 [9 3] [2 5] [4 END]<br />
1 [2 5] [4 END] [9 3]<br />
1 2 5 4 END 9 3<br />
merging this one with &#8220;xarr&#8221;<br />
(1) 9 (3) 2 (5) 4<br />
using only odd indexed members (in parentheses) will give you the result:<br />
1 2 3 4 5 9</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ronny</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20599</link>
		<dc:creator><![CDATA[Ronny]]></dc:creator>
		<pubDate>Tue, 25 Jun 2013 16:47:37 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20599</guid>
		<description><![CDATA[@aset why did u copied the array into another one &quot;xarr&quot;, if you were not going to use it.
You just copied it but never used it once.
Looking forward to know the approach.]]></description>
		<content:encoded><![CDATA[<p>@aset why did u copied the array into another one &#8220;xarr&#8221;, if you were not going to use it.<br />
You just copied it but never used it once.<br />
Looking forward to know the approach.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aset</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20596</link>
		<dc:creator><![CDATA[Aset]]></dc:creator>
		<pubDate>Tue, 25 Jun 2013 16:29:25 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20596</guid>
		<description><![CDATA[This one requires extra O(N) space (as is with separate indices arrays of structs in previous solutions)


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;

// Compare first int value of two ints passed to comparator
int comparator(const void *p, const void *q) 
{
    // Get the values at given addresses
    int l = *(const int *)p;
    int r = *(const int *)q;

    return l - r;
}

int main()
{
// ...

// Do two qsort passes, remembering the first pass results

// First pass is going to sort odd indices
    qsort((void*)arr, size / 2, sizeof(arr[0]) * 2, comparator);

// Remember the order of the odd indices
    xarr = (int*)calloc(size, sizeof(arr[0]));
    memcpy((void*)xarr, (const void*)arr, size * sizeof(arr[0]));

// Second pass is sorting even indices
    qsort((void*)(arr + 1), size / 2, sizeof(arr[0]) * 2, comparator);

// Merge the two arrays
    for(i = 0; i &#060; size; ++i)
        if(!(i &#038; 1)) 
            arr[i] = xarr[i];

// ...

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>This one requires extra O(N) space (as is with separate indices arrays of structs in previous solutions)</p>
<pre> <code language="C">

// Compare first int value of two ints passed to comparator
int comparator(const void *p, const void *q) 
{
    // Get the values at given addresses
    int l = *(const int *)p;
    int r = *(const int *)q;

    return l - r;
}

int main()
{
// ...

// Do two qsort passes, remembering the first pass results

// First pass is going to sort odd indices
    qsort((void*)arr, size / 2, sizeof(arr[0]) * 2, comparator);

// Remember the order of the odd indices
    xarr = (int*)calloc(size, sizeof(arr[0]));
    memcpy((void*)xarr, (const void*)arr, size * sizeof(arr[0]));

// Second pass is sorting even indices
    qsort((void*)(arr + 1), size / 2, sizeof(arr[0]) * 2, comparator);

// Merge the two arrays
    for(i = 0; i &lt; size; ++i)
        if(!(i &amp; 1)) 
            arr[i] = xarr[i];

// ...

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: kartik</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20289</link>
		<dc:creator><![CDATA[kartik]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 20:12:49 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20289</guid>
		<description><![CDATA[We will soon be publishing a post on this.]]></description>
		<content:encoded><![CDATA[<p>We will soon be publishing a post on this.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ronny</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20269</link>
		<dc:creator><![CDATA[ronny]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 14:23:36 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20269</guid>
		<description><![CDATA[@geeksforgeeks @kartik @sandeep @venki @ashishbarnwal @kartik
Plz help me on this question.]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks @kartik @sandeep @venki @ashishbarnwal @kartik<br />
Plz help me on this question.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ronny</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20107</link>
		<dc:creator><![CDATA[ronny]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 14:43:53 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20107</guid>
		<description><![CDATA[@kartik
Hey thanks for your response
For the first part, I guess modifying the array won&#039;t be a feasible option.
And as far as second option/approach you gave, if we create a structure with index stored but doesn&#039;t the comparator function check for the adjacent elements only. For example I am posting a sample code, correct me if I am wrong, the given code doesn&#039;t produce the desired result 


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include&#060;stdio.h&#062;

struct array
{
        int data;
        int ind;
};

int cmp(const struct array * a,const struct array * b)
{
    if(a-&#062;ind%2==0 &#038;&#038; b-&#062;ind%2==0)
      return b-&#062;data-a-&#062;data;    // if even indexed sort in decreasing order

    else if(a-&#062;ind%2!=0 &#038;&#038; b-&#062;ind%2!=0)
      return a-&#062;data-b-&#062;data;       // if odd indexed sort in increasing order

    else
      return 0;   // do not change if one is odd-indexed and other is even-indexed
}

int main()
{
    struct array arr[]={{1,0},{2,1},{3,2},{12,3},{5,4},{17,5},{7,6},{14,7}};

    int n=sizeof(arr)/sizeof(arr[0]);

    qsort(arr,n,sizeof(arr[0]),cmp);

    int i;
    for(i=0;i&#060;n;i++)
      printf(&#034;%d  &#034;,arr[i].data);

    return 0;
}

&lt;/code&gt; &lt;/pre&gt;

So any input from your side would be very helpful. I am still trying this question as it is a very good post to maneuver the inbuilt qsort according to any condition.
Thanks for your reply and precious time you spent to answer my queries.]]></description>
		<content:encoded><![CDATA[<p>@kartik<br />
Hey thanks for your response<br />
For the first part, I guess modifying the array won&#8217;t be a feasible option.<br />
And as far as second option/approach you gave, if we create a structure with index stored but doesn&#8217;t the comparator function check for the adjacent elements only. For example I am posting a sample code, correct me if I am wrong, the given code doesn&#8217;t produce the desired result </p>
<pre> <code language="C">
#include&lt;stdio.h&gt;

struct array
{
        int data;
        int ind;
};

int cmp(const struct array * a,const struct array * b)
{
    if(a-&gt;ind%2==0 &amp;&amp; b-&gt;ind%2==0)
      return b-&gt;data-a-&gt;data;    // if even indexed sort in decreasing order

    else if(a-&gt;ind%2!=0 &amp;&amp; b-&gt;ind%2!=0)
      return a-&gt;data-b-&gt;data;       // if odd indexed sort in increasing order

    else
      return 0;   // do not change if one is odd-indexed and other is even-indexed
}

int main()
{
    struct array arr[]={{1,0},{2,1},{3,2},{12,3},{5,4},{17,5},{7,6},{14,7}};

    int n=sizeof(arr)/sizeof(arr[0]);

    qsort(arr,n,sizeof(arr[0]),cmp);

    int i;
    for(i=0;i&lt;n;i++)
      printf(&quot;%d  &quot;,arr[i].data);

    return 0;
}

</code> </pre>
<p>So any input from your side would be very helpful. I am still trying this question as it is a very good post to maneuver the inbuilt qsort according to any condition.<br />
Thanks for your reply and precious time you spent to answer my queries.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kartik</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20066</link>
		<dc:creator><![CDATA[kartik]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 06:40:23 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20066</guid>
		<description><![CDATA[I can think of two ways:

One is simple method, modify input array to place the even indexed numbers in first half and odd indexed numbers in second half. Apply qsort() to two parts separately. Re-modify the array to place the numbers separately.
Input: 10, 5, 4, 12, 3, 8
This is in the form a1b2c3, convert it to abc123.
Modify: 10, 4, 3, 5, 12, 8
Sort two parts: 3, 4, 10, 5, 8, 12
This is in the form abc123,
Convert it to a1b2c3.

Another method (if we are not allowed to separate even and odd elements as first step OR if we are allowed to apply qsort() only once)
Create an auxiliary array of structures where every element of structure contains index and value.  Now write your comparator method such that it considers indexes while comparing two structure elements.  Sort the array of structures using your comparator method.]]></description>
		<content:encoded><![CDATA[<p>I can think of two ways:</p>
<p>One is simple method, modify input array to place the even indexed numbers in first half and odd indexed numbers in second half. Apply qsort() to two parts separately. Re-modify the array to place the numbers separately.<br />
Input: 10, 5, 4, 12, 3, 8<br />
This is in the form a1b2c3, convert it to abc123.<br />
Modify: 10, 4, 3, 5, 12, 8<br />
Sort two parts: 3, 4, 10, 5, 8, 12<br />
This is in the form abc123,<br />
Convert it to a1b2c3.</p>
<p>Another method (if we are not allowed to separate even and odd elements as first step OR if we are allowed to apply qsort() only once)<br />
Create an auxiliary array of structures where every element of structure contains index and value.  Now write your comparator method such that it considers indexes while comparing two structure elements.  Sort the array of structures using your comparator method.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ronny</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-20022</link>
		<dc:creator><![CDATA[ronny]]></dc:creator>
		<pubDate>Tue, 18 Jun 2013 13:24:25 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-20022</guid>
		<description><![CDATA[@geeksforgeeks @kartik @sandeep @kartik @ashishbarnwal

Plz can anyone explain how to do the exercise question.
I am stuck at it for the whole day.
But cannot proceed. How do we handle the index thing.
I tried incrementing and decrementing the pointer of a and b.
Any help would be appreciated.]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks @kartik @sandeep @kartik @ashishbarnwal</p>
<p>Plz can anyone explain how to do the exercise question.<br />
I am stuck at it for the whole day.<br />
But cannot proceed. How do we handle the index thing.<br />
I tried incrementing and decrementing the pointer of a and b.<br />
Any help would be appreciated.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ultimate_coder</title>
		<link>http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/#comment-18777</link>
		<dc:creator><![CDATA[ultimate_coder]]></dc:creator>
		<pubDate>Tue, 28 May 2013 09:15:40 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=116095#comment-18777</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;stdio.h&#062;
#include &#060;stdlib.h&#062;
int comparator(const void * p, const void * q)
{
    int l=*((const int *)p);
    int n=*((const int *)q);
    if((((const int *)p - (const int *)q)%2)==0)
    return (l-n);
    else
    return 0;
}
void printArr(int arr[], int n)
{
    int i;
    for (i = 0; i &#060; n; ++i)
        printf(&#034;%d &#034;, arr[i]);
}
int main()
{
    int arr[] = {1, 6, 5, 2, 3, 9, 4, 7, 8};

    int size = sizeof(arr) / sizeof(arr[0]);
    qsort((void *)arr,size,sizeof(arr[0]),comparator);

    printf(&#034;Output array is\n&#034;);
    printArr(arr, size);

    return 0;
}

&lt;/code&gt; &lt;/pre&gt;

what&#039;s wrong in this??]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int comparator(const void * p, const void * q)
{
    int l=*((const int *)p);
    int n=*((const int *)q);
    if((((const int *)p - (const int *)q)%2)==0)
    return (l-n);
    else
    return 0;
}
void printArr(int arr[], int n)
{
    int i;
    for (i = 0; i &lt; n; ++i)
        printf(&quot;%d &quot;, arr[i]);
}
int main()
{
    int arr[] = {1, 6, 5, 2, 3, 9, 4, 7, 8};

    int size = sizeof(arr) / sizeof(arr[0]);
    qsort((void *)arr,size,sizeof(arr[0]),comparator);

    printf(&quot;Output array is\n&quot;);
    printArr(arr, size);

    return 0;
}

</code> </pre>
<p>what&#8217;s wrong in this??</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.082 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:29:28 -->

<!-- Compression = gzip -->