<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find if there is a triplet in a Balanced BST that adds to zero</title>
	<atom:link href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Anand</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-33654</link>
		<dc:creator><![CDATA[Anand]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 07:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-33654</guid>
		<description><![CDATA[We can also do this by implementing a hash table with all the contents of the BST. We first have a function checkifSum(int sum) which checks if there are two numbers that add up to sum. Internally this loops thru the hash table and checks for every entry n if there is an entry (sum-x)...so for every entry this takes O(1) lookup time and O(n) for the function itself.

Now, to solve this problem, we loop thru the hash table and for every entry m, call the above function checkifSum(0-m). Since this function runs in O(n), we can implement this solution in n*n ie O(n^2) time.

Any thoughts/comments]]></description>
		<content:encoded><![CDATA[<p>We can also do this by implementing a hash table with all the contents of the BST. We first have a function checkifSum(int sum) which checks if there are two numbers that add up to sum. Internally this loops thru the hash table and checks for every entry n if there is an entry (sum-x)&#8230;so for every entry this takes O(1) lookup time and O(n) for the function itself.</p>
<p>Now, to solve this problem, we loop thru the hash table and for every entry m, call the above function checkifSum(0-m). Since this function runs in O(n), we can implement this solution in n*n ie O(n^2) time.</p>
<p>Any thoughts/comments</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mojo</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-33645</link>
		<dc:creator><![CDATA[Mojo]]></dc:creator>
		<pubDate>Tue, 18 Mar 2014 18:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-33645</guid>
		<description><![CDATA[When there are three zeroes in a BST, this will not return true.]]></description>
		<content:encoded><![CDATA[<p>When there are three zeroes in a BST, this will not return true.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sreenivas Doosa</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-29368</link>
		<dc:creator><![CDATA[Sreenivas Doosa]]></dc:creator>
		<pubDate>Sun, 27 Oct 2013 16:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-29368</guid>
		<description><![CDATA[@12rad:
It will be O(n^2) only.. Finding a triplet sum equal to given sum takes O(n^2) on a sorted array.. If you need to find just a pair sum equal to given sum takes O(n) .. for finding triplet, each element of the array has to be added to another pair in the array.. hence it will be O(n^2).]]></description>
		<content:encoded><![CDATA[<p>@12rad:<br />
It will be O(n^2) only.. Finding a triplet sum equal to given sum takes O(n^2) on a sorted array.. If you need to find just a pair sum equal to given sum takes O(n) .. for finding triplet, each element of the array has to be added to another pair in the array.. hence it will be O(n^2).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prama</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-24422</link>
		<dc:creator><![CDATA[Prama]]></dc:creator>
		<pubDate>Mon, 05 Aug 2013 03:26:56 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-24422</guid>
		<description><![CDATA[@GeeksForGeeks
For the better solution; why will the complexity be O(n^2)? The inorder tree traversal will be O(n) and the traversing the array will be another O(n) and this will lead to O(n)+O(n) ~O(n) ..  it isn&#039;t that for each node we&#039;re traversing the array - which is what will make it O(n^2). Please explain.

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>@GeeksForGeeks<br />
For the better solution; why will the complexity be O(n^2)? The inorder tree traversal will be O(n) and the traversing the array will be another O(n) and this will lead to O(n)+O(n) ~O(n) ..  it isn&#8217;t that for each node we&#8217;re traversing the array &#8211; which is what will make it O(n^2). Please explain.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: 12rad</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-24421</link>
		<dc:creator><![CDATA[12rad]]></dc:creator>
		<pubDate>Mon, 05 Aug 2013 03:21:52 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-24421</guid>
		<description><![CDATA[@GeeksForGeeks
The better solution :
A Better Solution is to create an auxiliary array and store Inorder traversal of BST in the array. The array will be sorted as Inorder traversal of BST always produces sorted data. Once we have the Inorder traversal, we can use method 2 of this post to find the triplet with sum equals to 0. This solution works in O(n^2) time, but requires O(n) auxiliary space.

Why will this be O(n^2)? Tree traversal will be O(n) and then traversing the array O(n) will make is O(n)+O(n) .. it&#039;s not that for each tree node, we&#039;re traversing the array.

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>@GeeksForGeeks<br />
The better solution :<br />
A Better Solution is to create an auxiliary array and store Inorder traversal of BST in the array. The array will be sorted as Inorder traversal of BST always produces sorted data. Once we have the Inorder traversal, we can use method 2 of this post to find the triplet with sum equals to 0. This solution works in O(n^2) time, but requires O(n) auxiliary space.</p>
<p>Why will this be O(n^2)? Tree traversal will be O(n) and then traversing the array O(n) will make is O(n)+O(n) .. it&#8217;s not that for each tree node, we&#8217;re traversing the array.</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ganesh</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-24038</link>
		<dc:creator><![CDATA[Ganesh]]></dc:creator>
		<pubDate>Sun, 04 Aug 2013 06:09:37 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-24038</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;Java&quot;&gt;

Recursive solution using inorder and reverse inorder.

Time complexity : I guess its O(nlogn) 
Space complexity: O(logn) due to recursion call stack 

package com.ganesh;

import com.ganesh.Node;

public class TreePair {
	
	static int INT_MIN = -32767;
	
	// Do an inorder traversal to print a tree
    public static void printTree(Node root) {
        if (root==null) return;
        printTree(root.small);
        System.out.print(Integer.toString(root.data) + &#034; &#034;);
        printTree(root.large);
    }
    
    /**
     * Tree Traversal to find if a given value exists in the tree
     * @param tripletCandidate
     * @param treeRoot
     * @return
     */
    public static int tripletCandidateExists(int tripletCandidate, Node treeRoot)
    {
    	
    	while(treeRoot != null)
    	{
    		if(tripletCandidate &#062; treeRoot.data)
        	{
        		treeRoot = treeRoot.large;
        	}
        	
        	if(tripletCandidate &#060; treeRoot.data)
        	{
        		treeRoot = treeRoot.small;
        	}
        	else
        		return treeRoot.data;
    	}
    	
		return INT_MIN;
    }
	
	public static void findsumTriplet(int tripletSum, Node root, Node curr, Node treeRoot)
    {
    	if(root == null &#038;&#038; curr == null) return;
  
    	findsumTriplet(tripletSum, (root==null)?null:root.small, (curr==null)?null:curr.large, treeRoot);
    	
    	if(root!=null &#038;&#038; curr!= null)
    	{
    		int partialSum = root.data + curr.data;
    		int remainingSum = tripletSum - partialSum;  //Remaining sum needed to form triplet
    		
    		{
    			/* Checking if any of the numbers are equal. A node&#039;s value should not be 
    			 * considered as a part of triplet if it is currently being considered for triplet sum
    			 */
    			if(root.data != curr.data &#038;&#038; root.data != remainingSum &#038;&#038; curr.data != remainingSum)
    			{
    				/**
    				 * Searching for the remaining value in the tree.
    				 */
    				if(tripletCandidateExists(remainingSum, treeRoot)!= INT_MIN)
                		System.out.println(&#034;Triplet for the given sum: &#034; + tripletSum + &#034; exists. The values are &#034; + root.data + &#034;, &#034; + remainingSum + &#034; and &#034; + curr.data);
    			}
    		}	
    	}
    	
    	findsumTriplet(tripletSum, (root==null)?null:root.large, (curr==null)?null:curr.small, treeRoot);
    }
	
	public static void main(String[] args) {
    	
    	Node root =  new Node(6);
        root.small = new Node(-13);
        root.large = new Node(14);
        root.small.large = new Node(-8);
        root.large.small = new Node(13);
        root.large.small.small = new Node(7);
        root.large.large = new Node(15);
        
        System.out.println(&#034;In order traversal of tree:&#034;);
        printTree(root);
        
        System.out.println();
        Node curr = root;
        findsumTriplet(0, root, curr, root);
    }

}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="Java">

Recursive solution using inorder and reverse inorder.

Time complexity : I guess its O(nlogn) 
Space complexity: O(logn) due to recursion call stack 

package com.ganesh;

import com.ganesh.Node;

public class TreePair {
	
	static int INT_MIN = -32767;
	
	// Do an inorder traversal to print a tree
    public static void printTree(Node root) {
        if (root==null) return;
        printTree(root.small);
        System.out.print(Integer.toString(root.data) + &quot; &quot;);
        printTree(root.large);
    }
    
    /**
     * Tree Traversal to find if a given value exists in the tree
     * @param tripletCandidate
     * @param treeRoot
     * @return
     */
    public static int tripletCandidateExists(int tripletCandidate, Node treeRoot)
    {
    	
    	while(treeRoot != null)
    	{
    		if(tripletCandidate &gt; treeRoot.data)
        	{
        		treeRoot = treeRoot.large;
        	}
        	
        	if(tripletCandidate &lt; treeRoot.data)
        	{
        		treeRoot = treeRoot.small;
        	}
        	else
        		return treeRoot.data;
    	}
    	
		return INT_MIN;
    }
	
	public static void findsumTriplet(int tripletSum, Node root, Node curr, Node treeRoot)
    {
    	if(root == null &amp;&amp; curr == null) return;
  
    	findsumTriplet(tripletSum, (root==null)?null:root.small, (curr==null)?null:curr.large, treeRoot);
    	
    	if(root!=null &amp;&amp; curr!= null)
    	{
    		int partialSum = root.data + curr.data;
    		int remainingSum = tripletSum - partialSum;  //Remaining sum needed to form triplet
    		
    		{
    			/* Checking if any of the numbers are equal. A node's value should not be 
    			 * considered as a part of triplet if it is currently being considered for triplet sum
    			 */
    			if(root.data != curr.data &amp;&amp; root.data != remainingSum &amp;&amp; curr.data != remainingSum)
    			{
    				/**
    				 * Searching for the remaining value in the tree.
    				 */
    				if(tripletCandidateExists(remainingSum, treeRoot)!= INT_MIN)
                		System.out.println(&quot;Triplet for the given sum: &quot; + tripletSum + &quot; exists. The values are &quot; + root.data + &quot;, &quot; + remainingSum + &quot; and &quot; + curr.data);
    			}
    		}	
    	}
    	
    	findsumTriplet(tripletSum, (root==null)?null:root.large, (curr==null)?null:curr.small, treeRoot);
    }
	
	public static void main(String[] args) {
    	
    	Node root =  new Node(6);
        root.small = new Node(-13);
        root.large = new Node(14);
        root.small.large = new Node(-8);
        root.large.small = new Node(13);
        root.large.small.small = new Node(7);
        root.large.large = new Node(15);
        
        System.out.println(&quot;In order traversal of tree:&quot;);
        printTree(root);
        
        System.out.println();
        Node curr = root;
        findsumTriplet(0, root, curr, root);
    }

}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ganesh</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-24032</link>
		<dc:creator><![CDATA[Ganesh]]></dc:creator>
		<pubDate>Sun, 04 Aug 2013 06:03:55 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-24032</guid>
		<description><![CDATA[Following is a Recursive solution that performs inorder and reverse inorder; while checking to find if there is a triplet summing to the given target. I think the time complexity in worst case is O(nlogn) and the space complexity (due to recursion call stack) is O(logn).

Checks are first made to see if duplicate values may form a triplet before searching for the third value in the tree. This makes the code little more efficient.


&lt;pre&gt; &lt;code language=&quot;Java&quot;&gt;

package com.ganesh;

import com.ganesh.Node;

public class TreePair {
	
	static int INT_MIN = -32767;
	
	// Do an inorder traversal to print a tree
    public static void printTree(Node root) {
        if (root==null) return;
        printTree(root.small);
        System.out.print(Integer.toString(root.data) + &#034; &#034;);
        printTree(root.large);
    }
    
    /**
     * Tree Traversal to find if a given value exists in the tree
     * @param tripletCandidate
     * @param treeRoot
     * @return
     */
    public static int tripletCandidateExists(int tripletCandidate, Node treeRoot)
    {
    	
    	while(treeRoot != null)
    	{
    		if(tripletCandidate &#062; treeRoot.data)
        	{
        		treeRoot = treeRoot.large;
        	}
        	
        	if(tripletCandidate &#060; treeRoot.data)
        	{
        		treeRoot = treeRoot.small;
        	}
        	else
        		return treeRoot.data;
    	}
    	
		return INT_MIN;
    }
	
	public static void findsumTriplet(int tripletSum, Node root, Node curr, Node treeRoot)
    {
    	if(root == null &#038;&#038; curr == null) return;
  
    	findsumTriplet(tripletSum, (root==null)?null:root.small, (curr==null)?null:curr.large, treeRoot);
    	
    	if(root!=null &#038;&#038; curr!= null)
    	{
    		int partialSum = root.data + curr.data;
    		int remainingSum = tripletSum - partialSum;  //Remaining sum needed to form triplet
    		
    		{
    			/* Checking if any of the numbers are equal. A node&#039;s value should not be 
    			 * considered as a part of triplet if it is currently being considered for triplet sum
    			 */
    			if(root.data != curr.data &#038;&#038; root.data != remainingSum &#038;&#038; curr.data != remainingSum)
    			{
    				/**
    				 * Searching for the remaining value in the tree.
    				 */
    				if(tripletCandidateExists(remainingSum, treeRoot)!= INT_MIN)
                		System.out.println(&#034;Triplet for the given sum: &#034; + tripletSum + &#034; exists. The values are &#034; + root.data + &#034;, &#034; + remainingSum + &#034; and &#034; + curr.data);
    			}
    		}	
    	}
    	
    	findsumTriplet(tripletSum, (root==null)?null:root.large, (curr==null)?null:curr.small, treeRoot);
    }
	
	public static void main(String[] args) {
    	
    	Node root =  new Node(6);
        root.small = new Node(-13);
        root.large = new Node(14);
        root.small.large = new Node(-8);
        root.large.small = new Node(13);
        root.large.small.small = new Node(7);
        root.large.large = new Node(15);
        
        System.out.println(&#034;In order traversal of tree:&#034;);
        printTree(root);
        
        System.out.println();
        Node curr = root;
        findsumTriplet(0, root, curr, root);
    }

}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Following is a Recursive solution that performs inorder and reverse inorder; while checking to find if there is a triplet summing to the given target. I think the time complexity in worst case is O(nlogn) and the space complexity (due to recursion call stack) is O(logn).</p>
<p>Checks are first made to see if duplicate values may form a triplet before searching for the third value in the tree. This makes the code little more efficient.</p>
<pre> <code language="Java">

package com.ganesh;

import com.ganesh.Node;

public class TreePair {
	
	static int INT_MIN = -32767;
	
	// Do an inorder traversal to print a tree
    public static void printTree(Node root) {
        if (root==null) return;
        printTree(root.small);
        System.out.print(Integer.toString(root.data) + &quot; &quot;);
        printTree(root.large);
    }
    
    /**
     * Tree Traversal to find if a given value exists in the tree
     * @param tripletCandidate
     * @param treeRoot
     * @return
     */
    public static int tripletCandidateExists(int tripletCandidate, Node treeRoot)
    {
    	
    	while(treeRoot != null)
    	{
    		if(tripletCandidate &gt; treeRoot.data)
        	{
        		treeRoot = treeRoot.large;
        	}
        	
        	if(tripletCandidate &lt; treeRoot.data)
        	{
        		treeRoot = treeRoot.small;
        	}
        	else
        		return treeRoot.data;
    	}
    	
		return INT_MIN;
    }
	
	public static void findsumTriplet(int tripletSum, Node root, Node curr, Node treeRoot)
    {
    	if(root == null &amp;&amp; curr == null) return;
  
    	findsumTriplet(tripletSum, (root==null)?null:root.small, (curr==null)?null:curr.large, treeRoot);
    	
    	if(root!=null &amp;&amp; curr!= null)
    	{
    		int partialSum = root.data + curr.data;
    		int remainingSum = tripletSum - partialSum;  //Remaining sum needed to form triplet
    		
    		{
    			/* Checking if any of the numbers are equal. A node's value should not be 
    			 * considered as a part of triplet if it is currently being considered for triplet sum
    			 */
    			if(root.data != curr.data &amp;&amp; root.data != remainingSum &amp;&amp; curr.data != remainingSum)
    			{
    				/**
    				 * Searching for the remaining value in the tree.
    				 */
    				if(tripletCandidateExists(remainingSum, treeRoot)!= INT_MIN)
                		System.out.println(&quot;Triplet for the given sum: &quot; + tripletSum + &quot; exists. The values are &quot; + root.data + &quot;, &quot; + remainingSum + &quot; and &quot; + curr.data);
    			}
    		}	
    	}
    	
    	findsumTriplet(tripletSum, (root==null)?null:root.large, (curr==null)?null:curr.small, treeRoot);
    }
	
	public static void main(String[] args) {
    	
    	Node root =  new Node(6);
        root.small = new Node(-13);
        root.large = new Node(14);
        root.small.large = new Node(-8);
        root.large.small = new Node(13);
        root.large.small.small = new Node(7);
        root.large.large = new Node(15);
        
        System.out.println(&quot;In order traversal of tree:&quot;);
        printTree(root);
        
        System.out.println();
        Node curr = root;
        findsumTriplet(0, root, curr, root);
    }

}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: abhishek08aug</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-18511</link>
		<dc:creator><![CDATA[abhishek08aug]]></dc:creator>
		<pubDate>Thu, 23 May 2013 08:51:46 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-18511</guid>
		<description><![CDATA[Intelligent :D]]></description>
		<content:encoded><![CDATA[<p>Intelligent ðŸ˜€</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vimal</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-16886</link>
		<dc:creator><![CDATA[Vimal]]></dc:creator>
		<pubDate>Sat, 30 Mar 2013 05:25:24 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-16886</guid>
		<description><![CDATA[Can you please explain the brute force method ?
I am finding it hard to get it.]]></description>
		<content:encoded><![CDATA[<p>Can you please explain the brute force method ?<br />
I am finding it hard to get it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GeeksFollower</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-16464</link>
		<dc:creator><![CDATA[GeeksFollower]]></dc:creator>
		<pubDate>Mon, 18 Mar 2013 08:33:09 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-16464</guid>
		<description><![CDATA[@GeeksForGeeks

Your program runs great EXCEPT ONE CASE:
when tree is having only single node and it is negative. slight modification will solve it. Rest is perfect.]]></description>
		<content:encoded><![CDATA[<p>@GeeksForGeeks</p>
<p>Your program runs great EXCEPT ONE CASE:<br />
when tree is having only single node and it is negative. slight modification will solve it. Rest is perfect.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aaman</title>
		<link>http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/#comment-16277</link>
		<dc:creator><![CDATA[Aaman]]></dc:creator>
		<pubDate>Wed, 13 Mar 2013 06:46:02 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115322#comment-16277</guid>
		<description><![CDATA[Better approach will be do inorder and reverse in order simultaneously,now add the two elements and search for negative of  this sum in tree in logn times..so N+NlogN 



&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Better approach will be do inorder and reverse in order simultaneously,now add the two elements and search for negative of  this sum in tree in logn times..so N+NlogN </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:18:26 -->

<!-- Compression = gzip -->