<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find the first circular tour that visits all petrol pumps</title>
	<atom:link href="http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: KeshaShah</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-40087</link>
		<dc:creator><![CDATA[KeshaShah]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 16:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-40087</guid>
		<description><![CDATA[Sime solution. It doesnt assume always an ans exist

http://ideone.com/N7pvZP]]></description>
		<content:encoded><![CDATA[<p>Sime solution. It doesnt assume always an ans exist</p>
<p><a href="http://ideone.com/N7pvZP" rel="nofollow">http://ideone.com/N7pvZP</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-40086</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 16:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-40086</guid>
		<description><![CDATA[Simple solution (It doesn&#039;t assume solution always exist)....
#include 

struct PPump

{

	int petrol;

	int distance;

};

int main(void) {

	struct PPump ar[]={{6,4},{3,6},{7,3}};

	int flag2=0;

	int n=sizeof(ar)/sizeof(ar[0]);

	for(int start=0;start&#060;n;start++)

	{

		int flag=0,tanki=0;

		for(int end=start;end!=(start-1+n)%n;end=(end+1)%n)

		{

			tanki+=ar[end].petrol;

			tanki-=ar[end].distance;

			

			if(tanki&#060;0)

			{

				flag=1;

				break;

			}

		}

		

		if(flag==1)

			continue;

		else

		{

			printf(&#034;%dn&#034;,start);

			flag2=1;

			break;

		}

	}

	

	if(flag2==0)

	{

		printf(&#034;No such possiblen&#034;);

	}

	// your code goes here

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Simple solution (It doesn&#8217;t assume solution always exist)&#8230;.<br />
#include </p>
<p>struct PPump</p>
<p>{</p>
<p>	int petrol;</p>
<p>	int distance;</p>
<p>};</p>
<p>int main(void) {</p>
<p>	struct PPump ar[]={{6,4},{3,6},{7,3}};</p>
<p>	int flag2=0;</p>
<p>	int n=sizeof(ar)/sizeof(ar[0]);</p>
<p>	for(int start=0;start&lt;n;start++)</p>
<p>	{</p>
<p>		int flag=0,tanki=0;</p>
<p>		for(int end=start;end!=(start-1+n)%n;end=(end+1)%n)</p>
<p>		{</p>
<p>			tanki+=ar[end].petrol;</p>
<p>			tanki-=ar[end].distance;</p>
<p>			if(tanki&lt;0)</p>
<p>			{</p>
<p>				flag=1;</p>
<p>				break;</p>
<p>			}</p>
<p>		}</p>
<p>		if(flag==1)</p>
<p>			continue;</p>
<p>		else</p>
<p>		{</p>
<p>			printf(&quot;%dn&quot;,start);</p>
<p>			flag2=1;</p>
<p>			break;</p>
<p>		}</p>
<p>	}</p>
<p>	if(flag2==0)</p>
<p>	{</p>
<p>		printf(&quot;No such possiblen&quot;);</p>
<p>	}</p>
<p>	// your code goes here</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-40085</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 28 Jun 2014 16:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-40085</guid>
		<description><![CDATA[Simple solution (It doesn&#039;t assume solution always exist)

#include 

struct PPump

{

	int petrol;

	int distance;

};

int main(void) {

	struct PPump ar[]={{6,4},{3,6},{7,3}};

	int flag2=0;

	int n=sizeof(ar)/sizeof(ar[0]);

	for(int start=0;start&#060;n;start++)

	{

		int flag=0,tanki=0;

		for(int end=start;end!=(start-1+n)%n;end=(end+1)%n)

		{

			tanki+=ar[end].petrol;

			tanki-=ar[end].distance;

			

			if(tanki&#060;0)

			{

				flag=1;

				break;

			}

		}

		

		if(flag==1)

			continue;

		else

		{

			printf(&#034;%dn&#034;,start);

			flag2=1;

			break;

		}

	}

	if(flag2==0)
	{
		printf(&#034;No such possiblen&#034;);
	}

	// your code goes here

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Simple solution (It doesn&#8217;t assume solution always exist)</p>
<p>#include </p>
<p>struct PPump</p>
<p>{</p>
<p>	int petrol;</p>
<p>	int distance;</p>
<p>};</p>
<p>int main(void) {</p>
<p>	struct PPump ar[]={{6,4},{3,6},{7,3}};</p>
<p>	int flag2=0;</p>
<p>	int n=sizeof(ar)/sizeof(ar[0]);</p>
<p>	for(int start=0;start&lt;n;start++)</p>
<p>	{</p>
<p>		int flag=0,tanki=0;</p>
<p>		for(int end=start;end!=(start-1+n)%n;end=(end+1)%n)</p>
<p>		{</p>
<p>			tanki+=ar[end].petrol;</p>
<p>			tanki-=ar[end].distance;</p>
<p>			if(tanki&lt;0)</p>
<p>			{</p>
<p>				flag=1;</p>
<p>				break;</p>
<p>			}</p>
<p>		}</p>
<p>		if(flag==1)</p>
<p>			continue;</p>
<p>		else</p>
<p>		{</p>
<p>			printf(&quot;%dn&quot;,start);</p>
<p>			flag2=1;</p>
<p>			break;</p>
<p>		}</p>
<p>	}</p>
<p>	if(flag2==0)<br />
	{<br />
		printf(&quot;No such possiblen&quot;);<br />
	}</p>
<p>	// your code goes here</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-39336</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 10:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-39336</guid>
		<description><![CDATA[@Dhruv   Yes you seem right. I think we can prove it similar to mathematical induction.

Given:- 
If P-Q-R-S are the nodes visited and journey R-S gives negative result.
Proof :- Lets assume by removing P we can make valid journey i.e.  Q-R-S is valid journey 
But as per &quot;given&quot; condition P-Q was feasible journey
And as per assumption Q-R-S is feasible journey. So totally P-Q-R-S is feasible journey.
Which is contradictory to &quot;given&quot; statement. 

So if P-Q-R-S is not feasible sequence; by removing start point will not lead us to any feasible journey.

@GeeksForGeeks can you take note of this and cooment about this approach ?]]></description>
		<content:encoded><![CDATA[<p>@Dhruv   Yes you seem right. I think we can prove it similar to mathematical induction.</p>
<p>Given:-<br />
If P-Q-R-S are the nodes visited and journey R-S gives negative result.<br />
Proof :- Lets assume by removing P we can make valid journey i.e.  Q-R-S is valid journey<br />
But as per &#8220;given&#8221; condition P-Q was feasible journey<br />
And as per assumption Q-R-S is feasible journey. So totally P-Q-R-S is feasible journey.<br />
Which is contradictory to &#8220;given&#8221; statement. </p>
<p>So if P-Q-R-S is not feasible sequence; by removing start point will not lead us to any feasible journey.</p>
<p>@GeeksForGeeks can you take note of this and cooment about this approach ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dhruv Bansal</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-39320</link>
		<dc:creator><![CDATA[Dhruv Bansal]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 08:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-39320</guid>
		<description><![CDATA[they are also restarting the process again only as when current_petrol becomes negative ,they are removing elements one by one until it becomes positive ,which will only become positive when start becomes end.]]></description>
		<content:encoded><![CDATA[<p>they are also restarting the process again only as when current_petrol becomes negative ,they are removing elements one by one until it becomes positive ,which will only become positive when start becomes end.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-39309</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 06:23:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-39309</guid>
		<description><![CDATA[By making

if ( total &#060; 0 ) {
start = current = ( current + 1 ) % n;
cnt = 0;
total = 0;

you are restarting whole process once again. 
So suppose you have traveled 8 nodes and on 9th node you found problem; then you make start=9 ..... so the information you gathered over last 8 nodes is lost ..... in approach suggested in article, you still use that info (by adjusting start position to next one and reducing current petrol) . Thus approach in article will be efficient]]></description>
		<content:encoded><![CDATA[<p>By making</p>
<p>if ( total &lt; 0 ) {<br />
start = current = ( current + 1 ) % n;<br />
cnt = 0;<br />
total = 0;</p>
<p>you are restarting whole process once again.<br />
So suppose you have traveled 8 nodes and on 9th node you found problem; then you make start=9 &#8230;.. so the information you gathered over last 8 nodes is lost &#8230;.. in approach suggested in article, you still use that info (by adjusting start position to next one and reducing current petrol) . Thus approach in article will be efficient</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-39307</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 06:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-39307</guid>
		<description><![CDATA[By making 

curr_petrol=arr[current].petrol - arr[current].distance;
int temp = start;
start = current;

you are restarting whole process once again. 
So suppose you have traveled 8 nodes and on 9th node you found problem; then you make start=9 ..... so the information you gathered over last 8 nodes is lost ..... in approach suggested in article, you still use that info (by adjusting start position to next one and reducing current petrol) . Thus approach in article will be efficient]]></description>
		<content:encoded><![CDATA[<p>By making </p>
<p>curr_petrol=arr[current].petrol &#8211; arr[current].distance;<br />
int temp = start;<br />
start = current;</p>
<p>you are restarting whole process once again.<br />
So suppose you have traveled 8 nodes and on 9th node you found problem; then you make start=9 &#8230;.. so the information you gathered over last 8 nodes is lost &#8230;.. in approach suggested in article, you still use that info (by adjusting start position to next one and reducing current petrol) . Thus approach in article will be efficient</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Saurabh</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-38795</link>
		<dc:creator><![CDATA[Saurabh]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 07:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-38795</guid>
		<description><![CDATA[Simple and elegant solution to this problem (It assumes that such a station always exists.!)

http://ideone.com/ZkN4va

Please comment if it is wrong.]]></description>
		<content:encoded><![CDATA[<p>Simple and elegant solution to this problem (It assumes that such a station always exists.!)</p>
<p><a href="http://ideone.com/ZkN4va" rel="nofollow">http://ideone.com/ZkN4va</a></p>
<p>Please comment if it is wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dhruv Bansal</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-38533</link>
		<dc:creator><![CDATA[Dhruv Bansal]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 10:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-38533</guid>
		<description><![CDATA[In geeksforgeeks is there any real need of removing elements one by one in case curr_petrol becomes negative . I think we can remove this
 while (curr_petrol &#060; 0 &#038;&#038; start != end)
        {
            // Remove starting petrol pump. Change start
            curr_petrol -= arr[start].petrol - arr[start].distance;
            start = (start + 1)%n;
 
            // If 0 is being considered as start again, then there is no
            // possible solution
            if (start == 0)
               return -1;
        }


and directly make start = end 


something like this code i have used 


// C program to find circular tour for a truck
#include 

// A petrol pump has petrol and distance to next petrol pump
struct petrolPump
{
  int petrol;
  int distance;
};

// The function returns starting point if there is a possible solution,
// otherwise returns -1
int printTour(struct petrolPump arr[], int n)
{
    // Consider first petrol pump as a starting point
    int start = 0;
    int current =  (start+1)%n;

    int curr_petrol = arr[start].petrol - arr[start].distance;

    /* Run a loop while all petrol pumps are not visited.
      And we have reached first petrol pump again with 0 or more petrol */
    while (1)
    {
        if(curr_petrol&#060;0)
        {
            curr_petrol=arr[current].petrol - arr[current].distance;
            int temp = start;
            start = current;
            if(start&#060;= temp )
            {
                return -1;

            }
            current +=1;
            current %=n;
        }
        else
        {
            if(current==start)
                return start;
            curr_petrol += arr[current].petrol - arr[current].distance;
            current+=1;
            current %=n;
        }
    }

    // Return starting point
    return start;
}

// Driver program to test above functions
int main()
{
    struct petrolPump arr[] = {{4, 6}, {6, 5}, {7, 3}, {5, 11}, {4, 1}};

    int n = sizeof(arr)/sizeof(arr[0]);
    int start = printTour(arr, n);

    (start == -1)? printf(&#034;No solution&#034;): printf(&#034;Start = %d&#034;, start);

    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>In geeksforgeeks is there any real need of removing elements one by one in case curr_petrol becomes negative . I think we can remove this<br />
 while (curr_petrol &lt; 0 &amp;&amp; start != end)<br />
        {<br />
            // Remove starting petrol pump. Change start<br />
            curr_petrol -= arr[start].petrol &#8211; arr[start].distance;<br />
            start = (start + 1)%n;</p>
<p>            // If 0 is being considered as start again, then there is no<br />
            // possible solution<br />
            if (start == 0)<br />
               return -1;<br />
        }</p>
<p>and directly make start = end </p>
<p>something like this code i have used </p>
<p>// C program to find circular tour for a truck<br />
#include </p>
<p>// A petrol pump has petrol and distance to next petrol pump<br />
struct petrolPump<br />
{<br />
  int petrol;<br />
  int distance;<br />
};</p>
<p>// The function returns starting point if there is a possible solution,<br />
// otherwise returns -1<br />
int printTour(struct petrolPump arr[], int n)<br />
{<br />
    // Consider first petrol pump as a starting point<br />
    int start = 0;<br />
    int current =  (start+1)%n;</p>
<p>    int curr_petrol = arr[start].petrol &#8211; arr[start].distance;</p>
<p>    /* Run a loop while all petrol pumps are not visited.<br />
      And we have reached first petrol pump again with 0 or more petrol */<br />
    while (1)<br />
    {<br />
        if(curr_petrol&lt;0)<br />
        {<br />
            curr_petrol=arr[current].petrol &#8211; arr[current].distance;<br />
            int temp = start;<br />
            start = current;<br />
            if(start&lt;= temp )<br />
            {<br />
                return -1;</p>
<p>            }<br />
            current +=1;<br />
            current %=n;<br />
        }<br />
        else<br />
        {<br />
            if(current==start)<br />
                return start;<br />
            curr_petrol += arr[current].petrol &#8211; arr[current].distance;<br />
            current+=1;<br />
            current %=n;<br />
        }<br />
    }</p>
<p>    // Return starting point<br />
    return start;<br />
}</p>
<p>// Driver program to test above functions<br />
int main()<br />
{<br />
    struct petrolPump arr[] = {{4, 6}, {6, 5}, {7, 3}, {5, 11}, {4, 1}};</p>
<p>    int n = sizeof(arr)/sizeof(arr[0]);<br />
    int start = printTour(arr, n);</p>
<p>    (start == -1)? printf(&quot;No solution&quot;): printf(&quot;Start = %d&quot;, start);</p>
<p>    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-38532</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 10:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-38532</guid>
		<description><![CDATA[i think it is not necessary to remove elements one by one , as when curr_petrol becomes negative then we should make start = end instead of removing elements one by one , as finally start will become end .


here is my code .


// C program to find circular tour for a truck
#include 


// A petrol pump has petrol and distance to next petrol pump
struct petrolPump
{
  int petrol;
  int distance;
};


// The function returns starting point if there is a possible solution,
// otherwise returns -1
int printTour(struct petrolPump arr[], int n)
{
    // Consider first petrol pump as a starting point
    int start = 0;
    int current =  (start+1)%n;


    int curr_petrol = arr[start].petrol - arr[start].distance;


    /* Run a loop while all petrol pumps are not visited.
      And we have reached first petrol pump again with 0 or more petrol */
    while (1)
    {
        if(curr_petrol&#060;0)
        {
            curr_petrol=arr[current].petrol - arr[current].distance;
            start = current;
            if(start == 0 )
            {
                return -1;


            }
            current +=1;
            current %=n;
        }
        else
        {
            curr_petrol += arr[current].petrol - arr[current].distance;
            current+=1;
            current %=n;
            if(current==start)
                return start;
        }
    }


    // Return starting point
    return start;
}


// Driver program to test above functions
int main()
{
    struct petrolPump arr[] = {{4, 6}, {6, 5}, {7, 3}, {5, 11}, {4, 1}};


    int n = sizeof(arr)/sizeof(arr[0]);
    int start = printTour(arr, n);


    (start == -1)? printf(&#034;No solution&#034;): printf(&#034;Start = %d&#034;, start);


    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>i think it is not necessary to remove elements one by one , as when curr_petrol becomes negative then we should make start = end instead of removing elements one by one , as finally start will become end .</p>
<p>here is my code .</p>
<p>// C program to find circular tour for a truck<br />
#include </p>
<p>// A petrol pump has petrol and distance to next petrol pump<br />
struct petrolPump<br />
{<br />
  int petrol;<br />
  int distance;<br />
};</p>
<p>// The function returns starting point if there is a possible solution,<br />
// otherwise returns -1<br />
int printTour(struct petrolPump arr[], int n)<br />
{<br />
    // Consider first petrol pump as a starting point<br />
    int start = 0;<br />
    int current =  (start+1)%n;</p>
<p>    int curr_petrol = arr[start].petrol &#8211; arr[start].distance;</p>
<p>    /* Run a loop while all petrol pumps are not visited.<br />
      And we have reached first petrol pump again with 0 or more petrol */<br />
    while (1)<br />
    {<br />
        if(curr_petrol&lt;0)<br />
        {<br />
            curr_petrol=arr[current].petrol &#8211; arr[current].distance;<br />
            start = current;<br />
            if(start == 0 )<br />
            {<br />
                return -1;</p>
<p>            }<br />
            current +=1;<br />
            current %=n;<br />
        }<br />
        else<br />
        {<br />
            curr_petrol += arr[current].petrol &#8211; arr[current].distance;<br />
            current+=1;<br />
            current %=n;<br />
            if(current==start)<br />
                return start;<br />
        }<br />
    }</p>
<p>    // Return starting point<br />
    return start;<br />
}</p>
<p>// Driver program to test above functions<br />
int main()<br />
{<br />
    struct petrolPump arr[] = {{4, 6}, {6, 5}, {7, 3}, {5, 11}, {4, 1}};</p>
<p>    int n = sizeof(arr)/sizeof(arr[0]);<br />
    int start = printTour(arr, n);</p>
<p>    (start == -1)? printf(&quot;No solution&quot;): printf(&quot;Start = %d&quot;, start);</p>
<p>    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/#comment-37862</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 07 Jun 2014 18:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114301#comment-37862</guid>
		<description><![CDATA[Here&#039;s my solution :  http://ideone.com/1dN6pU
TC : O(n)
AS : O(1)]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s my solution :  <a href="http://ideone.com/1dN6pU" rel="nofollow">http://ideone.com/1dN6pU</a><br />
TC : O(n)<br />
AS : O(1)</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:03:08 -->

<!-- Compression = gzip -->