<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Print BST keys in the given range</title>
	<atom:link href="http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-38421</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 12:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-38421</guid>
		<description><![CDATA[That won&#039;t work. Try it out yourselves. Whenever a node falls in the range, it will print the whole subtree rooted at that node, not just that node. Inorder print will descend into subtrees which fall out of range.]]></description>
		<content:encoded><![CDATA[<p>That won&#8217;t work. Try it out yourselves. Whenever a node falls in the range, it will print the whole subtree rooted at that node, not just that node. Inorder print will descend into subtrees which fall out of range.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: v3gA</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-38419</link>
		<dc:creator><![CDATA[v3gA]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 12:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-38419</guid>
		<description><![CDATA[It is O(n) in worst case. If the tree is balanced, it will run in O(log n + k) where k is no of nodes in the range]]></description>
		<content:encoded><![CDATA[<p>It is O(n) in worst case. If the tree is balanced, it will run in O(log n + k) where k is no of nodes in the range</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Yamini_yadav</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-38357</link>
		<dc:creator><![CDATA[Yamini_yadav]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 20:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-38357</guid>
		<description><![CDATA[You can prune the tree to find the first node in this range and then call inorder print to print this subtree...
https://ideone.com/vRj2xf]]></description>
		<content:encoded><![CDATA[<p>You can prune the tree to find the first node in this range and then call inorder print to print this subtree&#8230;<br />
<a href="https://ideone.com/vRj2xf" rel="nofollow">https://ideone.com/vRj2xf</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienAni25</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-37790</link>
		<dc:creator><![CDATA[AlienAni25]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 23:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-37790</guid>
		<description><![CDATA[the code given in the gfg is same,,,its going to only on those nodes which are to be printed,, except the case when the root is initially out of range , so as to traverse to the node inside the range..- this is the extra traversal which is also log(n).]]></description>
		<content:encoded><![CDATA[<p>the code given in the gfg is same,,,its going to only on those nodes which are to be printed,, except the case when the root is initially out of range , so as to traverse to the node inside the range..- this is the extra traversal which is also log(n).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Richard Fu</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-37569</link>
		<dc:creator><![CDATA[Richard Fu]]></dc:creator>
		<pubDate>Tue, 03 Jun 2014 23:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-37569</guid>
		<description><![CDATA[it&#039;s the same solution but just making the code longer...
i think we can say x always &#060; y, so some check is unnecessary]]></description>
		<content:encoded><![CDATA[<p>it&#8217;s the same solution but just making the code longer&#8230;<br />
i think we can say x always &lt; y, so some check is unnecessary</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aman</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-36389</link>
		<dc:creator><![CDATA[Aman]]></dc:creator>
		<pubDate>Wed, 21 May 2014 06:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-36389</guid>
		<description><![CDATA[In the above solution, we have to go through all the nodes of the tree. Here is the solution which go through only those nodes which need to be printed(except some nodes):


Print_Range is called in main().

void Print_Right(Node* root,int t)     
{
    if(root== NULL)
        return;
        
    else if(root-&#062;data == t)
    {
        cout&#060;data&#060;left);
        }
    
    else if(root-&#062;data &#060; t)
    {
        cout&#060;data&#060;left);
        Print_Right(root-&#062;right,t);
        }
    else
        Print_Right(root-&#062;left,t);
    
    }    
    
void Print_Left(Node* root,int t)
{
    if(root== NULL)
        return;
        
    else if(root-&#062;data == t)
    {
        cout&#060;data&#060;right);
        }
    
    else if(root-&#062;data &#062; t)
    {
        cout&#060;data&#060;right);
        Print_Left(root-&#062;left,t);
        }
        
    else
        Print_Left(root-&#062;right,t);
    }    
    
void Print_Range(Node* root,int x, int y)
{
    if(root == NULL)
        return;
        
    else if(root-&#062;data &#062; x &#038;&#038; root-&#062;data &#062; y)
        Print_Range(root-&#062;left,x,y);
        
    else if(root-&#062;data data right,x,y);
        
    else
    {
        cout&#060;data&#060;left,x);
        Print_Right(root-&#062;right,y);
        }
    }


Complexity is O(number of keys in the range) &#060; O(n)]]></description>
		<content:encoded><![CDATA[<p>In the above solution, we have to go through all the nodes of the tree. Here is the solution which go through only those nodes which need to be printed(except some nodes):</p>
<p>Print_Range is called in main().</p>
<p>void Print_Right(Node* root,int t)<br />
{<br />
    if(root== NULL)<br />
        return;</p>
<p>    else if(root-&gt;data == t)<br />
    {<br />
        cout&lt;data&lt;left);<br />
        }</p>
<p>    else if(root-&gt;data &lt; t)<br />
    {<br />
        cout&lt;data&lt;left);<br />
        Print_Right(root-&gt;right,t);<br />
        }<br />
    else<br />
        Print_Right(root-&gt;left,t);</p>
<p>    }    </p>
<p>void Print_Left(Node* root,int t)<br />
{<br />
    if(root== NULL)<br />
        return;</p>
<p>    else if(root-&gt;data == t)<br />
    {<br />
        cout&lt;data&lt;right);<br />
        }</p>
<p>    else if(root-&gt;data &gt; t)<br />
    {<br />
        cout&lt;data&lt;right);<br />
        Print_Left(root-&gt;left,t);<br />
        }</p>
<p>    else<br />
        Print_Left(root-&gt;right,t);<br />
    }    </p>
<p>void Print_Range(Node* root,int x, int y)<br />
{<br />
    if(root == NULL)<br />
        return;</p>
<p>    else if(root-&gt;data &gt; x &amp;&amp; root-&gt;data &gt; y)<br />
        Print_Range(root-&gt;left,x,y);</p>
<p>    else if(root-&gt;data data right,x,y);</p>
<p>    else<br />
    {<br />
        cout&lt;data&lt;left,x);<br />
        Print_Right(root-&gt;right,y);<br />
        }<br />
    }</p>
<p>Complexity is O(number of keys in the range) &lt; O(n)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: CoderKnowledge</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-27637</link>
		<dc:creator><![CDATA[CoderKnowledge]]></dc:creator>
		<pubDate>Sat, 14 Sep 2013 10:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-27637</guid>
		<description><![CDATA[Iterative Solution:


Approach:
1) Do Inorder Traversal.
2) while printing the nodes check whether the data within range of n1 and n2 where n1 and n2 are keys otherwise donot print.


psuedo Code:


void keysInRange(struct node *root,int n1,int n2)
{
     if(n1 &#062; n2)
     {
             // swap n1 and n2
             swap(n1,n2);
            // now n1 and n2 values interchanged.
     }
     stack s;
     while(1)
     {
        while(root)
         {
             /* All left sub tree elements are added */
            Push(s,root);
            root = root-&#062;left;
         }
 
         root = pop(s);
         if(root-&#062;data &#062;=n1 &#038;&#038; root-&#062;data  data);
        root = root -&#062;right;


         /* if stack is empty */
         if(stackIsEmpty(s))
               break;
     }
}


Please correct if any mistakes are there.]]></description>
		<content:encoded><![CDATA[<p>Iterative Solution:</p>
<p>Approach:<br />
1) Do Inorder Traversal.<br />
2) while printing the nodes check whether the data within range of n1 and n2 where n1 and n2 are keys otherwise donot print.</p>
<p>psuedo Code:</p>
<p>void keysInRange(struct node *root,int n1,int n2)<br />
{<br />
     if(n1 &gt; n2)<br />
     {<br />
             // swap n1 and n2<br />
             swap(n1,n2);<br />
            // now n1 and n2 values interchanged.<br />
     }<br />
     stack s;<br />
     while(1)<br />
     {<br />
        while(root)<br />
         {<br />
             /* All left sub tree elements are added */<br />
            Push(s,root);<br />
            root = root-&gt;left;<br />
         }</p>
<p>         root = pop(s);<br />
         if(root-&gt;data &gt;=n1 &amp;&amp; root-&gt;data  data);<br />
        root = root -&gt;right;</p>
<p>         /* if stack is empty */<br />
         if(stackIsEmpty(s))<br />
               break;<br />
     }<br />
}</p>
<p>Please correct if any mistakes are there.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-27087</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Wed, 28 Aug 2013 14:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-27087</guid>
		<description><![CDATA[Time Complexity: O(n) .
We can also store the values in a vector, if we want to process these values further.


&lt;code&gt;

#include

#include

#include

#include

using namespace std;

typedef struct node

{

    int data;

    struct node *left;

    struct node *right;

}node;

node *newNode(int data)

{

    node *N=(node *)calloc(1,sizeof(node));

    N-&#062;data=data;

    N-&#062;right=NULL;

    N-&#062;left=NULL;

    return N;

}

void FindKeys(node *root,int k1,int k2,vector&#038;V)

{

    if(!root)

        return;

    if(root-&#062;data&#062;=k1 &#038;&#038; root-&#062;datadata);

            FindKeys(root-&#062;left,k1,k2,V);

            FindKeys(root-&#062;right,k1,k2,V);

        }

    else if(root-&#062;dataright,k1,k2,V);

    }

    else if(root-&#062;data&#062;k2)

    {

        FindKeys(root-&#062;right,k1,k2,V);

    }

    return;

}

int main()

{

    vector V;

    int k1 = 10, k2 = 25;

    node *root = newNode(20);

    root-&#062;left = newNode(8);

    root-&#062;right = newNode(22);

    root-&#062;left-&#062;left = newNode(4);

    root-&#062;left-&#062;right = newNode(12);

    FindKeys(root,k1,k2,V);

    for(int i=0;i&#060;V.size();i++)

        printf(&#034;%d &#034;,V[i]);

    return 0;

}

&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>Time Complexity: O(n) .<br />
We can also store the values in a vector, if we want to process these values further.</p>
<p><code></p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>using namespace std;</p>
<p>typedef struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node *left;</p>
<p>    struct node *right;</p>
<p>}node;</p>
<p>node *newNode(int data)</p>
<p>{</p>
<p>    node *N=(node *)calloc(1,sizeof(node));</p>
<p>    N-&gt;data=data;</p>
<p>    N-&gt;right=NULL;</p>
<p>    N-&gt;left=NULL;</p>
<p>    return N;</p>
<p>}</p>
<p>void FindKeys(node *root,int k1,int k2,vector&amp;V)</p>
<p>{</p>
<p>    if(!root)</p>
<p>        return;</p>
<p>    if(root-&gt;data&gt;=k1 &amp;&amp; root-&gt;datadata);</p>
<p>            FindKeys(root-&gt;left,k1,k2,V);</p>
<p>            FindKeys(root-&gt;right,k1,k2,V);</p>
<p>        }</p>
<p>    else if(root-&gt;dataright,k1,k2,V);</p>
<p>    }</p>
<p>    else if(root-&gt;data&gt;k2)</p>
<p>    {</p>
<p>        FindKeys(root-&gt;right,k1,k2,V);</p>
<p>    }</p>
<p>    return;</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>    vector V;</p>
<p>    int k1 = 10, k2 = 25;</p>
<p>    node *root = newNode(20);</p>
<p>    root-&gt;left = newNode(8);</p>
<p>    root-&gt;right = newNode(22);</p>
<p>    root-&gt;left-&gt;left = newNode(4);</p>
<p>    root-&gt;left-&gt;right = newNode(12);</p>
<p>    FindKeys(root,k1,k2,V);</p>
<p>    for(int i=0;i&lt;V.size();i++)</p>
<p>        printf(&quot;%d &quot;,V[i]);</p>
<p>    return 0;</p>
<p>}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Shuchit Khurana</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-26730</link>
		<dc:creator><![CDATA[Shuchit Khurana]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 03:57:13 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-26730</guid>
		<description><![CDATA[Would the complexity differ from their solution? Please let me know :)
]]></description>
		<content:encoded><![CDATA[<p>Would the complexity differ from their solution? Please let me know 🙂</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: miandfhy</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-22476</link>
		<dc:creator><![CDATA[miandfhy]]></dc:creator>
		<pubDate>Sun, 21 Jul 2013 09:28:08 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-22476</guid>
		<description><![CDATA[Do inorder traversal.  At node apply the condition
Does this work?]]></description>
		<content:encoded><![CDATA[<p>Do inorder traversal.  At node apply the condition<br />
Does this work?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sonali gupta</title>
		<link>http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/#comment-20743</link>
		<dc:creator><![CDATA[sonali gupta]]></dc:creator>
		<pubDate>Thu, 27 Jun 2013 16:58:43 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=11103#comment-20743</guid>
		<description><![CDATA[#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;malloc.h&gt;
typedef struct NODE
{
 int info;
 struct NODE *left,*right;
}node;
node *temp;
node *getnode()
{return((node *)malloc(sizeof(node)));
 }
node *newNode(int x)
{
 temp=getnode();
 temp-&gt;info=x;
 temp-&gt;left=NULL;
 temp-&gt;right=NULL; 
 return temp;  
     }
void inorder(node *root,int k1,int k2)
{if(root!=NULL)
{inorder(root-&gt;left,k1,k2);
if(root-&gt;info&gt;=k1 &amp;&amp; root-&gt;info&lt;=k2)
printf(&quot;%d &quot;,root-&gt;info);
inorder(root-&gt;right,k1,k2);
}    
     }     
int main()
{
  
  int k1 = 10, k2 = 25;
 
  /* Constructing tree given in the above figure */
node  *root = newNode(20);
  root-&gt;left = newNode(8);
  root-&gt;right = newNode(22);
  root-&gt;left-&gt;left = newNode(4);
  root-&gt;left-&gt;right = newNode(12);
 
  inorder(root, k1, k2);
 
  getchar();
  return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<stdio .h><br />
#include<conio .h><br />
#include<malloc .h><br />
typedef struct NODE<br />
{<br />
 int info;<br />
 struct NODE *left,*right;<br />
}node;<br />
node *temp;<br />
node *getnode()<br />
{return((node *)malloc(sizeof(node)));<br />
 }<br />
node *newNode(int x)<br />
{<br />
 temp=getnode();<br />
 temp->info=x;<br />
 temp->left=NULL;<br />
 temp->right=NULL;<br />
 return temp;<br />
     }<br />
void inorder(node *root,int k1,int k2)<br />
{if(root!=NULL)<br />
{inorder(root->left,k1,k2);<br />
if(root->info>=k1 &#038;&#038; root->info< =k2)
printf("%d ",root->info);<br />
inorder(root->right,k1,k2);<br />
}<br />
     }<br />
int main()<br />
{</p>
<p>  int k1 = 10, k2 = 25;</p>
<p>  /* Constructing tree given in the above figure */<br />
node  *root = newNode(20);<br />
  root->left = newNode(8);<br />
  root->right = newNode(22);<br />
  root->left->left = newNode(4);<br />
  root->left->right = newNode(12);</p>
<p>  inorder(root, k1, k2);</p>
<p>  getchar();<br />
  return 0;<br />
}</malloc></conio></stdio></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.042 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:18:23 -->

<!-- Compression = gzip -->