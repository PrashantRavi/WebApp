<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 7 (Coin Change)</title>
	<atom:link href="http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Pulkit Agarwal</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-40148</link>
		<dc:creator><![CDATA[Pulkit Agarwal]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 12:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-40148</guid>
		<description><![CDATA[For  S = {1,2,4} and target V = 8 it is giving 9 which is correct. 
Please could you give another example ?]]></description>
		<content:encoded><![CDATA[<p>For  S = {1,2,4} and target V = 8 it is giving 9 which is correct.<br />
Please could you give another example ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: akash</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39713</link>
		<dc:creator><![CDATA[akash]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 04:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39713</guid>
		<description><![CDATA[ultimate]]></description>
		<content:encoded><![CDATA[<p>ultimate</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: RACHIT SAXENA</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39650</link>
		<dc:creator><![CDATA[RACHIT SAXENA]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 13:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39650</guid>
		<description><![CDATA[second solution reduced copying of row&#039;s prev cell elements (y)]]></description>
		<content:encoded><![CDATA[<p>second solution reduced copying of row&#8217;s prev cell elements (y)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: RACHIT SAXENA</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39648</link>
		<dc:creator><![CDATA[RACHIT SAXENA]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 13:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39648</guid>
		<description><![CDATA[its all about hash map (y)]]></description>
		<content:encoded><![CDATA[<p>its all about hash map (y)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jshollow</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39581</link>
		<dc:creator><![CDATA[Jshollow]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 03:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39581</guid>
		<description><![CDATA[Also, if you&#039;re more familiar with Java than C++, m = arr.length.]]></description>
		<content:encoded><![CDATA[<p>Also, if you&#8217;re more familiar with Java than C++, m = arr.length.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jshollow</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39580</link>
		<dc:creator><![CDATA[Jshollow]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 03:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39580</guid>
		<description><![CDATA[@Rachit - Start with the recursive solution of the problem. At the end of the algorithm, where it says (i) and (ii), the return value should read &quot;count(S,m,N-S[m-1]) + count(S,m-1,N)&quot; to follow the respective order or (i) and (ii). What you see in the recursive tree that has been drawn is that every time S[m-1] is included, it is subtracted from N. Think of it this way, you want to keep subtracting values in S from N until N reaches 0. If it&#039;s possible for N to reach 0, you&#039;ve found a solution, increment your solution count. At the same time, you want to try both solutions that contain S[m-1] and solutions that don&#039;t contain S[m-1] so you exclude S[m-1] by not subtracting its value from N and decrementing m so that you&#039;re looking at a smaller subset of the array that no longer considers the previous S[m-1] value. Genius!


Hope this helps.]]></description>
		<content:encoded><![CDATA[<p>@Rachit &#8211; Start with the recursive solution of the problem. At the end of the algorithm, where it says (i) and (ii), the return value should read &#8220;count(S,m,N-S[m-1]) + count(S,m-1,N)&#8221; to follow the respective order or (i) and (ii). What you see in the recursive tree that has been drawn is that every time S[m-1] is included, it is subtracted from N. Think of it this way, you want to keep subtracting values in S from N until N reaches 0. If it&#8217;s possible for N to reach 0, you&#8217;ve found a solution, increment your solution count. At the same time, you want to try both solutions that contain S[m-1] and solutions that don&#8217;t contain S[m-1] so you exclude S[m-1] by not subtracting its value from N and decrementing m so that you&#8217;re looking at a smaller subset of the array that no longer considers the previous S[m-1] value. Genius!</p>
<p>Hope this helps.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39550</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 16:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39550</guid>
		<description><![CDATA[I tried to solve it this recursive way. 
Consider one coin at a time. 
If amount equals to the coin then this is only 1 way using this coin.
Otherwise deduct the count from required amount and call the function to get the number of ways remaining amount be produced (using all coins).
But problem here is that we get duplicate solutions

e.g. N=3, coins={1,2,5} we get no of ways as 3, where as it should be just 2.

First we consider coin Rs.1. So remaining amount is 2. So call function for amount 2. Amount 2 can be got in 2 ways {1,1} and {2}. So we have two ways to get original amount {1,1,1},{1,2}

Now we consider coin =2. Deducting it remaining amount is 1. So call function of 1. there is only way. So we got one way to make original amount viz. {2,1}

Now solution {1,2} is actually same as {2,1}. So we are getting duplicate solution. 

Does anyone have suggestion to improve this approach ?
Code is shared at
http://ideone.com/bYJeU2
Also given below


	public static void main(String[] args) {
		int amount = 3;
		int[] denominations = new int[]{1,2,5};
		HashMap solutionMap = new HashMap();
		System.out.println(&quot;getNumberOfWays for &quot;+amount+&quot; = &quot;+getNumberOfWays(amount,denominations,solutionMap) );
	}

	public static int getNumberOfWays(int amount, int[] denominations,HashMap solutionMap){
		if(solutionMap.get(amount)!=null){
			return solutionMap.get(amount);
		}else{
			int numOfWays=0;
			for(int i=0;i0){
					// After deducting this coin, still more amount to cover
					// So call routine again to find no of ways remining amount is achieved
					numOfWays = numOfWays + getNumberOfWays(amount-denominations[i],denominations,solutionMap);
				}else{
					// It means amount-denominations[i] &#060; 0
					// So there is no way of getting exact amount by taking this count
					// So do nothing
				}
			}
			return numOfWays;
		}
	}
}
]]></description>
		<content:encoded><![CDATA[<p>I tried to solve it this recursive way.<br />
Consider one coin at a time.<br />
If amount equals to the coin then this is only 1 way using this coin.<br />
Otherwise deduct the count from required amount and call the function to get the number of ways remaining amount be produced (using all coins).<br />
But problem here is that we get duplicate solutions</p>
<p>e.g. N=3, coins={1,2,5} we get no of ways as 3, where as it should be just 2.</p>
<p>First we consider coin Rs.1. So remaining amount is 2. So call function for amount 2. Amount 2 can be got in 2 ways {1,1} and {2}. So we have two ways to get original amount {1,1,1},{1,2}</p>
<p>Now we consider coin =2. Deducting it remaining amount is 1. So call function of 1. there is only way. So we got one way to make original amount viz. {2,1}</p>
<p>Now solution {1,2} is actually same as {2,1}. So we are getting duplicate solution. </p>
<p>Does anyone have suggestion to improve this approach ?<br />
Code is shared at<br />
<a href="http://ideone.com/bYJeU2" rel="nofollow">http://ideone.com/bYJeU2</a><br />
Also given below</p>
<p>	public static void main(String[] args) {<br />
		int amount = 3;<br />
		int[] denominations = new int[]{1,2,5};<br />
		HashMap solutionMap = new HashMap();<br />
		System.out.println(&#8220;getNumberOfWays for &#8220;+amount+&#8221; = &#8220;+getNumberOfWays(amount,denominations,solutionMap) );<br />
	}</p>
<p>	public static int getNumberOfWays(int amount, int[] denominations,HashMap solutionMap){<br />
		if(solutionMap.get(amount)!=null){<br />
			return solutionMap.get(amount);<br />
		}else{<br />
			int numOfWays=0;<br />
			for(int i=0;i0){<br />
					// After deducting this coin, still more amount to cover<br />
					// So call routine again to find no of ways remining amount is achieved<br />
					numOfWays = numOfWays + getNumberOfWays(amount-denominations[i],denominations,solutionMap);<br />
				}else{<br />
					// It means amount-denominations[i] &lt; 0<br />
					// So there is no way of getting exact amount by taking this count<br />
					// So do nothing<br />
				}<br />
			}<br />
			return numOfWays;<br />
		}<br />
	}<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: nk</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-39454</link>
		<dc:creator><![CDATA[nk]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 13:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-39454</guid>
		<description><![CDATA[i get this error error C2466: cannot allocate an array of constant size 0 when i am using visual stdio from this line..
int table[n+1][m]... anybody knows how to resolve this..?i guess this has something to do with c89/c99.]]></description>
		<content:encoded><![CDATA[<p>i get this error error C2466: cannot allocate an array of constant size 0 when i am using visual stdio from this line..<br />
int table[n+1][m]&#8230; anybody knows how to resolve this..?i guess this has something to do with c89/c99.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Suvodip Bhattacharya</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-37923</link>
		<dc:creator><![CDATA[Suvodip Bhattacharya]]></dc:creator>
		<pubDate>Sun, 08 Jun 2014 14:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-37923</guid>
		<description><![CDATA[#include
#include
#include
using namespace std;

int change(int N,int s[],int start,int sizen,int current)
{

    if( N == 0 /*&#038;&#038; start &#060; sizen*/) return 1;
    if( N &#060; 0 ) return 0;


    else
    {    
        int f=0;
        for(int i=start ; i&#060;sizen ; i++)
        {    
            if( current &#060;= i )
            f+=change( N-s[i],s,0,sizen,i);
        }

        return f;
    }

}


int main()
{
int s[]={2, 5, 3, 6};
int size=sizeof(s)/sizeof(s[0]);

int N=10;

cout&#060;&#060;change(N,s,0,size,INT_MIN)&#060;&#060;endl;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
using namespace std;</p>
<p>int change(int N,int s[],int start,int sizen,int current)<br />
{</p>
<p>    if( N == 0 /*&amp;&amp; start &lt; sizen*/) return 1;<br />
    if( N &lt; 0 ) return 0;</p>
<p>    else<br />
    {<br />
        int f=0;<br />
        for(int i=start ; i&lt;sizen ; i++)<br />
        {<br />
            if( current &lt;= i )<br />
            f+=change( N-s[i],s,0,sizen,i);<br />
        }</p>
<p>        return f;<br />
    }</p>
<p>}</p>
<p>int main()<br />
{<br />
int s[]={2, 5, 3, 6};<br />
int size=sizeof(s)/sizeof(s[0]);</p>
<p>int N=10;</p>
<p>cout&lt;&lt;change(N,s,0,size,INT_MIN)&lt;&lt;endl;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-37400</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 05:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-37400</guid>
		<description><![CDATA[@geeksforgeeks:disqus  In my opinion the code given by Roshan wont work for every input.
for(int i=0 ; i&#060;m ; i++) {
 for(int j=S[i] ; j&#060;=n ; j++)
in the second loop  we are incrementing  j but what if the coins are not in increasing order (or they are increasing but not in a constant periodic fashion, the above code fails to handle this problem. correct me if i am wrong.]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus  In my opinion the code given by Roshan wont work for every input.<br />
for(int i=0 ; i&lt;m ; i++) {<br />
 for(int j=S[i] ; j&lt;=n ; j++)<br />
in the second loop  we are incrementing  j but what if the coins are not in increasing order (or they are increasing but not in a constant periodic fashion, the above code fails to handle this problem. correct me if i am wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/#comment-37399</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 02 Jun 2014 05:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17401#comment-37399</guid>
		<description><![CDATA[@geeksforgeeks:disqus In my opinion the code given by Roshan wont work for every input.
for(int i=0; i&#060;m; i++)
        for(int j=S[i]; j&#060;=n; j++)
            table[j] += table[j-S[i]];
in the second loop we are incrementing j but what is the coins are not in increasing order (or they are increasing but not in a constant fashion, the above code fails to handle this problem.
Correct me if I am wrong.]]></description>
		<content:encoded><![CDATA[<p>@geeksforgeeks:disqus In my opinion the code given by Roshan wont work for every input.<br />
for(int i=0; i&lt;m; i++)<br />
        for(int j=S[i]; j&lt;=n; j++)<br />
            table[j] += table[j-S[i]];<br />
in the second loop we are incrementing j but what is the coins are not in increasing order (or they are increasing but not in a constant fashion, the above code fails to handle this problem.<br />
Correct me if I am wrong.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:00 -->

<!-- Compression = gzip -->