<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Inorder Tree Traversal without Recursion</title>
	<atom:link href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Mittal</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-39428</link>
		<dc:creator><![CDATA[Mittal]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 08:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-39428</guid>
		<description><![CDATA[I think the algo can be reworded a bit to make it more clear(atleast I was confused :) -

3) If current is NOT NULL, push the current node to S and set current = current-&#062;left
4) If current is NULL and stack is not empty then 
     a) Pop the top item from stack. Set current to this popped item
     b) Print the popped item, set current = current-&#062;right 
     c) Go to step 3.
OR
4) If current is NULL and stack is not empty then 
     a) Pop the top item from stack
     b) Print the popped item, set current = (popped item)-&#062;right 
     c) Go to step 3.

The reason to modify 4.a is that if we never set current to the popped item, we can&#039;t set current = current -&#062; right in 4.b as current was NULL when we entered 4)


Hope this makes sense]]></description>
		<content:encoded><![CDATA[<p>I think the algo can be reworded a bit to make it more clear(atleast I was confused ðŸ™‚ &#8211;</p>
<p>3) If current is NOT NULL, push the current node to S and set current = current-&gt;left<br />
4) If current is NULL and stack is not empty then<br />
     a) Pop the top item from stack. Set current to this popped item<br />
     b) Print the popped item, set current = current-&gt;right<br />
     c) Go to step 3.<br />
OR<br />
4) If current is NULL and stack is not empty then<br />
     a) Pop the top item from stack<br />
     b) Print the popped item, set current = (popped item)-&gt;right<br />
     c) Go to step 3.</p>
<p>The reason to modify 4.a is that if we never set current to the popped item, we can&#8217;t set current = current -&gt; right in 4.b as current was NULL when we entered 4)</p>
<p>Hope this makes sense</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rahul</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-38325</link>
		<dc:creator><![CDATA[Rahul]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 14:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-38325</guid>
		<description><![CDATA[this method solve all the traversals by only take a simple pointer to array and store all the tree nodes and ....
so plz check out this .....
http://ideone.com/biAxO0]]></description>
		<content:encoded><![CDATA[<p>this method solve all the traversals by only take a simple pointer to array and store all the tree nodes and &#8230;.<br />
so plz check out this &#8230;..<br />
<a href="http://ideone.com/biAxO0" rel="nofollow">http://ideone.com/biAxO0</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nandha</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-35972</link>
		<dc:creator><![CDATA[Nandha]]></dc:creator>
		<pubDate>Tue, 13 May 2014 11:32:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-35972</guid>
		<description><![CDATA[void InOrderTraversalIterative() const
{
    Node *current = root_;
    stack&#060;Node*&#062; theStack;
    while ( current &#124;&#124; ! theStack.empty() )
    {
        while(current) {
            theStack.push(current);
            current = current-&#062;left_;
        }
        current = theStack.top() ; theStack.pop();
        //do whatever you want to with this. here i print simply
        cout &#060;&#060; *current &#060;right_;
    }
}]]></description>
		<content:encoded><![CDATA[<p>void InOrderTraversalIterative() const<br />
{<br />
    Node *current = root_;<br />
    stack&lt;Node*&gt; theStack;<br />
    while ( current || ! theStack.empty() )<br />
    {<br />
        while(current) {<br />
            theStack.push(current);<br />
            current = current-&gt;left_;<br />
        }<br />
        current = theStack.top() ; theStack.pop();<br />
        //do whatever you want to with this. here i print simply<br />
        cout &lt;&lt; *current &lt;right_;<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ashish</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-33687</link>
		<dc:creator><![CDATA[Ashish]]></dc:creator>
		<pubDate>Thu, 20 Mar 2014 09:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-33687</guid>
		<description><![CDATA[error, as when ur left side node of right subtree of left child .:)]]></description>
		<content:encoded><![CDATA[<p>error, as when ur left side node of right subtree of left child .:)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Babaji</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-32693</link>
		<dc:creator><![CDATA[Babaji]]></dc:creator>
		<pubDate>Tue, 18 Feb 2014 09:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-32693</guid>
		<description><![CDATA[My solution solves all traversals using a simple and elegant &#039;dummy&#039; node method. The idea is to push the left, right and a dummy node onto the stack according to our traversal order and everything is handled automatically. The dummy node represents a leaf node where both right and left children are nullptr. When we see this node on the stack, just print its value and continue onto the next iteration of the loop. This method works closely with how recursion actually works. Here is some code:


struct Node 
{
    Node* left;
    Node* right;
    int data;


    Node(int d) : left(nullptr), right(nullptr), data(d) { }


    bool isLeaf() { return ((left == nullptr) &#038;&#038; (right == nullptr)); }
};


void InOrder(Node* root, Stack s)
{
    if (!root)
        return;


    s.push(root);
    while(!s.empty())
    {
         Node* node = s.pop();
         if (node-&#062;isLeaf())
         {
              print(node-&#062;data);
              continue;
         }


         if (node-&#062;right)
             s.push(node-&#062;right);


         // Pushing a dummy leaf node
         s.push(new Node(node-&#062;data));


         if (node-&#062;left)
             s.push(node-&#062;left);
    }
}]]></description>
		<content:encoded><![CDATA[<p>My solution solves all traversals using a simple and elegant &#8216;dummy&#8217; node method. The idea is to push the left, right and a dummy node onto the stack according to our traversal order and everything is handled automatically. The dummy node represents a leaf node where both right and left children are nullptr. When we see this node on the stack, just print its value and continue onto the next iteration of the loop. This method works closely with how recursion actually works. Here is some code:</p>
<p>struct Node<br />
{<br />
    Node* left;<br />
    Node* right;<br />
    int data;</p>
<p>    Node(int d) : left(nullptr), right(nullptr), data(d) { }</p>
<p>    bool isLeaf() { return ((left == nullptr) &amp;&amp; (right == nullptr)); }<br />
};</p>
<p>void InOrder(Node* root, Stack s)<br />
{<br />
    if (!root)<br />
        return;</p>
<p>    s.push(root);<br />
    while(!s.empty())<br />
    {<br />
         Node* node = s.pop();<br />
         if (node-&gt;isLeaf())<br />
         {<br />
              print(node-&gt;data);<br />
              continue;<br />
         }</p>
<p>         if (node-&gt;right)<br />
             s.push(node-&gt;right);</p>
<p>         // Pushing a dummy leaf node<br />
         s.push(new Node(node-&gt;data));</p>
<p>         if (node-&gt;left)<br />
             s.push(node-&gt;left);<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: moussa</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-31683</link>
		<dc:creator><![CDATA[moussa]]></dc:creator>
		<pubDate>Tue, 21 Jan 2014 07:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-31683</guid>
		<description><![CDATA[r u sure?

http://www.cplusplus.com/reference/stack/stack/pop/]]></description>
		<content:encoded><![CDATA[<p>r u sure?</p>
<p><a href="http://www.cplusplus.com/reference/stack/stack/pop/" rel="nofollow">http://www.cplusplus.com/reference/stack/stack/pop/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: bikash</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-31550</link>
		<dc:creator><![CDATA[bikash]]></dc:creator>
		<pubDate>Wed, 15 Jan 2014 22:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-31550</guid>
		<description><![CDATA[I guess the above code can be simplified a little:

void inOrder(struct tNode *root)
{
    /* set current to root of binary tree */
    struct tNode *current = root;
    struct sNode *s = NULL;  /* Initialize stack s */

   while (!isEmpty(s) &#124;&#124; current)
   {
       if(current)
       {
           /* place pointer to a tree node on the stack before traversing 
           the node&#039;s left subtree */
           push(&#038;s, current);                                               
          current = current-&#062;left;  
       } else {
            current = pop(&#038;s);
            printf(&quot;%d &quot;, current-&#062;data);
           /* we have visited the node and its left subtree. Now, it&#039;s right subtree&#039;s            turn */
            current = current-&#062;right;
       }
    }
}]]></description>
		<content:encoded><![CDATA[<p>I guess the above code can be simplified a little:</p>
<p>void inOrder(struct tNode *root)<br />
{<br />
    /* set current to root of binary tree */<br />
    struct tNode *current = root;<br />
    struct sNode *s = NULL;  /* Initialize stack s */</p>
<p>   while (!isEmpty(s) || current)<br />
   {<br />
       if(current)<br />
       {<br />
           /* place pointer to a tree node on the stack before traversing<br />
           the node&#8217;s left subtree */<br />
           push(&amp;s, current);<br />
          current = current-&gt;left;<br />
       } else {<br />
            current = pop(&amp;s);<br />
            printf(&#8220;%d &#8220;, current-&gt;data);<br />
           /* we have visited the node and its left subtree. Now, it&#8217;s right subtree&#8217;s            turn */<br />
            current = current-&gt;right;<br />
       }<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: superaghu</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-29803</link>
		<dc:creator><![CDATA[superaghu]]></dc:creator>
		<pubDate>Wed, 13 Nov 2013 01:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-29803</guid>
		<description><![CDATA[public static void InOrderIterative(TreeNode root)
        {
            Console.WriteLine(&quot;In Order Iterative&quot;);
            var stack = new Stack();
            var node = root;
            if (node != null)
            {
                stack.Push(node);
                while (stack.Count &#062; 0)
                {
                    //stack.Push(node);
                    while (node.LeftChild != null)
                    {
                        node = node.LeftChild;
                        stack.Push(node);
                    }
                    node = stack.Pop();
                    Console.Write(node.Data + &quot;  --&#062;&quot;);
                    if (node.RightChild != null)
                    {
                        node = node.RightChild;
                        stack.Push(node);
                    }
                }
            }
        }]]></description>
		<content:encoded><![CDATA[<p>public static void InOrderIterative(TreeNode root)<br />
        {<br />
            Console.WriteLine(&#8220;In Order Iterative&#8221;);<br />
            var stack = new Stack();<br />
            var node = root;<br />
            if (node != null)<br />
            {<br />
                stack.Push(node);<br />
                while (stack.Count &gt; 0)<br />
                {<br />
                    //stack.Push(node);<br />
                    while (node.LeftChild != null)<br />
                    {<br />
                        node = node.LeftChild;<br />
                        stack.Push(node);<br />
                    }<br />
                    node = stack.Pop();<br />
                    Console.Write(node.Data + &#8221;  &#8211;&gt;&#8221;);<br />
                    if (node.RightChild != null)<br />
                    {<br />
                        node = node.RightChild;<br />
                        stack.Push(node);<br />
                    }<br />
                }<br />
            }<br />
        }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samsammy</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-28015</link>
		<dc:creator><![CDATA[samsammy]]></dc:creator>
		<pubDate>Sun, 22 Sep 2013 16:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-28015</guid>
		<description><![CDATA[node=stack.top() ; and stack.pop();  can be correctly written as a single line---
node=stack.pop();

As pop operation in stack deletes the object in top and returns it.]]></description>
		<content:encoded><![CDATA[<p>node=stack.top() ; and stack.pop();  can be correctly written as a single line&#8212;<br />
node=stack.pop();</p>
<p>As pop operation in stack deletes the object in top and returns it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: chinnisasi</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-21622</link>
		<dc:creator><![CDATA[chinnisasi]]></dc:creator>
		<pubDate>Sun, 07 Jul 2013 12:14:01 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-21622</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
void inOrderTraversalWithOutStack(struct node* node)	{
	std::stack&#060;struct node*&#062; stk;
	struct node* current = node;
	while(current)	{
		while(current)	{
			stk.push(current);
			current = current-&#062;left;
		}
		while(current == NULL &#038;&#038; !stk.empty())	{
			current = stk.top();
			stk.pop();
			printf(&#034;%d \t&#034;, current-&#062;data);
			current = current-&#062;right;
		}
	}
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
void inOrderTraversalWithOutStack(struct node* node)	{
	std::stack&lt;struct node*&gt; stk;
	struct node* current = node;
	while(current)	{
		while(current)	{
			stk.push(current);
			current = current-&gt;left;
		}
		while(current == NULL &amp;&amp; !stk.empty())	{
			current = stk.top();
			stk.pop();
			printf(&quot;%d \t&quot;, current-&gt;data);
			current = current-&gt;right;
		}
	}
}

</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nitesh</title>
		<link>http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/#comment-20887</link>
		<dc:creator><![CDATA[Nitesh]]></dc:creator>
		<pubDate>Sat, 29 Jun 2013 14:12:32 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=5592#comment-20887</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
void pre_ordr(node *tree)
{
     vector&#060;node*&#062; v;
     if(tree == NULL)
       return;
     
     node *root = tree;
     v.push_back(root);
     while(v.size())
     {
          while(root-&#062;left != NULL)
          {
             v.push_back(root-&#062;left);
             root = root-&#062;left;
          }
          node *tmp = v.back();
          v.pop_back();
          cout&#060;&#060;&#034;Data = &#034;&#060;&#060;tmp-&#062;data&#060;&#060;endl;
          if(tmp-&#062;right != NULL)
          {
             v.push_back(tmp-&#062;right);
             root = tmp-&#062;right;
          }
     }
}

&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
void pre_ordr(node *tree)
{
     vector&lt;node*&gt; v;
     if(tree == NULL)
       return;
     
     node *root = tree;
     v.push_back(root);
     while(v.size())
     {
          while(root-&gt;left != NULL)
          {
             v.push_back(root-&gt;left);
             root = root-&gt;left;
          }
          node *tmp = v.back();
          v.pop_back();
          cout&lt;&lt;&quot;Data = &quot;&lt;&lt;tmp-&gt;data&lt;&lt;endl;
          if(tmp-&gt;right != NULL)
          {
             v.push_back(tmp-&gt;right);
             root = tmp-&gt;right;
          }
     }
}

</code> </pre>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.043 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 12:50:00 -->

<!-- Compression = gzip -->