<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Majority Element</title>
	<atom:link href="http://www.geeksforgeeks.org/majority-element/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/majority-element/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39885</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 14:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39885</guid>
		<description><![CDATA[OMG! I gave an answer Exactly urs @koushik  :P]]></description>
		<content:encoded><![CDATA[<p>OMG! I gave an answer Exactly urs @koushik  ðŸ˜›</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39884</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Thu, 26 Jun 2014 14:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39884</guid>
		<description><![CDATA[I had a similar solution, Traverse through the array, check the elements of (i+1) and (i+2) with element at i&#039;th location. tats enuf. It covers almost all the cases. 


ex: If element occurs n/2 times. then all possible cases will be like this..
1. n,1,n,2,n...
2. n,n,1,2,n,3,n...
3.n,1,n,n,n,2,3....
4.1,2,3,n,n,n....


Comment if wrong.]]></description>
		<content:encoded><![CDATA[<p>I had a similar solution, Traverse through the array, check the elements of (i+1) and (i+2) with element at i&#8217;th location. tats enuf. It covers almost all the cases. </p>
<p>ex: If element occurs n/2 times. then all possible cases will be like this..<br />
1. n,1,n,2,n&#8230;<br />
2. n,n,1,2,n,3,n&#8230;<br />
3.n,1,n,n,n,2,3&#8230;.<br />
4.1,2,3,n,n,n&#8230;.</p>
<p>Comment if wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39798</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 15:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39798</guid>
		<description><![CDATA[Hi @Prince , after your previous comment I had given modified approach above.
In short if any of first two element is same as any of last two elements then we have considered alternate number case. 
If this condition is not passed then we will iterate over array and this time checkin (i th) with (i+1)th is sufficient.]]></description>
		<content:encoded><![CDATA[<p>Hi @Prince , after your previous comment I had given modified approach above.<br />
In short if any of first two element is same as any of last two elements then we have considered alternate number case.<br />
If this condition is not passed then we will iterate over array and this time checkin (i th) with (i+1)th is sufficient.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prince</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39767</link>
		<dc:creator><![CDATA[Prince]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 11:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39767</guid>
		<description><![CDATA[ur approach
i)   first element =8   second last=7   different
ii)  second =1       last=8  diff
iii)  i=0;i&#060;2*n-1;i++
       if(a[i]==a[i+1])
            return a[i];
but in the array  no two elements are adjacent........ a[i] is never equal to a[i+1]]]></description>
		<content:encoded><![CDATA[<p>ur approach<br />
i)   first element =8   second last=7   different<br />
ii)  second =1       last=8  diff<br />
iii)  i=0;i&lt;2*n-1;i++<br />
       if(a[i]==a[i+1])<br />
            return a[i];<br />
but in the array  no two elements are adjacent&#8230;&#8230;.. a[i] is never equal to a[i+1]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek Chauhan</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39712</link>
		<dc:creator><![CDATA[Abhishek Chauhan]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 04:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39712</guid>
		<description><![CDATA[The problem reduces to finding median of an array because if number is more than n/2 it must cross the middle boundary. Once median is found we need to confirm if it is majority element or not. Finding median can be done via quick select in 0(n). Although it is not as efficient as moore&#039;s voting technique. Just another way of solving this.]]></description>
		<content:encoded><![CDATA[<p>The problem reduces to finding median of an array because if number is more than n/2 it must cross the middle boundary. Once median is found we need to confirm if it is majority element or not. Finding median can be done via quick select in 0(n). Although it is not as efficient as moore&#8217;s voting technique. Just another way of solving this.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek Chauhan</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39711</link>
		<dc:creator><![CDATA[Abhishek Chauhan]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 04:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39711</guid>
		<description><![CDATA[As your question has no valid answer . It must be more than n/2 . In this case we dont have anyone.]]></description>
		<content:encoded><![CDATA[<p>As your question has no valid answer . It must be more than n/2 . In this case we dont have anyone.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39524</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 10:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39524</guid>
		<description><![CDATA[Hash map base solution 
for(int i: arr)

		{

			if(map1.get(i)==null)

			{

				map1.put(i, 1);

			}

			else

			{

				int frequency = map1.get(i);

				frequency+=1;

				map1.put(i, frequency);

				if(n = arr.length/2)

		{

			System.out.println(&quot;majority element is &quot;+ element);

		}]]></description>
		<content:encoded><![CDATA[<p>Hash map base solution<br />
for(int i: arr)</p>
<p>		{</p>
<p>			if(map1.get(i)==null)</p>
<p>			{</p>
<p>				map1.put(i, 1);</p>
<p>			}</p>
<p>			else</p>
<p>			{</p>
<p>				int frequency = map1.get(i);</p>
<p>				frequency+=1;</p>
<p>				map1.put(i, frequency);</p>
<p>				if(n = arr.length/2)</p>
<p>		{</p>
<p>			System.out.println(&#8220;majority element is &#8220;+ element);</p>
<p>		}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39397</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 04:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39397</guid>
		<description><![CDATA[@Prince Instead of comparing with (i-1) &#038; (i+1); we can modify the shortcut checks for alternative numbers. This will reduce no. of comparisons required.

In case of alternative numbers 
first element is same as second last element (as in 1,2,1,3,1,4 )
OR
second element is same as last element (as in 4,1,2,1,3,1)
OR
first element is same as last element (as in 8,1,2,8,3,8,4,8,5,8,6,8,7,8 )

:

:

Do you see any case failing?]]></description>
		<content:encoded><![CDATA[<p>@Prince Instead of comparing with (i-1) &amp; (i+1); we can modify the shortcut checks for alternative numbers. This will reduce no. of comparisons required.</p>
<p>In case of alternative numbers<br />
first element is same as second last element (as in 1,2,1,3,1,4 )<br />
OR<br />
second element is same as last element (as in 4,1,2,1,3,1)<br />
OR<br />
first element is same as last element (as in 8,1,2,8,3,8,4,8,5,8,6,8,7,8 )</p>
<p>:</p>
<p>:</p>
<p>Do you see any case failing?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prince</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39368</link>
		<dc:creator><![CDATA[Prince]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 16:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39368</guid>
		<description><![CDATA[compare (i-1)th and (i+1)th   it will work for all cases]]></description>
		<content:encoded><![CDATA[<p>compare (i-1)th and (i+1)th   it will work for all cases</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prince</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39367</link>
		<dc:creator><![CDATA[Prince]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 16:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39367</guid>
		<description><![CDATA[If numbers are not alternative e.g. Will not work for {8,1,2,8,3,8,4,8,5,8,6,8,7,8}]]></description>
		<content:encoded><![CDATA[<p>If numbers are not alternative e.g. Will not work for {8,1,2,8,3,8,4,8,5,8,6,8,7,8}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: MANAS KUMAR</title>
		<link>http://www.geeksforgeeks.org/majority-element/#comment-39052</link>
		<dc:creator><![CDATA[MANAS KUMAR]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 15:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=503#comment-39052</guid>
		<description><![CDATA[It can be done using HashSet with Time complexity=O(n) and space=o(n).

public static void majorityElement(int[] a,HashSet s){

		int sum=0;

		for(int i=0;i&lt;a&gt;((a.length-1)/2)){

					System.out.println(&quot;Majority element found  &quot;+a[i]);

					System.exit(0);}

				else

					continue;

				}

			else{

				s.add(a[i]);

				sum=1;

			}

		}

		System.out.println(&quot;Majority element not found&quot;);

	}]]></description>
		<content:encoded><![CDATA[<p>It can be done using HashSet with Time complexity=O(n) and space=o(n).</p>
<p>public static void majorityElement(int[] a,HashSet s){</p>
<p>		int sum=0;</p>
<p>		for(int i=0;i<a>((a.length-1)/2)){</p>
<p>					System.out.println(&#8220;Majority element found  &#8220;+a[i]);</p>
<p>					System.exit(0);}</p>
<p>				else</p>
<p>					continue;</p>
<p>				}</p>
<p>			else{</p>
<p>				s.add(a[i]);</p>
<p>				sum=1;</p>
<p>			}</p>
<p>		}</p>
<p>		System.out.println(&#8220;Majority element not found&#8221;);</p>
<p>	}</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:12:36 -->

<!-- Compression = gzip -->