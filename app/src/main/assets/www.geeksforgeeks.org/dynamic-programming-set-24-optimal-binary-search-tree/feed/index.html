<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Dynamic Programming &#124; Set 24 (Optimal Binary Search Tree)</title>
	<atom:link href="http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Lohith Ravi</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-35799</link>
		<dc:creator><![CDATA[Lohith Ravi]]></dc:creator>
		<pubDate>Thu, 08 May 2014 19:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-35799</guid>
		<description><![CDATA[we can also put the weights in a Max Heap with  key-&#062;weight &#038; Value-&#062;index .and with a next top value of the Heap, break the array  at the index recursively. to form right and left subtree.

Forming the heap and taking = nlogn and that will be the complexity of algo as well]]></description>
		<content:encoded><![CDATA[<p>we can also put the weights in a Max Heap with  key-&gt;weight &amp; Value-&gt;index .and with a next top value of the Heap, break the array  at the index recursively. to form right and left subtree.</p>
<p>Forming the heap and taking = nlogn and that will be the complexity of algo as well</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: NB</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-34788</link>
		<dc:creator><![CDATA[NB]]></dc:creator>
		<pubDate>Thu, 17 Apr 2014 18:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-34788</guid>
		<description><![CDATA[Food for thought  -  This problem is similar to Huffman coding concept. ( where you want to associate small length prefix code to symbols that occur more frequently ). Huffman coding can be solved in linear time when sorted weights are given. This cant  be directly be applied here because the the binary tree formed by this method wont be a binary SEARCH tree.]]></description>
		<content:encoded><![CDATA[<p>Food for thought  &#8211;  This problem is similar to Huffman coding concept. ( where you want to associate small length prefix code to symbols that occur more frequently ). Huffman coding can be solved in linear time when sorted weights are given. This cant  be directly be applied here because the the binary tree formed by this method wont be a binary SEARCH tree.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-34126</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Mon, 31 Mar 2014 15:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-34126</guid>
		<description><![CDATA[Recursion tree for above example
                                  opt(0,2)


      root0                        root1                root2
          /                           /                        
       opt(1,2)         opt(0,0)  opt(2,2)         opt(0,1)
    root1     root2                                    root0    root1
    /                                                          /         
    /                                                         /             
opt(2,2)   opt(1,1)                             opt(1,1)    opt(0,0)]]></description>
		<content:encoded><![CDATA[<p>Recursion tree for above example<br />
                                  opt(0,2)</p>
<p>      root0                        root1                root2<br />
          /                           /<br />
       opt(1,2)         opt(0,0)  opt(2,2)         opt(0,1)<br />
    root1     root2                                    root0    root1<br />
    /                                                          /<br />
    /                                                         /<br />
opt(2,2)   opt(1,1)                             opt(1,1)    opt(0,0)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Junyi Hu</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-32971</link>
		<dc:creator><![CDATA[Junyi Hu]]></dc:creator>
		<pubDate>Tue, 25 Feb 2014 14:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-32971</guid>
		<description><![CDATA[Very clear explanation!]]></description>
		<content:encoded><![CDATA[<p>Very clear explanation!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Samar</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-32011</link>
		<dc:creator><![CDATA[Samar]]></dc:creator>
		<pubDate>Thu, 30 Jan 2014 23:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-32011</guid>
		<description><![CDATA[Following code is simple and easy to understand.

#include 
#include 

using namespace std;

struct node {
   int data;
   node *left;
   node *right;
};

node * setroot(int n) {
	node *p;
p = new node;
p-&#062;data = n;
p-&#062;left = NULL;
p-&#062;right = NULL;
return p;
}

int insert (int x, node *t1, int a) {

	if (x data) {
if (t1-&#062;left != NULL) {
a = a + 1;
insert(x, t1-&#062;left, a);
} else {
t1-&#062;left = setroot(x);
return a;
}
} else if (x &#062; t1-&#062;data) {
if (t1-&#062;right != NULL) {
a = a + 1;
insert(x, t1-&#062;right, a);
} else {
t1-&#062;right = setroot(x);
return a;
}
}
}

void inorder(node *t1) {

	if(t1 != NULL) {
inorder(t1-&#062;left);
cout &#060;data &#060;right);	
}
}

int freqh(int freq[], int keys[], int n) {

	int x, y, z;
x = freq[0];
y = 0;

for(int i = 1; i &#060; n; i++) {
if (x &#060; freq[i]) {
x = freq[i];
y = i;
}	
}
if (x != 0) {
freq[y] = 0;
return keys[y];
} else {
return 999;
}
}

int main()
{

	node *p;

	int n, k, sum = 0, z = 2, a;
int keys[] = {10, 12, 20};
int freq[] = {34, 8, 50};

a = sizeof(keys)/sizeof(keys[0]);
n = freqh(freq, keys, a);
sum = n;

	if(n != 999) {
p = setroot(n);
} else {
p = NULL;
}

	while(n != 999) {
n = freqh(freq, keys, a);
if(n != 999) {	
k = insert(n, p, z);
sum = sum + (n * k);
}
}

	cout &#060;&#060; &#034;The cost of the tree is : &#034; &#060;&#060; sum;
cout &#060;&#060; &#034;nTree is :n&#034;;

	inorder(p);

	return 0;
}]]></description>
		<content:encoded><![CDATA[<p>Following code is simple and easy to understand.</p>
<p>#include<br />
#include </p>
<p>using namespace std;</p>
<p>struct node {<br />
   int data;<br />
   node *left;<br />
   node *right;<br />
};</p>
<p>node * setroot(int n) {<br />
	node *p;<br />
p = new node;<br />
p-&gt;data = n;<br />
p-&gt;left = NULL;<br />
p-&gt;right = NULL;<br />
return p;<br />
}</p>
<p>int insert (int x, node *t1, int a) {</p>
<p>	if (x data) {<br />
if (t1-&gt;left != NULL) {<br />
a = a + 1;<br />
insert(x, t1-&gt;left, a);<br />
} else {<br />
t1-&gt;left = setroot(x);<br />
return a;<br />
}<br />
} else if (x &gt; t1-&gt;data) {<br />
if (t1-&gt;right != NULL) {<br />
a = a + 1;<br />
insert(x, t1-&gt;right, a);<br />
} else {<br />
t1-&gt;right = setroot(x);<br />
return a;<br />
}<br />
}<br />
}</p>
<p>void inorder(node *t1) {</p>
<p>	if(t1 != NULL) {<br />
inorder(t1-&gt;left);<br />
cout &lt;data &lt;right);<br />
}<br />
}</p>
<p>int freqh(int freq[], int keys[], int n) {</p>
<p>	int x, y, z;<br />
x = freq[0];<br />
y = 0;</p>
<p>for(int i = 1; i &lt; n; i++) {<br />
if (x &lt; freq[i]) {<br />
x = freq[i];<br />
y = i;<br />
}<br />
}<br />
if (x != 0) {<br />
freq[y] = 0;<br />
return keys[y];<br />
} else {<br />
return 999;<br />
}<br />
}</p>
<p>int main()<br />
{</p>
<p>	node *p;</p>
<p>	int n, k, sum = 0, z = 2, a;<br />
int keys[] = {10, 12, 20};<br />
int freq[] = {34, 8, 50};</p>
<p>a = sizeof(keys)/sizeof(keys[0]);<br />
n = freqh(freq, keys, a);<br />
sum = n;</p>
<p>	if(n != 999) {<br />
p = setroot(n);<br />
} else {<br />
p = NULL;<br />
}</p>
<p>	while(n != 999) {<br />
n = freqh(freq, keys, a);<br />
if(n != 999) {<br />
k = insert(n, p, z);<br />
sum = sum + (n * k);<br />
}<br />
}</p>
<p>	cout &lt;&lt; &quot;The cost of the tree is : &quot; &lt;&lt; sum;<br />
cout &lt;&lt; &quot;nTree is :n&quot;;</p>
<p>	inorder(p);</p>
<p>	return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gautam</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-31289</link>
		<dc:creator><![CDATA[gautam]]></dc:creator>
		<pubDate>Sun, 05 Jan 2014 23:14:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-31289</guid>
		<description><![CDATA[Example that shows greedy doesn&#039;t work
keys[x,y,z,w]   frequency[ 2, 
8, 1, 9]  and given that x&#060;y&#060;z&#060;w. so choosing greedy w as a root will have cost 34 but choosing the y as root have cost 33.]]></description>
		<content:encoded><![CDATA[<p>Example that shows greedy doesn&#8217;t work<br />
keys[x,y,z,w]   frequency[ 2,<br />
8, 1, 9]  and given that x&lt;y&lt;z&lt;w. so choosing greedy w as a root will have cost 34 but choosing the y as root have cost 33.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gautam</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-31288</link>
		<dc:creator><![CDATA[gautam]]></dc:creator>
		<pubDate>Sun, 05 Jan 2014 23:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-31288</guid>
		<description><![CDATA[Example that shows greedy doesn&#039;t work
keys[x,y,z,w]   frequency[ 2, 8, 1, 9]  and given that x&#060;y&#060;z&#060;w  so if you build the BST with w(maximum frequency) you will get total cost 34 , while if you build the BST with y(frequency 8) as a root you will get the total cost 33. Which shows that greedy won&#039;t work here.]]></description>
		<content:encoded><![CDATA[<p>Example that shows greedy doesn&#8217;t work<br />
keys[x,y,z,w]   frequency[ 2, 8, 1, 9]  and given that x&lt;y&lt;z&lt;w  so if you build the BST with w(maximum frequency) you will get total cost 34 , while if you build the BST with y(frequency 8) as a root you will get the total cost 33. Which shows that greedy won&#039;t work here.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-30580</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Mon, 09 Dec 2013 09:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-30580</guid>
		<description><![CDATA[#include
#define infinity 999999
using namespace std;
struct s
{
    int key;
    int freq;
};
int fun(s *arr,int n)
{
    if(n==0)
       return 0;
    if(n==1)
       return (arr[0].freq);
    s *left,*right;
    int min=infinity;int i,j,m;
    for(i=0;i&#060;n;i++)
    {
      int r_cost=0,s1=0,s2=0,p1=0,p2=0;
        for(j=0;j&#060;n;j++)
        {
            if(j==i)
               continue;
            r_cost=r_cost+arr[j].freq;
            if(arr[j].key&#060;arr[i].key)
               s1++;
            else
               s2++;
        }
        left=new s[s1];
        right=new s[s2];
        for(j=0;j&#060;n;j++)
        {
            if(j==i)
               continue;
            if(arr[j].key&#060;arr[i].key)
               {
                   left[p1].key=arr[j].key;
                   left[p1].freq=arr[j].freq;
                   p1++;
               }
            else
               {
                   right[p2].key=arr[j].key;
                   right[p2].freq=arr[j].freq;
                   p2++;
               }
        }
        m=arr[i].freq+fun(left,s1)+fun(right,s2)+r_cost;
        if(m&#060;min)
          min=m;
    }
    return min;
}
int main()
{
    int n;
    cout&#060;&#062;n;
    s *arr=new s[n];
    for(int i=0;i&#060;n;i++)
    {
        cout&#060;&#060;&#034;enter the &#034;&#060;&#060;i+1&#060;&#062;arr[i].key&#062;&#062;arr[i].freq;
    }
    cout&#060;&#060;fun(arr,n)&#060;&#060;&#034; is the optimal cost.n&#034;;
    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#define infinity 999999<br />
using namespace std;<br />
struct s<br />
{<br />
    int key;<br />
    int freq;<br />
};<br />
int fun(s *arr,int n)<br />
{<br />
    if(n==0)<br />
       return 0;<br />
    if(n==1)<br />
       return (arr[0].freq);<br />
    s *left,*right;<br />
    int min=infinity;int i,j,m;<br />
    for(i=0;i&lt;n;i++)<br />
    {<br />
      int r_cost=0,s1=0,s2=0,p1=0,p2=0;<br />
        for(j=0;j&lt;n;j++)<br />
        {<br />
            if(j==i)<br />
               continue;<br />
            r_cost=r_cost+arr[j].freq;<br />
            if(arr[j].key&lt;arr[i].key)<br />
               s1++;<br />
            else<br />
               s2++;<br />
        }<br />
        left=new s[s1];<br />
        right=new s[s2];<br />
        for(j=0;j&lt;n;j++)<br />
        {<br />
            if(j==i)<br />
               continue;<br />
            if(arr[j].key&lt;arr[i].key)<br />
               {<br />
                   left[p1].key=arr[j].key;<br />
                   left[p1].freq=arr[j].freq;<br />
                   p1++;<br />
               }<br />
            else<br />
               {<br />
                   right[p2].key=arr[j].key;<br />
                   right[p2].freq=arr[j].freq;<br />
                   p2++;<br />
               }<br />
        }<br />
        m=arr[i].freq+fun(left,s1)+fun(right,s2)+r_cost;<br />
        if(m&lt;min)<br />
          min=m;<br />
    }<br />
    return min;<br />
}<br />
int main()<br />
{<br />
    int n;<br />
    cout&lt;&gt;n;<br />
    s *arr=new s[n];<br />
    for(int i=0;i&lt;n;i++)<br />
    {<br />
        cout&lt;&lt;&quot;enter the &quot;&lt;&lt;i+1&lt;&gt;arr[i].key&gt;&gt;arr[i].freq;<br />
    }<br />
    cout&lt;&lt;fun(arr,n)&lt;&lt;&quot; is the optimal cost.n&quot;;<br />
    return 0;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: BSTlover</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-29169</link>
		<dc:creator><![CDATA[BSTlover]]></dc:creator>
		<pubDate>Mon, 21 Oct 2013 12:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-29169</guid>
		<description><![CDATA[Can you share that solutions pls?]]></description>
		<content:encoded><![CDATA[<p>Can you share that solutions pls?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jv</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-28155</link>
		<dc:creator><![CDATA[jv]]></dc:creator>
		<pubDate>Fri, 27 Sep 2013 03:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-28155</guid>
		<description><![CDATA[regarding

2) In the above solutions, we have computed optimal cost only. The solutions can be easily modified to store the structure of BSTs also. We can create another auxiliary array of size n to store the structure of tree. All we need to do is, store the chosen ‘r’ in the innermost loop.



i think this needs any array of NxN as we need to store r at every level and back trace at the end.


Can you please explain how this can be done with array of size N only.]]></description>
		<content:encoded><![CDATA[<p>regarding</p>
<p>2) In the above solutions, we have computed optimal cost only. The solutions can be easily modified to store the structure of BSTs also. We can create another auxiliary array of size n to store the structure of tree. All we need to do is, store the chosen ‘r’ in the innermost loop.</p>
<p>i think this needs any array of NxN as we need to store r at every level and back trace at the end.</p>
<p>Can you please explain how this can be done with array of size N only.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jv</title>
		<link>http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/#comment-28154</link>
		<dc:creator><![CDATA[jv]]></dc:creator>
		<pubDate>Fri, 27 Sep 2013 03:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=28316#comment-28154</guid>
		<description><![CDATA[lets say
keys[]={1,2,3}
frequency[]={3,10,5}
when you are considering 2 as root and finding the min cost
mincostof(1, with size 1)+mincostof(3, with size 1) + costof 2(=10) + since now element 1 and elment 3 is moved to second level you need to add there cost also(=3+5)


so if see the total will become


cost of all keys + minat 1 + mniat 3


hope it clears this now]]></description>
		<content:encoded><![CDATA[<p>lets say<br />
keys[]={1,2,3}<br />
frequency[]={3,10,5}<br />
when you are considering 2 as root and finding the min cost<br />
mincostof(1, with size 1)+mincostof(3, with size 1) + costof 2(=10) + since now element 1 and elment 3 is moved to second level you need to add there cost also(=3+5)</p>
<p>so if see the total will become</p>
<p>cost of all keys + minat 1 + mniat 3</p>
<p>hope it clears this now</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.065 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:09:46 -->

<!-- Compression = gzip -->