<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Flatten a multilevel linked list</title>
	<atom:link href="http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: KeshaShah</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-40172</link>
		<dc:creator><![CDATA[KeshaShah]]></dc:creator>
		<pubDate>Sun, 29 Jun 2014 14:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-40172</guid>
		<description><![CDATA[Isn&#039;t queue a good idea ? traverse the first row and keep inserting in the queue those elements whose down pointer is not null. And repeat this till list is not empty]]></description>
		<content:encoded><![CDATA[<p>Isn&#8217;t queue a good idea ? traverse the first row and keep inserting in the queue those elements whose down pointer is not null. And repeat this till list is not empty</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: max</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-39050</link>
		<dc:creator><![CDATA[max]]></dc:creator>
		<pubDate>Wed, 18 Jun 2014 15:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-39050</guid>
		<description><![CDATA[/* an approach using queue*/

void flatten_list(struct node *h)
{
queue Q;
struct node *temp;
if( !h)
    return ;
enqueue(Q,h);

while( is_queue_empty(Q)
{
    temp=dequeue(Q);
    
    while(temp)
    {
        if(temp-&#062;child)
            enqueue(Q,temp-&#062;child);
        printf(&quot;%d    &quot;,temp-&#062;data);
        temp=temp-&#062;next;
    }
}]]></description>
		<content:encoded><![CDATA[<p>/* an approach using queue*/</p>
<p>void flatten_list(struct node *h)<br />
{<br />
queue Q;<br />
struct node *temp;<br />
if( !h)<br />
    return ;<br />
enqueue(Q,h);</p>
<p>while( is_queue_empty(Q)<br />
{<br />
    temp=dequeue(Q);</p>
<p>    while(temp)<br />
    {<br />
        if(temp-&gt;child)<br />
            enqueue(Q,temp-&gt;child);<br />
        printf(&#8220;%d    &#8220;,temp-&gt;data);<br />
        temp=temp-&gt;next;<br />
    }<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: MK</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-38405</link>
		<dc:creator><![CDATA[MK]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 09:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-38405</guid>
		<description><![CDATA[Why it wont&#039; work? Can you please explain? I guess it works if correction made as suggested below!]]></description>
		<content:encoded><![CDATA[<p>Why it wont&#8217; work? Can you please explain? I guess it works if correction made as suggested below!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: santosh gupta</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-36190</link>
		<dc:creator><![CDATA[santosh gupta]]></dc:creator>
		<pubDate>Sun, 18 May 2014 05:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-36190</guid>
		<description><![CDATA[if there is only a single element in the first level, it will not work]]></description>
		<content:encoded><![CDATA[<p>if there is only a single element in the first level, it will not work</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kaushik Lele</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-35138</link>
		<dc:creator><![CDATA[kaushik Lele]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 06:10:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-35138</guid>
		<description><![CDATA[flattenList has main loop as 
while (cur != tail)
So it will not handle to childs of tail. It should have been 
while (cur != NULL)



Please update code.]]></description>
		<content:encoded><![CDATA[<p>flattenList has main loop as<br />
while (cur != tail)<br />
So it will not handle to childs of tail. It should have been<br />
while (cur != NULL)</p>
<p>Please update code.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vishal</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-33248</link>
		<dc:creator><![CDATA[Vishal]]></dc:creator>
		<pubDate>Thu, 06 Mar 2014 09:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-33248</guid>
		<description><![CDATA[class Queue childList;
/* The main function that flattens a multilevel linked list */
node* flattenList( node *head)
{   
    if (head == NULL)
       return 0;
 
    node *temp = head;  
    while(temp-&#062;next)
    {
        if(temp-&#062;child)
        {
            childList.Enqueue(temp-&#062;child);
        }
        temp = temp-&#062;next;
    }
    temp-&#062;next = childList.Dqueue();
    flattenList(temp-&#062;next);

    return head;
}]]></description>
		<content:encoded><![CDATA[<p>class Queue childList;<br />
/* The main function that flattens a multilevel linked list */<br />
node* flattenList( node *head)<br />
{<br />
    if (head == NULL)<br />
       return 0;</p>
<p>    node *temp = head;<br />
    while(temp-&gt;next)<br />
    {<br />
        if(temp-&gt;child)<br />
        {<br />
            childList.Enqueue(temp-&gt;child);<br />
        }<br />
        temp = temp-&gt;next;<br />
    }<br />
    temp-&gt;next = childList.Dqueue();<br />
    flattenList(temp-&gt;next);</p>
<p>    return head;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: xxmajia</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-31578</link>
		<dc:creator><![CDATA[xxmajia]]></dc:creator>
		<pubDate>Fri, 17 Jan 2014 06:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-31578</guid>
		<description><![CDATA[according to &quot;which may or may not point to a separate list&quot;

i think its easier to use a queue structure to solve this puzzle

public static ListNode flattern(ListNode head) {

		if (head == null) {

			return head;

		}

		

		Queue queue = new LinkedList();

		ListNode newHead = new ListNode();

		ListNode cur = newHead;

		queue.add(head);

		while (!queue.isEmpty()) {

			ListNode node = queue.poll();

			while (node.next != null) {

				cur.next = node;

				cur = cur.next;

				if (node.random != null) {

					queue.add(node.random);

				}

				

				node = node.next;

			}

		}

		

		return newHead.next;

	}]]></description>
		<content:encoded><![CDATA[<p>according to &#8220;which may or may not point to a separate list&#8221;</p>
<p>i think its easier to use a queue structure to solve this puzzle</p>
<p>public static ListNode flattern(ListNode head) {</p>
<p>		if (head == null) {</p>
<p>			return head;</p>
<p>		}</p>
<p>		Queue queue = new LinkedList();</p>
<p>		ListNode newHead = new ListNode();</p>
<p>		ListNode cur = newHead;</p>
<p>		queue.add(head);</p>
<p>		while (!queue.isEmpty()) {</p>
<p>			ListNode node = queue.poll();</p>
<p>			while (node.next != null) {</p>
<p>				cur.next = node;</p>
<p>				cur = cur.next;</p>
<p>				if (node.random != null) {</p>
<p>					queue.add(node.random);</p>
<p>				}</p>
<p>				node = node.next;</p>
<p>			}</p>
<p>		}</p>
<p>		return newHead.next;</p>
<p>	}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anil</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-31484</link>
		<dc:creator><![CDATA[Anil]]></dc:creator>
		<pubDate>Sun, 12 Jan 2014 21:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-31484</guid>
		<description><![CDATA[Queue can be use to solve this problem]]></description>
		<content:encoded><![CDATA[<p>Queue can be use to solve this problem</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mohan Kishor</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-27455</link>
		<dc:creator><![CDATA[Mohan Kishor]]></dc:creator>
		<pubDate>Mon, 09 Sep 2013 16:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-27455</guid>
		<description><![CDATA[Hey, Your code will not work in the case where all nodes have both the NEXT and CHILD nodes except for the last node in the list whose NEXT pointer is NULL but with a CHILD pointer.This is because the end finder while loop traverses only considering the NEXT pointer but not the other nodes CHILD pointer.Please check your code.]]></description>
		<content:encoded><![CDATA[<p>Hey, Your code will not work in the case where all nodes have both the NEXT and CHILD nodes except for the last node in the list whose NEXT pointer is NULL but with a CHILD pointer.This is because the end finder while loop traverses only considering the NEXT pointer but not the other nodes CHILD pointer.Please check your code.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ishita</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-22366</link>
		<dc:creator><![CDATA[Ishita]]></dc:creator>
		<pubDate>Fri, 19 Jul 2013 08:54:34 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-22366</guid>
		<description><![CDATA[Your code works incorrectly if the tail has a child. Ex if in your test case 15 were to have a child, that child wont get included in the flattened list. Instead you should change 
while(cur!=tail) to while(cur)


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Your code works incorrectly if the tail has a child. Ex if in your test case 15 were to have a child, that child wont get included in the flattened list. Instead you should change<br />
while(cur!=tail) to while(cur)</p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Manisha Barnwal</title>
		<link>http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/#comment-25575</link>
		<dc:creator><![CDATA[Manisha Barnwal]]></dc:creator>
		<pubDate>Sat, 22 Jun 2013 22:08:38 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=114576#comment-25575</guid>
		<description><![CDATA[/*I think the insert function can be implemented as:
where parent and sibling=-1 if not applicable.
otherwise, it is insert(&#038;start, 2,-1,1);*/.
void insert(list **start, int num, int parent, int sibling).
{



list *p;.



list *temp=(list*)malloc(sizeof(list));.



temp-&#062;data=num;.



temp-&#062;next=NULL;.



temp-&#062;child=NULL;.



if(*start==NULL).



{.



*start=temp;.



}.



else.



{.



if(parent!=-1).



{.




p=search(*start, parent);.



if(p!=NULL).



{.



p-&#062;child=temp;.



}.       



}.



else if(sibling!=-1).



{.



p=search(*start, sibling);.



if(p!=NULL).



if(p!=NULL).



p-&#062;next=temp;.



}.



}.
}]]></description>
		<content:encoded><![CDATA[<p>/*I think the insert function can be implemented as:<br />
where parent and sibling=-1 if not applicable.<br />
otherwise, it is insert(&amp;start, 2,-1,1);*/.<br />
void insert(list **start, int num, int parent, int sibling).<br />
{</p>
<p>list *p;.</p>
<p>list *temp=(list*)malloc(sizeof(list));.</p>
<p>temp-&gt;data=num;.</p>
<p>temp-&gt;next=NULL;.</p>
<p>temp-&gt;child=NULL;.</p>
<p>if(*start==NULL).</p>
<p>{.</p>
<p>*start=temp;.</p>
<p>}.</p>
<p>else.</p>
<p>{.</p>
<p>if(parent!=-1).</p>
<p>{.</p>
<p>p=search(*start, parent);.</p>
<p>if(p!=NULL).</p>
<p>{.</p>
<p>p-&gt;child=temp;.</p>
<p>}.       </p>
<p>}.</p>
<p>else if(sibling!=-1).</p>
<p>{.</p>
<p>p=search(*start, sibling);.</p>
<p>if(p!=NULL).</p>
<p>if(p!=NULL).</p>
<p>p-&gt;next=temp;.</p>
<p>}.</p>
<p>}.<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.045 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:14:53 -->

<!-- Compression = gzip -->