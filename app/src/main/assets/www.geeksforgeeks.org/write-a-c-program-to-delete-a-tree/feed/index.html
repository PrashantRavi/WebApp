<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Write a  program to Delete a Tree.</title>
	<atom:link href="http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ashish jaiswal</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-39629</link>
		<dc:creator><![CDATA[ashish jaiswal]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 11:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-39629</guid>
		<description><![CDATA[I am not able to understand the unwrapping of recursive fucntion.....bit of it got it right....rest is going above head....any one to throw little light over it??? thanks in advance...]]></description>
		<content:encoded><![CDATA[<p>I am not able to understand the unwrapping of recursive fucntion&#8230;..bit of it got it right&#8230;.rest is going above head&#8230;.any one to throw little light over it??? thanks in advance&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: codead</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-39448</link>
		<dc:creator><![CDATA[codead]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 12:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-39448</guid>
		<description><![CDATA[i have a question regarding the above given methods........
if we delete a node in a tree then we need to ensure that we set the left/right pointers of the parent of that child to NULL. e.g.- if &#039;q&#039; is the left child of say &#039;f&#039; then if we delete &#039;q&#039; then f-&#062;left should be set to NULL. none of the above programs do that, why???
and without that how do these programs work??
plz explain.....thanks in advance :)]]></description>
		<content:encoded><![CDATA[<p>i have a question regarding the above given methods&#8230;&#8230;..<br />
if we delete a node in a tree then we need to ensure that we set the left/right pointers of the parent of that child to NULL. e.g.- if &#8216;q&#8217; is the left child of say &#8216;f&#8217; then if we delete &#8216;q&#8217; then f-&gt;left should be set to NULL. none of the above programs do that, why???<br />
and without that how do these programs work??<br />
plz explain&#8230;..thanks in advance ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Baghel</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-39159</link>
		<dc:creator><![CDATA[Amit Baghel]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 14:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-39159</guid>
		<description><![CDATA[visited!]]></description>
		<content:encoded><![CDATA[<p>visited!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Deepesh Panjabi</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-38203</link>
		<dc:creator><![CDATA[Deepesh Panjabi]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 11:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-38203</guid>
		<description><![CDATA[http://ideone.com/WH3K5s]]></description>
		<content:encoded><![CDATA[<p><a href="http://ideone.com/WH3K5s" rel="nofollow">http://ideone.com/WH3K5s</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit Kumar</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-38147</link>
		<dc:creator><![CDATA[Rohit Kumar]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 20:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-38147</guid>
		<description><![CDATA[#include
#include
struct node
{
    int data;
    struct node *prev;
    struct node* next;
};
void deleting(struct node*);
void preorder(struct node*);
struct node* create(struct node*,int);
int main()
{
    int n;
    struct node*head;
    head=NULL;
    head=create(head,4);
    create(head,2);
    create(head,6);
    create(head,1);
    create(head,3);
    create(head,5);
    create(head,8);
    create(head,7);
    create(head,9);
    create(head,10);
   while(1)
   {
      printf(&quot;ndo you want to delete node (if yes press 1):&quot;);
      scanf(&quot;%d&quot;,&#038;n);
      if(n!=1)break;
      deleting(head);
      printf(&quot;nafter deletion tree: n&quot;);
      preorder(head);
   }
    return 0;
}
struct node* create(struct node*root,int n)
{
    if(root==NULL)
    {
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));
        newnode-&#062;data=n;
        newnode-&#062;next=NULL;
        newnode-&#062;prev=NULL;
        root=newnode;
    }
    else if(root-&#062;data&#062;=n)
    {
        if(root-&#062;prev==NULL)
        {
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));
        newnode-&#062;data=n;
        newnode-&#062;next=NULL;
        newnode-&#062;prev=NULL;
         root-&#062;prev=newnode;
        }
        else
            create(root-&#062;prev,n);
    }
    else
    {
        if(root-&#062;next==NULL)
        {
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));
        newnode-&#062;data=n;
        newnode-&#062;next=NULL;
        newnode-&#062;prev=NULL;
         root-&#062;next=newnode;
        }
        else
            create(root-&#062;next,n);
    }
    return(root);
}
void deleting(struct node* node)
{
    if (node == NULL) return;
   else if((node-&#062;prev==NULL)&#038;&#038;(node-&#062;next==NULL)){free(node);return;}
   else if((node-&#062;prev==NULL)&#038;&#038;(node-&#062;next!=NULL))
    {
        if((node-&#062;next-&#062;prev==NULL)&#038;&#038;(node-&#062;next-&#062;next==NULL)){node-&#062;next=NULL;return;}
       else  deleting(node-&#062;next);
    }
   else if((node-&#062;prev!=NULL)&#038;&#038;(node-&#062;next==NULL))
    {
        if((node-&#062;prev-&#062;prev==NULL)&#038;&#038;(node-&#062;prev-&#062;next==NULL)){node-&#062;prev=NULL;return;}
        else deleting(node-&#062;prev);
    }
  else if((node-&#062;prev-&#062;prev==NULL)&#038;&#038;(node-&#062;prev-&#062;next==NULL))node-&#062;prev=NULL;
  else if((node-&#062;next-&#062;prev==NULL)&#038;&#038;(node-&#062;next-&#062;next==NULL))node-&#062;next=NULL;
else
{
     deleting(node-&#062;prev);
     //deleting(node-&#062;next);
}
}
void preorder(struct node *root)
{
    if(root==NULL)return;
    printf(&quot; %d &quot;,root-&#062;data);
    preorder(root-&#062;prev);
    preorder(root-&#062;next);
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
struct node<br />
{<br />
    int data;<br />
    struct node *prev;<br />
    struct node* next;<br />
};<br />
void deleting(struct node*);<br />
void preorder(struct node*);<br />
struct node* create(struct node*,int);<br />
int main()<br />
{<br />
    int n;<br />
    struct node*head;<br />
    head=NULL;<br />
    head=create(head,4);<br />
    create(head,2);<br />
    create(head,6);<br />
    create(head,1);<br />
    create(head,3);<br />
    create(head,5);<br />
    create(head,8);<br />
    create(head,7);<br />
    create(head,9);<br />
    create(head,10);<br />
   while(1)<br />
   {<br />
      printf(&#8220;ndo you want to delete node (if yes press 1):&#8221;);<br />
      scanf(&#8220;%d&#8221;,&amp;n);<br />
      if(n!=1)break;<br />
      deleting(head);<br />
      printf(&#8220;nafter deletion tree: n&#8221;);<br />
      preorder(head);<br />
   }<br />
    return 0;<br />
}<br />
struct node* create(struct node*root,int n)<br />
{<br />
    if(root==NULL)<br />
    {<br />
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));<br />
        newnode-&gt;data=n;<br />
        newnode-&gt;next=NULL;<br />
        newnode-&gt;prev=NULL;<br />
        root=newnode;<br />
    }<br />
    else if(root-&gt;data&gt;=n)<br />
    {<br />
        if(root-&gt;prev==NULL)<br />
        {<br />
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));<br />
        newnode-&gt;data=n;<br />
        newnode-&gt;next=NULL;<br />
        newnode-&gt;prev=NULL;<br />
         root-&gt;prev=newnode;<br />
        }<br />
        else<br />
            create(root-&gt;prev,n);<br />
    }<br />
    else<br />
    {<br />
        if(root-&gt;next==NULL)<br />
        {<br />
        struct node* newnode=(struct node*)malloc(sizeof(struct node*));<br />
        newnode-&gt;data=n;<br />
        newnode-&gt;next=NULL;<br />
        newnode-&gt;prev=NULL;<br />
         root-&gt;next=newnode;<br />
        }<br />
        else<br />
            create(root-&gt;next,n);<br />
    }<br />
    return(root);<br />
}<br />
void deleting(struct node* node)<br />
{<br />
    if (node == NULL) return;<br />
   else if((node-&gt;prev==NULL)&amp;&amp;(node-&gt;next==NULL)){free(node);return;}<br />
   else if((node-&gt;prev==NULL)&amp;&amp;(node-&gt;next!=NULL))<br />
    {<br />
        if((node-&gt;next-&gt;prev==NULL)&amp;&amp;(node-&gt;next-&gt;next==NULL)){node-&gt;next=NULL;return;}<br />
       else  deleting(node-&gt;next);<br />
    }<br />
   else if((node-&gt;prev!=NULL)&amp;&amp;(node-&gt;next==NULL))<br />
    {<br />
        if((node-&gt;prev-&gt;prev==NULL)&amp;&amp;(node-&gt;prev-&gt;next==NULL)){node-&gt;prev=NULL;return;}<br />
        else deleting(node-&gt;prev);<br />
    }<br />
  else if((node-&gt;prev-&gt;prev==NULL)&amp;&amp;(node-&gt;prev-&gt;next==NULL))node-&gt;prev=NULL;<br />
  else if((node-&gt;next-&gt;prev==NULL)&amp;&amp;(node-&gt;next-&gt;next==NULL))node-&gt;next=NULL;<br />
else<br />
{<br />
     deleting(node-&gt;prev);<br />
     //deleting(node-&gt;next);<br />
}<br />
}<br />
void preorder(struct node *root)<br />
{<br />
    if(root==NULL)return;<br />
    printf(&#8221; %d &#8220;,root-&gt;data);<br />
    preorder(root-&gt;prev);<br />
    preorder(root-&gt;next);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aman</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-36005</link>
		<dc:creator><![CDATA[Aman]]></dc:creator>
		<pubDate>Tue, 13 May 2014 19:44:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-36005</guid>
		<description><![CDATA[Try to pass root of the tree as double pointer to make it pass by reference]]></description>
		<content:encoded><![CDATA[<p>Try to pass root of the tree as double pointer to make it pass by reference</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aman</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-35944</link>
		<dc:creator><![CDATA[Aman]]></dc:creator>
		<pubDate>Tue, 13 May 2014 05:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-35944</guid>
		<description><![CDATA[Yeah!! understood now.]]></description>
		<content:encoded><![CDATA[<p>Yeah!! understood now.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: GOPI GOPINATH</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-35942</link>
		<dc:creator><![CDATA[GOPI GOPINATH]]></dc:creator>
		<pubDate>Tue, 13 May 2014 04:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-35942</guid>
		<description><![CDATA[U can just give a base case that root is NULL...need not check it..]]></description>
		<content:encoded><![CDATA[<p>U can just give a base case that root is NULL&#8230;need not check it..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aman</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-35938</link>
		<dc:creator><![CDATA[Aman]]></dc:creator>
		<pubDate>Mon, 12 May 2014 18:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-35938</guid>
		<description><![CDATA[Hi,
 Why arent we checking for conditions whether root has both children or one or none? As I have checked in my code

void DeleteTree(Node*&#038; root)
{
    if(root-&#062;right != NULL &#038;&#038; root-&#062;left != NULL)
    {
        DeleteTree(root-&#062;left);
        DeleteTree(root-&#062;right);
        }
         
    else if(root-&#062;right == NULL &#038;&#038; root-&#062;left != NULL)
        DeleteTree(root-&#062;left);
         
    else if(root-&#062;right != NULL &#038;&#038; root-&#062;left == NULL)
        DeleteTree(root-&#062;right);
    delete root;
    root = NULL;
    }]]></description>
		<content:encoded><![CDATA[<p>Hi,<br />
 Why arent we checking for conditions whether root has both children or one or none? As I have checked in my code</p>
<p>void DeleteTree(Node*&amp; root)<br />
{<br />
    if(root-&gt;right != NULL &amp;&amp; root-&gt;left != NULL)<br />
    {<br />
        DeleteTree(root-&gt;left);<br />
        DeleteTree(root-&gt;right);<br />
        }</p>
<p>    else if(root-&gt;right == NULL &amp;&amp; root-&gt;left != NULL)<br />
        DeleteTree(root-&gt;left);</p>
<p>    else if(root-&gt;right != NULL &amp;&amp; root-&gt;left == NULL)<br />
        DeleteTree(root-&gt;right);<br />
    delete root;<br />
    root = NULL;<br />
    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Marsha Donna</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-33197</link>
		<dc:creator><![CDATA[Marsha Donna]]></dc:creator>
		<pubDate>Tue, 04 Mar 2014 13:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-33197</guid>
		<description><![CDATA[after freeing each node in postorder manner are we setting the node to NULL .Is this wat this function is doing??? pls clarify soon]]></description>
		<content:encoded><![CDATA[<p>after freeing each node in postorder manner are we setting the node to NULL .Is this wat this function is doing??? pls clarify soon</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/#comment-33184</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Tue, 04 Mar 2014 09:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=654#comment-33184</guid>
		<description><![CDATA[can someone tel why i am not getting the correct output for the following code ......
the whole prgm is @ the link http://ideone.com/FI6X0Q


void postorder_del(struct node*root)

{

	if(root==NULL)return;

	postorder_del(root-&#062;left);

	postorder_del(root-&#062;right);

	if(root-&#062;left==NULL&#038;&#038;root-&#062;right==NULL)

	free(root);

}]]></description>
		<content:encoded><![CDATA[<p>can someone tel why i am not getting the correct output for the following code &#8230;&#8230;<br />
the whole prgm is @ the link <a href="http://ideone.com/FI6X0Q" rel="nofollow">http://ideone.com/FI6X0Q</a></p>
<p>void postorder_del(struct node*root)</p>
<p>{</p>
<p>	if(root==NULL)return;</p>
<p>	postorder_del(root-&gt;left);</p>
<p>	postorder_del(root-&gt;right);</p>
<p>	if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)</p>
<p>	free(root);</p>
<p>}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.044 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:17:28 -->

<!-- Compression = gzip -->