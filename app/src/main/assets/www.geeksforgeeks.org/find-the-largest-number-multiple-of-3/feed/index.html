<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find the largest multiple of 3 &#124; Set 1 (Using Queue)</title>
	<atom:link href="http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: S?njiv Kumar</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-36407</link>
		<dc:creator><![CDATA[S?njiv Kumar]]></dc:creator>
		<pubDate>Wed, 21 May 2014 11:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-36407</guid>
		<description><![CDATA[we can implement it without queue 
just count no of elements congruent to 1mod3 and 2mod3 and 
using some rules .......
O(n) time and O(1)space to find included digits 
http://ideone.com/e.js/gDHYDj
]]></description>
		<content:encoded><![CDATA[<p>we can implement it without queue<br />
just count no of elements congruent to 1mod3 and 2mod3 and<br />
using some rules &#8230;&#8230;.<br />
O(n) time and O(1)space to find included digits<br />
<a href="http://ideone.com/e.js/gDHYDj" rel="nofollow">http://ideone.com/e.js/gDHYDj</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-36134</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 16 May 2014 13:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-36134</guid>
		<description><![CDATA[can&#039;t we do like this?
Example :
[8,1,7,6,0]
1. Sort in descending order = [8,7,6,1,0]


2. if sum % 3 == 0 return list/array
 Else:]]></description>
		<content:encoded><![CDATA[<p>can&#8217;t we do like this?<br />
Example :<br />
[8,1,7,6,0]<br />
1. Sort in descending order = [8,7,6,1,0]</p>
<p>2. if sum % 3 == 0 return list/array<br />
 Else:</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: PRADIP_ACHARJEE</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-35977</link>
		<dc:creator><![CDATA[PRADIP_ACHARJEE]]></dc:creator>
		<pubDate>Tue, 13 May 2014 12:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-35977</guid>
		<description><![CDATA[ok...its a really nice approach.
I think we can choose the element to be discard more easily from queue1 and queue2.
As like:-

          Queue0--&#062;&#062; Yeah all elements are considerable as they are divisible by  3.
suppose, queue1 and queue2 has the following elements---&#062;

          Queue1---&#062;&#062; 1, 7,7,7   // so size is = 4 ,( produces reminder 1)
          Queue2---&#062;&#062; 5,8,8       // so size is = 3 ,( produces reminder 2)

so if you sum up all the elements of Queue1 and Queue2 and divide the sum by 3 ------what will be the remainder??!!!

    (size_of_queue1 * 1 + size_of_queue2 * 2) % 3 = (4*1+3*2) %3 = 1

so 
Logic-1&#062;&#062; If remainder is 1; Discard an element from queue1.
Logic-2&#062;&#062; if remainder is 2; discard an element from queue2.

Logic-3&#062;&#062; if remainder is 0; No need to discard.

Logic-4&#062;&#062; If queue1 is empty the size of queue2 should be multiple of 3. If its not multiple of 3 , then discard elements from queue2 such that the size should be multiple of 3. Though if its not possible to make the size multiple of 3 , then the no is not possible by queue1 and queue2.

Logic-5&#062;&#062; same as logic--&#062;&#062;4 for queue2 also. vice-verse.

So after discard, you can consider rest of all digits.( As the sum of rest of all digits will be divisible by 3).

Please write comments if you find anything incorrect.]]></description>
		<content:encoded><![CDATA[<p>ok&#8230;its a really nice approach.<br />
I think we can choose the element to be discard more easily from queue1 and queue2.<br />
As like:-</p>
<p>          Queue0&#8211;&gt;&gt; Yeah all elements are considerable as they are divisible by  3.<br />
suppose, queue1 and queue2 has the following elements&#8212;&gt;</p>
<p>          Queue1&#8212;&gt;&gt; 1, 7,7,7   // so size is = 4 ,( produces reminder 1)<br />
          Queue2&#8212;&gt;&gt; 5,8,8       // so size is = 3 ,( produces reminder 2)</p>
<p>so if you sum up all the elements of Queue1 and Queue2 and divide the sum by 3 &#8212;&#8212;what will be the remainder??!!!</p>
<p>    (size_of_queue1 * 1 + size_of_queue2 * 2) % 3 = (4*1+3*2) %3 = 1</p>
<p>so<br />
Logic-1&gt;&gt; If remainder is 1; Discard an element from queue1.<br />
Logic-2&gt;&gt; if remainder is 2; discard an element from queue2.</p>
<p>Logic-3&gt;&gt; if remainder is 0; No need to discard.</p>
<p>Logic-4&gt;&gt; If queue1 is empty the size of queue2 should be multiple of 3. If its not multiple of 3 , then discard elements from queue2 such that the size should be multiple of 3. Though if its not possible to make the size multiple of 3 , then the no is not possible by queue1 and queue2.</p>
<p>Logic-5&gt;&gt; same as logic&#8211;&gt;&gt;4 for queue2 also. vice-verse.</p>
<p>So after discard, you can consider rest of all digits.( As the sum of rest of all digits will be divisible by 3).</p>
<p>Please write comments if you find anything incorrect.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anon</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-34844</link>
		<dc:creator><![CDATA[Anon]]></dc:creator>
		<pubDate>Sat, 19 Apr 2014 06:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-34844</guid>
		<description><![CDATA[so that we do not remove larger numbers for smaller numbers :)]]></description>
		<content:encoded><![CDATA[<p>so that we do not remove larger numbers for smaller numbers ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hawk Eye</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-24586</link>
		<dc:creator><![CDATA[Hawk Eye]]></dc:creator>
		<pubDate>Mon, 05 Aug 2013 16:17:47 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-24586</guid>
		<description><![CDATA[&#034;The above code works only if the input arrays has numbers from 0 to 9. It can be easily extended for any positive integer array.&#034;
I&#039;m sorry... but I think for other integers it would be a bit difficult... 
like if the sum of digits produces remainder 2...
and q1={1,1,...} and q2={23,26,....}
then I think it&#039;s optimal to remove two item (1 and 1) from q1 than removing only single item (23) from q2.... 
correct me if I&#039;m wrong... :)]]></description>
		<content:encoded><![CDATA[<p>&quot;The above code works only if the input arrays has numbers from 0 to 9. It can be easily extended for any positive integer array.&quot;<br />
I&#039;m sorry&#8230; but I think for other integers it would be a bit difficult&#8230;<br />
like if the sum of digits produces remainder 2&#8230;<br />
and q1={1,1,&#8230;} and q2={23,26,&#8230;.}<br />
then I think it&#039;s optimal to remove two item (1 and 1) from q1 than removing only single item (23) from q2&#8230;.<br />
correct me if I&#039;m wrong&#8230; ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hawk Eye</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-26541</link>
		<dc:creator><![CDATA[Hawk Eye]]></dc:creator>
		<pubDate>Mon, 05 Aug 2013 16:17:47 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-26541</guid>
		<description><![CDATA[&#034;The above code works only if the input arrays has numbers from 0 to 9. It can be easily extended for any positive integer array.&#034;
I&#039;m sorry... but I think for other integers it would be a bit difficult... 
like if the sum of digits produces remainder 2...
and q1={1,1,...} and q2={23,26,....}
then I think it&#039;s optimal to remove two item (1 and 1) from q1 than removing only single item (23) from q2.... 
correct me if I&#039;m wrong... :)]]></description>
		<content:encoded><![CDATA[<p>&quot;The above code works only if the input arrays has numbers from 0 to 9. It can be easily extended for any positive integer array.&quot;<br />
I&#039;m sorry&#8230; but I think for other integers it would be a bit difficult&#8230;<br />
like if the sum of digits produces remainder 2&#8230;<br />
and q1={1,1,&#8230;} and q2={23,26,&#8230;.}<br />
then I think it&#039;s optimal to remove two item (1 and 1) from q1 than removing only single item (23) from q2&#8230;.<br />
correct me if I&#039;m wrong&#8230; ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: raghson</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-22047</link>
		<dc:creator><![CDATA[raghson]]></dc:creator>
		<pubDate>Sat, 13 Jul 2013 13:54:59 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-22047</guid>
		<description><![CDATA[I could not get that why we need to sort the array in ascending order initially. I don&#039;t think sorting is needed initially.]]></description>
		<content:encoded><![CDATA[<p>I could not get that why we need to sort the array in ascending order initially. I don&#8217;t think sorting is needed initially.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: thepace</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-16851</link>
		<dc:creator><![CDATA[thepace]]></dc:creator>
		<pubDate>Fri, 29 Mar 2013 07:50:19 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-16851</guid>
		<description><![CDATA[Hi,
I think the above solution can be simplified with the above solution of counting sort.
Here is my solution: &quot;http://codepad.org/UdX8EOs7&quot;
Steps:
a)Get the input..&lt;Output: arr[])
b)Do counting sort.&lt;Output: count_sort[])
c)Calculate the two values:
  i)rem_one: Stores the number of numbers with remainder 1;
  i)rem_two: Stores the number of numbers with remainder 2;
d)Adjust count_sort array so that its divisible by 3.
  Func: MAKE_REM_ZERO(..)
Step1: Calculate the final remainder =((rem_two&lt;&lt;1)+rem_one)%3; 
Step2: If final_rem=1
          If rem_one&gt;0 =&gt; decrease count_sort[3*i+1] 
          else if rem_two&gt;1 =&gt; decrease count_sort[3*i+2] twice.
          else return false;
       else
          If rem_two&gt;0 =&gt; decrease count_sort[3*i+2] 
          else if rem_one&gt;1 =&gt; decrease count_sort[3*i+1] twice.
          else return false;

e)Print count_sort array with the &quot;i&quot; value for count_sort[i] times.

Complexity: O(n);]]></description>
		<content:encoded><![CDATA[<p>Hi,<br />
I think the above solution can be simplified with the above solution of counting sort.<br />
Here is my solution: &#8220;http://codepad.org/UdX8EOs7&#8221;<br />
Steps:<br />
a)Get the input..<output: arr[])
b)Do counting sort.<Output: count_sort[])
c)Calculate the two values:
  i)rem_one: Stores the number of numbers with remainder 1;
  i)rem_two: Stores the number of numbers with remainder 2;
d)Adjust count_sort array so that its divisible by 3.
  Func: MAKE_REM_ZERO(..)
Step1: Calculate the final remainder =((rem_two<&lt;1)+rem_one)%3; 
Step2: If final_rem=1
          If rem_one>0 => decrease count_sort[3*i+1]<br />
          else if rem_two>1 => decrease count_sort[3*i+2] twice.<br />
          else return false;<br />
       else<br />
          If rem_two>0 => decrease count_sort[3*i+2]<br />
          else if rem_one>1 => decrease count_sort[3*i+1] twice.<br />
          else return false;</p>
<p>e)Print count_sort array with the &#8220;i&#8221; value for count_sort[i] times.</p>
<p>Complexity: O(n);</output:></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nguyen Ngoc Hoang</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-12938</link>
		<dc:creator><![CDATA[Nguyen Ngoc Hoang]]></dc:creator>
		<pubDate>Wed, 28 Nov 2012 06:17:21 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-12938</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
// Step 2 and 3 get the sum of numbers and place them in
    // corresponding queues
    int i, sum;
    for ( i = 0, sum = 0; i &#060; size; ++i )
    {
        //sum += arr[i];
        if ( (arr[i] % 3) == 0 )
            Enqueue( queue0, arr[i] );
        else if ( (arr[i] % 3) == 1 ) {
            sum ++;
            Enqueue( queue1, arr[i] );
        }
        else{
            Enqueue( queue2, arr[i] );
            sum += 2;
        } 
    }
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<pre> <code language="C">
// Step 2 and 3 get the sum of numbers and place them in
    // corresponding queues
    int i, sum;
    for ( i = 0, sum = 0; i &lt; size; ++i )
    {
        //sum += arr[i];
        if ( (arr[i] % 3) == 0 )
            Enqueue( queue0, arr[i] );
        else if ( (arr[i] % 3) == 1 ) {
            sum ++;
            Enqueue( queue1, arr[i] );
        }
        else{
            Enqueue( queue2, arr[i] );
            sum += 2;
        } 
    }
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nguyen Ngoc Hoang</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-12936</link>
		<dc:creator><![CDATA[Nguyen Ngoc Hoang]]></dc:creator>
		<pubDate>Wed, 28 Nov 2012 06:05:13 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-12936</guid>
		<description><![CDATA[No need to calculate the sum, just calculate the number of elements n1 and n2 in queue 1 and 2. Then, sum = n1 + 2 * n2.   

&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
/* Paste your code here (You may delete these lines if not writing code) */
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>No need to calculate the sum, just calculate the number of elements n1 and n2 in queue 1 and 2. Then, sum = n1 + 2 * n2.   </p>
<pre> <code language="C">
/* Paste your code here (You may delete these lines if not writing code) */
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Aashish</title>
		<link>http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/#comment-11674</link>
		<dc:creator><![CDATA[Aashish]]></dc:creator>
		<pubDate>Sat, 13 Oct 2012 04:48:01 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24460#comment-11674</guid>
		<description><![CDATA[Without sorting, how can we ensure that the number so formed is the largest?
We need sorting at least once, either prior to applying algo or post to applying algo.]]></description>
		<content:encoded><![CDATA[<p>Without sorting, how can we ensure that the number so formed is the largest?<br />
We need sorting at least once, either prior to applying algo or post to applying algo.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:14:16 -->

<!-- Compression = gzip -->