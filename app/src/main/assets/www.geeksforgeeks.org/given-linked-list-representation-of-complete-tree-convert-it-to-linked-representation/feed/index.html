<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Construct Complete Binary Tree from its Linked List Representation</title>
	<atom:link href="http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: ms</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-38526</link>
		<dc:creator><![CDATA[ms]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 07:35:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-38526</guid>
		<description><![CDATA[Complexity O(n)]]></description>
		<content:encoded><![CDATA[<p>Complexity O(n)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ms</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-38525</link>
		<dc:creator><![CDATA[ms]]></dc:creator>
		<pubDate>Sat, 14 Jun 2014 07:33:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-38525</guid>
		<description><![CDATA[I guess this can be an alternate soln(Pls share ur views):
Take two pointers: root &#038; child.
root points two the first node of the list and child to the second node.
make child and child-&#062;next the left and right children of root
progress root by one and child by two nodes..

Base cases can be handled accordingly..]]></description>
		<content:encoded><![CDATA[<p>I guess this can be an alternate soln(Pls share ur views):<br />
Take two pointers: root &amp; child.<br />
root points two the first node of the list and child to the second node.<br />
make child and child-&gt;next the left and right children of root<br />
progress root by one and child by two nodes..</p>
<p>Base cases can be handled accordingly..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-38199</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 11:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-38199</guid>
		<description><![CDATA[nice trick :)]]></description>
		<content:encoded><![CDATA[<p>nice trick ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: samthebest</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-38085</link>
		<dc:creator><![CDATA[samthebest]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 10:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-38085</guid>
		<description><![CDATA[btnode * CBTfromLL(lnode *head)
{
    if(head==NULL)
    return NULL;
    
    queue q;
    
    btnode *root=new_node(head-&#062;data);
    lnode *ptr=head-&#062;next;
    btnode *current=root;
    q.push(root);
    while(ptr!=NULL)
    {    btnode *node=new_node(ptr-&#062;data);
        if(!current-&#062;lchild)
        {
            current-&#062;lchild=node;
        }
        else if(!current-&#062;rchild)
        {    current-&#062;rchild=node;
        }
        
        q.push(node);
        if(current-&#062;lchild &#038;&#038; current-&#062;rchild)
        {
            q.pop();
            current=q.front();
        }
        ptr=ptr-&#062;next;
    }
    
    return root;
}]]></description>
		<content:encoded><![CDATA[<p>btnode * CBTfromLL(lnode *head)<br />
{<br />
    if(head==NULL)<br />
    return NULL;</p>
<p>    queue q;</p>
<p>    btnode *root=new_node(head-&gt;data);<br />
    lnode *ptr=head-&gt;next;<br />
    btnode *current=root;<br />
    q.push(root);<br />
    while(ptr!=NULL)<br />
    {    btnode *node=new_node(ptr-&gt;data);<br />
        if(!current-&gt;lchild)<br />
        {<br />
            current-&gt;lchild=node;<br />
        }<br />
        else if(!current-&gt;rchild)<br />
        {    current-&gt;rchild=node;<br />
        }</p>
<p>        q.push(node);<br />
        if(current-&gt;lchild &amp;&amp; current-&gt;rchild)<br />
        {<br />
            q.pop();<br />
            current=q.front();<br />
        }<br />
        ptr=ptr-&gt;next;<br />
    }</p>
<p>    return root;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: prashant jha</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-36330</link>
		<dc:creator><![CDATA[prashant jha]]></dc:creator>
		<pubDate>Tue, 20 May 2014 12:11:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-36330</guid>
		<description><![CDATA[0(n^2) can be done by using recursion passing level and node values to the recursive function which recur at 2i+1 and 2i+2  and if its value is &#062;currrent index then return........
0(n) by using queue
create root and enqueue it 
while q.front!=-1
deque from front
check if its both child exist or not by checking 2i+1 and 2i+2 both &#060;n
if they exist form nodes and enqueue it else enque only lchild if 2i+2 &#060;n]]></description>
		<content:encoded><![CDATA[<p>0(n^2) can be done by using recursion passing level and node values to the recursive function which recur at 2i+1 and 2i+2  and if its value is &gt;currrent index then return&#8230;&#8230;..<br />
0(n) by using queue<br />
create root and enqueue it<br />
while q.front!=-1<br />
deque from front<br />
check if its both child exist or not by checking 2i+1 and 2i+2 both &lt;n<br />
if they exist form nodes and enqueue it else enque only lchild if 2i+2 &lt;n</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: monu</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-34904</link>
		<dc:creator><![CDATA[monu]]></dc:creator>
		<pubDate>Sun, 20 Apr 2014 06:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-34904</guid>
		<description><![CDATA[hi]]></description>
		<content:encoded><![CDATA[<p>hi</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sunil</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-33802</link>
		<dc:creator><![CDATA[sunil]]></dc:creator>
		<pubDate>Mon, 24 Mar 2014 15:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-33802</guid>
		<description><![CDATA[Another way would be to count the number of nodes &#062; send half the nodes to left and the other half to right(if odd number send the extra one to left)
recursively build the left subtree (termination condition would be when there are no more nodes) and right subtree (while building the tree keep sending the next node up the tree for building the right subtree).]]></description>
		<content:encoded><![CDATA[<p>Another way would be to count the number of nodes &gt; send half the nodes to left and the other half to right(if odd number send the extra one to left)<br />
recursively build the left subtree (termination condition would be when there are no more nodes) and right subtree (while building the tree keep sending the next node up the tree for building the right subtree).</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Dave</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-33296</link>
		<dc:creator><![CDATA[Dave]]></dc:creator>
		<pubDate>Sat, 08 Mar 2014 13:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-33296</guid>
		<description><![CDATA[Call me crazy but isn&#039;t a binary tree supposed to be sorted?]]></description>
		<content:encoded><![CDATA[<p>Call me crazy but isn&#8217;t a binary tree supposed to be sorted?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Monin Anicet Sia</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-26319</link>
		<dc:creator><![CDATA[Monin Anicet Sia]]></dc:creator>
		<pubDate>Sun, 18 Aug 2013 09:51:31 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-26319</guid>
		<description><![CDATA[tu est ou?]]></description>
		<content:encoded><![CDATA[<p>tu est ou?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Celeste Bah</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-26318</link>
		<dc:creator><![CDATA[Celeste Bah]]></dc:creator>
		<pubDate>Sat, 17 Aug 2013 10:20:55 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-26318</guid>
		<description><![CDATA[very strong man.]]></description>
		<content:encoded><![CDATA[<p>very strong man.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: SYED IMRAN</title>
		<link>http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/#comment-24817</link>
		<dc:creator><![CDATA[SYED IMRAN]]></dc:creator>
		<pubDate>Sun, 11 Aug 2013 05:53:43 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115958#comment-24817</guid>
		<description><![CDATA[#include
#include
#include
struct tnode
{
    int data;
    struct tnode *left,*right;
};
struct node
{
    int data;
    struct node *next;
};
typedef struct tnode tnode;
typedef struct node node;
node * head=NULL;
void push(node **h,int t)
{
    node * nw=(node *)malloc(sizeof(node));
    nw-&#062;data=t;
    nw-&#062;next=NULL;
    if(*h==NULL)
    {
        *h=nw;
    }
    else
    {
        nw-&#062;next=*h;
        *h=nw;
    }
}
tnode * newtnode(int n)
{
    tnode *nw=(tnode *)malloc(sizeof(tnode));
    nw-&#062;data=n;
    nw-&#062;left=nw-&#062;right=NULL;
    return nw;
}
int getlistnode(node *h,int i)
{
    node * s;
    s=h;
    while(i&#062;0)
    {
        s=s-&#062;next;
        i--;
    }
    return s-&#062;data;
}
tnode * createtree(int i,int size)
{
    if(i&#062;=size) return NULL;
    tnode * root=(tnode *)malloc(sizeof(tnode));
    root-&#062;left=createtree(2*i+1,size);
    root-&#062;right=createtree(2*i+2,size);
    root-&#062;data=getlistnode(head,i);
    return root;
}
void inorderTraversal(tnode * root)
{
    if (root)
    {
        inorderTraversal( root-&#062;left );
        printf(&quot;%d &quot;,root-&#062;data);
        inorderTraversal( root-&#062;right );
    }
}
int main()
{
    tnode * root=NULL;
    push(&#038;head, 36);  /* Last node of Linked List */
    push(&#038;head, 30);
    push(&#038;head, 25);
    push(&#038;head, 15);
    push(&#038;head, 12);
    push(&#038;head, 10);
    root=createtree(0,6);
    printf(&quot;inorder is:\n&quot;);
    inorderTraversal(root);

    return 0;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
#include<br />
struct tnode<br />
{<br />
    int data;<br />
    struct tnode *left,*right;<br />
};<br />
struct node<br />
{<br />
    int data;<br />
    struct node *next;<br />
};<br />
typedef struct tnode tnode;<br />
typedef struct node node;<br />
node * head=NULL;<br />
void push(node **h,int t)<br />
{<br />
    node * nw=(node *)malloc(sizeof(node));<br />
    nw-&gt;data=t;<br />
    nw-&gt;next=NULL;<br />
    if(*h==NULL)<br />
    {<br />
        *h=nw;<br />
    }<br />
    else<br />
    {<br />
        nw-&gt;next=*h;<br />
        *h=nw;<br />
    }<br />
}<br />
tnode * newtnode(int n)<br />
{<br />
    tnode *nw=(tnode *)malloc(sizeof(tnode));<br />
    nw-&gt;data=n;<br />
    nw-&gt;left=nw-&gt;right=NULL;<br />
    return nw;<br />
}<br />
int getlistnode(node *h,int i)<br />
{<br />
    node * s;<br />
    s=h;<br />
    while(i&gt;0)<br />
    {<br />
        s=s-&gt;next;<br />
        i&#8211;;<br />
    }<br />
    return s-&gt;data;<br />
}<br />
tnode * createtree(int i,int size)<br />
{<br />
    if(i&gt;=size) return NULL;<br />
    tnode * root=(tnode *)malloc(sizeof(tnode));<br />
    root-&gt;left=createtree(2*i+1,size);<br />
    root-&gt;right=createtree(2*i+2,size);<br />
    root-&gt;data=getlistnode(head,i);<br />
    return root;<br />
}<br />
void inorderTraversal(tnode * root)<br />
{<br />
    if (root)<br />
    {<br />
        inorderTraversal( root-&gt;left );<br />
        printf(&#8220;%d &#8220;,root-&gt;data);<br />
        inorderTraversal( root-&gt;right );<br />
    }<br />
}<br />
int main()<br />
{<br />
    tnode * root=NULL;<br />
    push(&amp;head, 36);  /* Last node of Linked List */<br />
    push(&amp;head, 30);<br />
    push(&amp;head, 25);<br />
    push(&amp;head, 15);<br />
    push(&amp;head, 12);<br />
    push(&amp;head, 10);<br />
    root=createtree(0,6);<br />
    printf(&#8220;inorder is:\n&#8221;);<br />
    inorderTraversal(root);</p>
<p>    return 0;<br />
}</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.041 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:16:36 -->

<!-- Compression = gzip -->