<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find a pair with given sum in a Balanced BST</title>
	<atom:link href="http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-38894</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 00:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-38894</guid>
		<description><![CDATA[http://stackoverflow.com/questions/12289949/find-two-numbers-from-bst-which-sum-to-given-number-k]]></description>
		<content:encoded><![CDATA[<p><a href="http://stackoverflow.com/questions/12289949/find-two-numbers-from-bst-which-sum-to-given-number-k" rel="nofollow">http://stackoverflow.com/questions/12289949/find-two-numbers-from-bst-which-sum-to-given-number-k</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amarnath Raju Vysyaraju</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-35752</link>
		<dc:creator><![CDATA[Amarnath Raju Vysyaraju]]></dc:creator>
		<pubDate>Wed, 07 May 2014 12:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-35752</guid>
		<description><![CDATA[@Admin

I think the isFull method given here is wrong. It must be :

int isFull(struct Stack* stack)

{   return stack-&#062;top + 1 == stack-&#062;size;  }]]></description>
		<content:encoded><![CDATA[<p>@Admin</p>
<p>I think the isFull method given here is wrong. It must be :</p>
<p>int isFull(struct Stack* stack)</p>
<p>{   return stack-&gt;top + 1 == stack-&gt;size;  }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AlienOnEarth</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-35230</link>
		<dc:creator><![CDATA[AlienOnEarth]]></dc:creator>
		<pubDate>Mon, 28 Apr 2014 10:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-35230</guid>
		<description><![CDATA[Another o(n) Approach. Same as finding pair sum in a sorted array. C source code is as below:

#include

#include

#include

bool isSumSet = false;

 

// Structure of a BST Node

struct node

{

    int data;

    struct node *left;

    struct node *right;

};

 

 int isPrinted = 0;

 

/* Utility function to create a new Binary Tree node */

struct node* newNode (int data)

{

    struct node *temp = (struct node*)malloc(sizeof(struct node));

    temp-&#062;data = data;

    temp-&#062;left = NULL;

    temp-&#062;right = NULL;

    return temp;

}

/* A utility function to print Inoder traversal of a Binary Tree */

void inorder(struct node *root)

{

    if (root != NULL)

    {

        inorder(root-&#062;left);

        printf(&quot;%d--&#062;&quot;, root-&#062;data);

        inorder(root-&#062;right);

    }

}

 

// The function to print data of two BSTs in sorted order

void  findSumPair(struct node *root1, struct node *root2, int *n1, int *n2,int sum)

{

    

    	// go to left most node

    	if(root1-&#062;left != NULL)

    		findSumPair(root1-&#062;left,root2,n1,n2,sum);

    	

    	// go to right most node

    	if(root2-&#062;right != NULL)

	    	findSumPair(root1,root2-&#062;right,n1,n2,sum);

    	

    	int tempSum = root1-&#062;data + root2-&#062;data;

    	

    	// processing

    	if(tempSum == sum)

    	{

    		printf(&quot;data: %d + %d&quot;,root1-&#062;data,root2-&#062;data);

    		isSumSet = true;

    	}	

    	else if(tempSum&#062;sum)

    	{

    		if(root2-&#062;left!=NULL &#038;&#038; isSumSet == false)

    		{

    			findSumPair(root1,root2-&#062;left,n1,n2,sum);	

    		}

    	}

    	else if(tempSumright!=NULL)

    		{

    			findSumPair(root1,root1-&#062;right,n1,n2,sum);	

    		}

    	}

}

int size(struct node* root)

{	

	if(root == NULL)

		return 0;

		

	return (1 + size(root-&#062;left) + size(root-&#062;right));

}

void BSTSumPair(struct node *root, int sum)

{

	int n1= size(root-&#062;left);

	int n2= size(root-&#062;right);

	findSumPair(root-&#062;left, root-&#062;right, &#038;n1, &#038;n2, sum);

}

 

/* Driver program to test above functions */

int main()

{

    struct node  *root = NULL;

 

    /* Let us create the following tree as first tree

            6

          /  

        3     8

          

            4

     */

    root = newNode(15);

    root-&#062;left = newNode(10);

    root-&#062;right = newNode(20);

    root-&#062;left-&#062;left = newNode(8);

    root-&#062;left-&#062;right = newNode(12);

    root-&#062;right-&#062;left = newNode(16);

    root-&#062;right-&#062;right = newNode(25);

 

    BSTSumPair(root,28);

 

    return 0;

}]]></description>
		<content:encoded><![CDATA[<p>Another o(n) Approach. Same as finding pair sum in a sorted array. C source code is as below:</p>
<p>#include</p>
<p>#include</p>
<p>#include</p>
<p>bool isSumSet = false;</p>
<p>// Structure of a BST Node</p>
<p>struct node</p>
<p>{</p>
<p>    int data;</p>
<p>    struct node *left;</p>
<p>    struct node *right;</p>
<p>};</p>
<p> int isPrinted = 0;</p>
<p>/* Utility function to create a new Binary Tree node */</p>
<p>struct node* newNode (int data)</p>
<p>{</p>
<p>    struct node *temp = (struct node*)malloc(sizeof(struct node));</p>
<p>    temp-&gt;data = data;</p>
<p>    temp-&gt;left = NULL;</p>
<p>    temp-&gt;right = NULL;</p>
<p>    return temp;</p>
<p>}</p>
<p>/* A utility function to print Inoder traversal of a Binary Tree */</p>
<p>void inorder(struct node *root)</p>
<p>{</p>
<p>    if (root != NULL)</p>
<p>    {</p>
<p>        inorder(root-&gt;left);</p>
<p>        printf(&#8220;%d&#8211;&gt;&#8221;, root-&gt;data);</p>
<p>        inorder(root-&gt;right);</p>
<p>    }</p>
<p>}</p>
<p>// The function to print data of two BSTs in sorted order</p>
<p>void  findSumPair(struct node *root1, struct node *root2, int *n1, int *n2,int sum)</p>
<p>{</p>
<p>    	// go to left most node</p>
<p>    	if(root1-&gt;left != NULL)</p>
<p>    		findSumPair(root1-&gt;left,root2,n1,n2,sum);</p>
<p>    	// go to right most node</p>
<p>    	if(root2-&gt;right != NULL)</p>
<p>	    	findSumPair(root1,root2-&gt;right,n1,n2,sum);</p>
<p>    	int tempSum = root1-&gt;data + root2-&gt;data;</p>
<p>    	// processing</p>
<p>    	if(tempSum == sum)</p>
<p>    	{</p>
<p>    		printf(&#8220;data: %d + %d&#8221;,root1-&gt;data,root2-&gt;data);</p>
<p>    		isSumSet = true;</p>
<p>    	}	</p>
<p>    	else if(tempSum&gt;sum)</p>
<p>    	{</p>
<p>    		if(root2-&gt;left!=NULL &amp;&amp; isSumSet == false)</p>
<p>    		{</p>
<p>    			findSumPair(root1,root2-&gt;left,n1,n2,sum);	</p>
<p>    		}</p>
<p>    	}</p>
<p>    	else if(tempSumright!=NULL)</p>
<p>    		{</p>
<p>    			findSumPair(root1,root1-&gt;right,n1,n2,sum);	</p>
<p>    		}</p>
<p>    	}</p>
<p>}</p>
<p>int size(struct node* root)</p>
<p>{	</p>
<p>	if(root == NULL)</p>
<p>		return 0;</p>
<p>	return (1 + size(root-&gt;left) + size(root-&gt;right));</p>
<p>}</p>
<p>void BSTSumPair(struct node *root, int sum)</p>
<p>{</p>
<p>	int n1= size(root-&gt;left);</p>
<p>	int n2= size(root-&gt;right);</p>
<p>	findSumPair(root-&gt;left, root-&gt;right, &amp;n1, &amp;n2, sum);</p>
<p>}</p>
<p>/* Driver program to test above functions */</p>
<p>int main()</p>
<p>{</p>
<p>    struct node  *root = NULL;</p>
<p>    /* Let us create the following tree as first tree</p>
<p>            6</p>
<p>          /  </p>
<p>        3     8</p>
<p>            4</p>
<p>     */</p>
<p>    root = newNode(15);</p>
<p>    root-&gt;left = newNode(10);</p>
<p>    root-&gt;right = newNode(20);</p>
<p>    root-&gt;left-&gt;left = newNode(8);</p>
<p>    root-&gt;left-&gt;right = newNode(12);</p>
<p>    root-&gt;right-&gt;left = newNode(16);</p>
<p>    root-&gt;right-&gt;right = newNode(25);</p>
<p>    BSTSumPair(root,28);</p>
<p>    return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Lohith Ravi</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-35201</link>
		<dc:creator><![CDATA[Lohith Ravi]]></dc:creator>
		<pubDate>Sun, 27 Apr 2014 18:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-35201</guid>
		<description><![CDATA[I have done a Iterative method or processing InOrder and reverseInOrder

http://ideone.com/p33W9c]]></description>
		<content:encoded><![CDATA[<p>I have done a Iterative method or processing InOrder and reverseInOrder</p>
<p><a href="http://ideone.com/p33W9c" rel="nofollow">http://ideone.com/p33W9c</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sukisukimo</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-33615</link>
		<dc:creator><![CDATA[sukisukimo]]></dc:creator>
		<pubDate>Mon, 17 Mar 2014 18:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-33615</guid>
		<description><![CDATA[/*

* Modified version of the above algorithm, where is the pair resides on the left/right subtree from the root

*/

boolean findPairOfSumBestSol(BinaryNode head, int sum)

	{

		int leftVal = 0, rightVal = 0;

		BinaryNode left = head;

		BinaryNode right = head.right;

		boolean isLeft, isRight, still;

		isLeft = isRight = still = true;

		Stack sl = new Stack(10);

		Stack sr = new Stack(10);

		while (still)

		{

			while (isLeft)

			{

				if (left != null)

				{

					sl.pushNode(left);

					left = left.left;

				}

				else

				{

					if (sl.isEmpty())

					{

						isLeft = false;

						left = head.right;

					}

					else

					{

						isLeft = false;

						left = sl.popNode();

						leftVal = left.key;

						left = left.right;

					}

				}

			}

			while (isRight)

			{

				if (right != null)

				{

					sr.pushNode(right);

					right = right.right;

				}

				else

				{

					if (sr.isEmpty())

					{

						isRight = false;

						right = head.left;

					}

					else

					{

						isRight = false;

						right = sr.popNode();

						rightVal = right.key;

						right = right.left;

					}

				}

			}

			if (leftVal != rightVal &#038;&#038; leftVal + rightVal == sum)

			{

				System.out.println(&quot;Pairs are :&quot; + leftVal + &quot; and &quot; + rightVal);

				still = false;

				return true;

			}

			else if (leftVal == rightVal)

				still = false;

			else if (leftVal + rightVal  sum)

				isRight = true;

				

		}

		return false;

	}

/*

* test from main methiod

*/

	public static void main(String[] args)

	{

		BinaryNode b30 = new BinaryNode(30);

		BinaryNode b20 = new BinaryNode(20);

		BinaryNode b40 = new BinaryNode(40);

		BinaryNode b15 = new BinaryNode(15);

		BinaryNode b25 = new BinaryNode(25);

		BinaryNode b35 = new BinaryNode(35);

		BinaryNode b45 = new BinaryNode(45);

		BinaryNode b13 = new BinaryNode(13);

		BinaryNode b17 = new BinaryNode(17);

		BinaryNode b18 = new BinaryNode(18);

		BinaryNode b19 = new BinaryNode(19);

		BinaryNode b43 = new BinaryNode(43);

		BinaryNode b46 = new BinaryNode(46);

		b30.left = b20;

		b30.right = b40;

		b20.left = b15;

		b20.right = b25;

		b40.left = b35;

		b40.right = b45;

		b15.left = b13;

		b15.right = b17;

		b17.right = b18;

		b18.right = b19;

		b45.left = b43;

		b45.right = b46;

		System.out.println(findPairOfSumBestSol(b30, 38));

	}]]></description>
		<content:encoded><![CDATA[<p>/*</p>
<p>* Modified version of the above algorithm, where is the pair resides on the left/right subtree from the root</p>
<p>*/</p>
<p>boolean findPairOfSumBestSol(BinaryNode head, int sum)</p>
<p>	{</p>
<p>		int leftVal = 0, rightVal = 0;</p>
<p>		BinaryNode left = head;</p>
<p>		BinaryNode right = head.right;</p>
<p>		boolean isLeft, isRight, still;</p>
<p>		isLeft = isRight = still = true;</p>
<p>		Stack sl = new Stack(10);</p>
<p>		Stack sr = new Stack(10);</p>
<p>		while (still)</p>
<p>		{</p>
<p>			while (isLeft)</p>
<p>			{</p>
<p>				if (left != null)</p>
<p>				{</p>
<p>					sl.pushNode(left);</p>
<p>					left = left.left;</p>
<p>				}</p>
<p>				else</p>
<p>				{</p>
<p>					if (sl.isEmpty())</p>
<p>					{</p>
<p>						isLeft = false;</p>
<p>						left = head.right;</p>
<p>					}</p>
<p>					else</p>
<p>					{</p>
<p>						isLeft = false;</p>
<p>						left = sl.popNode();</p>
<p>						leftVal = left.key;</p>
<p>						left = left.right;</p>
<p>					}</p>
<p>				}</p>
<p>			}</p>
<p>			while (isRight)</p>
<p>			{</p>
<p>				if (right != null)</p>
<p>				{</p>
<p>					sr.pushNode(right);</p>
<p>					right = right.right;</p>
<p>				}</p>
<p>				else</p>
<p>				{</p>
<p>					if (sr.isEmpty())</p>
<p>					{</p>
<p>						isRight = false;</p>
<p>						right = head.left;</p>
<p>					}</p>
<p>					else</p>
<p>					{</p>
<p>						isRight = false;</p>
<p>						right = sr.popNode();</p>
<p>						rightVal = right.key;</p>
<p>						right = right.left;</p>
<p>					}</p>
<p>				}</p>
<p>			}</p>
<p>			if (leftVal != rightVal &amp;&amp; leftVal + rightVal == sum)</p>
<p>			{</p>
<p>				System.out.println(&#8220;Pairs are :&#8221; + leftVal + &#8221; and &#8221; + rightVal);</p>
<p>				still = false;</p>
<p>				return true;</p>
<p>			}</p>
<p>			else if (leftVal == rightVal)</p>
<p>				still = false;</p>
<p>			else if (leftVal + rightVal  sum)</p>
<p>				isRight = true;</p>
<p>		}</p>
<p>		return false;</p>
<p>	}</p>
<p>/*</p>
<p>* test from main methiod</p>
<p>*/</p>
<p>	public static void main(String[] args)</p>
<p>	{</p>
<p>		BinaryNode b30 = new BinaryNode(30);</p>
<p>		BinaryNode b20 = new BinaryNode(20);</p>
<p>		BinaryNode b40 = new BinaryNode(40);</p>
<p>		BinaryNode b15 = new BinaryNode(15);</p>
<p>		BinaryNode b25 = new BinaryNode(25);</p>
<p>		BinaryNode b35 = new BinaryNode(35);</p>
<p>		BinaryNode b45 = new BinaryNode(45);</p>
<p>		BinaryNode b13 = new BinaryNode(13);</p>
<p>		BinaryNode b17 = new BinaryNode(17);</p>
<p>		BinaryNode b18 = new BinaryNode(18);</p>
<p>		BinaryNode b19 = new BinaryNode(19);</p>
<p>		BinaryNode b43 = new BinaryNode(43);</p>
<p>		BinaryNode b46 = new BinaryNode(46);</p>
<p>		b30.left = b20;</p>
<p>		b30.right = b40;</p>
<p>		b20.left = b15;</p>
<p>		b20.right = b25;</p>
<p>		b40.left = b35;</p>
<p>		b40.right = b45;</p>
<p>		b15.left = b13;</p>
<p>		b15.right = b17;</p>
<p>		b17.right = b18;</p>
<p>		b18.right = b19;</p>
<p>		b45.left = b43;</p>
<p>		b45.right = b46;</p>
<p>		System.out.println(findPairOfSumBestSol(b30, 38));</p>
<p>	}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: sukisukimo</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-33614</link>
		<dc:creator><![CDATA[sukisukimo]]></dc:creator>
		<pubDate>Mon, 17 Mar 2014 18:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-33614</guid>
		<description><![CDATA[This algorithm will not work if the pair are in the left subtree(or right subtree) from the root eg sum=18, sum=20]]></description>
		<content:encoded><![CDATA[<p>This algorithm will not work if the pair are in the left subtree(or right subtree) from the root eg sum=18, sum=20</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: OP Coder</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-32063</link>
		<dc:creator><![CDATA[OP Coder]]></dc:creator>
		<pubDate>Sat, 01 Feb 2014 18:01:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-32063</guid>
		<description><![CDATA[In today&#039;s world, space is not a problem, but speed is. So always try to optimize it.]]></description>
		<content:encoded><![CDATA[<p>In today&#8217;s world, space is not a problem, but speed is. So always try to optimize it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sumit Monga</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-31769</link>
		<dc:creator><![CDATA[Sumit Monga]]></dc:creator>
		<pubDate>Thu, 23 Jan 2014 18:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-31769</guid>
		<description><![CDATA[height of tree is always 0(logn) as it is a balanced bst so maximum depth of stack is 0(logn) as on pushing elements we go from one level to another. hope its clear now]]></description>
		<content:encoded><![CDATA[<p>height of tree is always 0(logn) as it is a balanced bst so maximum depth of stack is 0(logn) as on pushing elements we go from one level to another. hope its clear now</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jayanth</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-31765</link>
		<dc:creator><![CDATA[Jayanth]]></dc:creator>
		<pubDate>Thu, 23 Jan 2014 16:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-31765</guid>
		<description><![CDATA[Can someone explain how is the space O(logn)..??
Isnt it O(n)...???]]></description>
		<content:encoded><![CDATA[<p>Can someone explain how is the space O(logn)..??<br />
Isnt it O(n)&#8230;???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jayanth</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-31766</link>
		<dc:creator><![CDATA[Jayanth]]></dc:creator>
		<pubDate>Thu, 23 Jan 2014 16:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-31766</guid>
		<description><![CDATA[Can someone explain how is the space O(logn)..??

Isnt it O(n)...??]]></description>
		<content:encoded><![CDATA[<p>Can someone explain how is the space O(logn)..??</p>
<p>Isnt it O(n)&#8230;??</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Newgeek</title>
		<link>http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/#comment-31270</link>
		<dc:creator><![CDATA[Newgeek]]></dc:creator>
		<pubDate>Sun, 05 Jan 2014 08:05:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=115599#comment-31270</guid>
		<description><![CDATA[i think we can have a O(nlogn) solution for this without any space.


Since it is a BST, for each node we can search for (k - node-&#062;data) in the tree in O(logn) time.]]></description>
		<content:encoded><![CDATA[<p>i think we can have a O(nlogn) solution for this without any space.</p>
<p>Since it is a BST, for each node we can search for (k &#8211; node-&gt;data) in the tree in O(logn) time.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.047 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:06:46 -->

<!-- Compression = gzip -->