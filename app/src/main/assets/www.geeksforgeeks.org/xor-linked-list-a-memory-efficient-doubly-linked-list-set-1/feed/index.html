<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: XOR Linked List &#8211; A Memory Efficient Doubly Linked List  &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: typing..</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-37074</link>
		<dc:creator><![CDATA[typing..]]></dc:creator>
		<pubDate>Fri, 30 May 2014 14:46:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-37074</guid>
		<description><![CDATA[innovation is here!!!!!!]]></description>
		<content:encoded><![CDATA[<p>innovation is here!!!!!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: code1234</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-21063</link>
		<dc:creator><![CDATA[code1234]]></dc:creator>
		<pubDate>Tue, 02 Jul 2013 14:37:14 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-21063</guid>
		<description><![CDATA[Works very well! Great, thanks! :)]]></description>
		<content:encoded><![CDATA[<p>Works very well! Great, thanks! ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: devil</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-20729</link>
		<dc:creator><![CDATA[devil]]></dc:creator>
		<pubDate>Thu, 27 Jun 2013 11:20:20 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-20729</guid>
		<description><![CDATA[http://cocoadev.com/wiki/DesignDoublyXORLinkedList Some explanation. Just incorporate this in your LL implementation.]]></description>
		<content:encoded><![CDATA[<p><a href="http://cocoadev.com/wiki/DesignDoublyXORLinkedList" rel="nofollow">http://cocoadev.com/wiki/DesignDoublyXORLinkedList</a> Some explanation. Just incorporate this in your LL implementation.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: devil</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-20727</link>
		<dc:creator><![CDATA[devil]]></dc:creator>
		<pubDate>Thu, 27 Jun 2013 11:16:06 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-20727</guid>
		<description><![CDATA[Don&#039;t worry. I am going to try and come up with it here. Hold on..]]></description>
		<content:encoded><![CDATA[<p>Don&#8217;t worry. I am going to try and come up with it here. Hold on..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: devil</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-20726</link>
		<dc:creator><![CDATA[devil]]></dc:creator>
		<pubDate>Thu, 27 Jun 2013 11:15:15 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-20726</guid>
		<description><![CDATA[Good havens, does anyone ever code in Java here. !crying]]></description>
		<content:encoded><![CDATA[<p>Good havens, does anyone ever code in Java here. !crying</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: subhin</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-20036</link>
		<dc:creator><![CDATA[subhin]]></dc:creator>
		<pubDate>Tue, 18 Jun 2013 19:06:03 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-20036</guid>
		<description><![CDATA[Can any one publish java code of above program]]></description>
		<content:encoded><![CDATA[<p>Can any one publish java code of above program</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Atul</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-8175</link>
		<dc:creator><![CDATA[Atul]]></dc:creator>
		<pubDate>Sat, 21 Apr 2012 13:15:20 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-8175</guid>
		<description><![CDATA[Somehow I didn&#039;t like the &quot;node* next&quot; in the given source code. Since it is the distance between the locations, why can&#039;t it be a simple number? Hence I implemented following.


&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;
#include &#060;stdio.h&#062;
#include &#060;stdlib.h&#062;

typedef struct node
{
  int val;
  unsigned int pnx;  /* prev, next ptr XOR&#039;ed value */
} NODE;
NODE *head, *tail;

/* returns XORed value of the node addresses */
unsigned int XOR (NODE *a, NODE *b)
{
  return (unsigned int) ((unsigned int) (a) ^ (unsigned int) (b));
}

/*
 * When we add a new node, if it is a first node, pnx value is 0.
 * Interesting observations:
 * In case of first node, pnx value is always the address of next node.
 * In case of last node, pnx value is always the address of last-but-one node.
 */

NODE *add_node (int val)
{
  NODE *tmpNode = (NODE *) malloc (sizeof (NODE));
  tmpNode-&#062;val = val;

  /*
   * Now we have this node, we can update previous node&#039;s pnx value.
   *
   * If this is the first node, then ignore this step, as there is nothing
   * which we want to update.
   *
   * If this is not a first node, we have a previous node indeed, which is
   * pointed by the &#034;tail&#034; pointer. So update the pnx value of previous
   * node.
   */
  if (tail)
    tail-&#062;pnx = XOR ((NODE *) tail-&#062;pnx, tmpNode);

  /*
   * set pnx value of this node. We have a previous node, however the
   * next node will always be 0 (as we always insert a new node at end).
   * So as long as this node is the last node, pnx value will always be
   * the address of last node!
   */
  tmpNode-&#062;pnx = XOR (tail, (NODE *) 0);
  tail = tmpNode;

  if (tail) printf (&#034;prev pnx = %x  &#034;, tail-&#062;pnx);
  printf (&#034;this: %p node %d: pnx = %x\n&#034;, tmpNode, tmpNode-&#062;val, tmpNode-&#062;pnx);
  return (tmpNode);
}

void print_list (NODE *n)
{
  NODE *cur = n;
  NODE *prev = NULL;
  NODE *next;

  while (cur)
  {
    printf (&#034;this = %p data = %d. pnx = %x\n&#034;, cur, cur-&#062;val, cur-&#062;pnx);
    next = (NODE *) XOR (prev, (NODE *) cur-&#062;pnx);
    prev = cur;
    cur = next;
  }
}

int main (void)
{
  head = tail = 0;
  head = add_node (10);
  add_node (20);
  add_node (30);
  add_node (40);

  printf (&#034;\n\n&#034;);
  print_list (head);
  printf (&#034;\n\n&#034;);
  print_list (tail);
  return (0);
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Somehow I didn&#8217;t like the &#8220;node* next&#8221; in the given source code. Since it is the distance between the locations, why can&#8217;t it be a simple number? Hence I implemented following.</p>
<pre> <code language="C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct node
{
  int val;
  unsigned int pnx;  /* prev, next ptr XOR'ed value */
} NODE;
NODE *head, *tail;

/* returns XORed value of the node addresses */
unsigned int XOR (NODE *a, NODE *b)
{
  return (unsigned int) ((unsigned int) (a) ^ (unsigned int) (b));
}

/*
 * When we add a new node, if it is a first node, pnx value is 0.
 * Interesting observations:
 * In case of first node, pnx value is always the address of next node.
 * In case of last node, pnx value is always the address of last-but-one node.
 */

NODE *add_node (int val)
{
  NODE *tmpNode = (NODE *) malloc (sizeof (NODE));
  tmpNode-&gt;val = val;

  /*
   * Now we have this node, we can update previous node's pnx value.
   *
   * If this is the first node, then ignore this step, as there is nothing
   * which we want to update.
   *
   * If this is not a first node, we have a previous node indeed, which is
   * pointed by the &quot;tail&quot; pointer. So update the pnx value of previous
   * node.
   */
  if (tail)
    tail-&gt;pnx = XOR ((NODE *) tail-&gt;pnx, tmpNode);

  /*
   * set pnx value of this node. We have a previous node, however the
   * next node will always be 0 (as we always insert a new node at end).
   * So as long as this node is the last node, pnx value will always be
   * the address of last node!
   */
  tmpNode-&gt;pnx = XOR (tail, (NODE *) 0);
  tail = tmpNode;

  if (tail) printf (&quot;prev pnx = %x  &quot;, tail-&gt;pnx);
  printf (&quot;this: %p node %d: pnx = %x\n&quot;, tmpNode, tmpNode-&gt;val, tmpNode-&gt;pnx);
  return (tmpNode);
}

void print_list (NODE *n)
{
  NODE *cur = n;
  NODE *prev = NULL;
  NODE *next;

  while (cur)
  {
    printf (&quot;this = %p data = %d. pnx = %x\n&quot;, cur, cur-&gt;val, cur-&gt;pnx);
    next = (NODE *) XOR (prev, (NODE *) cur-&gt;pnx);
    prev = cur;
    cur = next;
  }
}

int main (void)
{
  head = tail = 0;
  head = add_node (10);
  add_node (20);
  add_node (30);
  add_node (40);

  printf (&quot;\n\n&quot;);
  print_list (head);
  printf (&quot;\n\n&quot;);
  print_list (tail);
  return (0);
}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sudha</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-7720</link>
		<dc:creator><![CDATA[Sudha]]></dc:creator>
		<pubDate>Fri, 02 Mar 2012 05:09:46 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-7720</guid>
		<description><![CDATA[// Insertion, Deletion and Both direction traversal.

#include
#include

struct node 
{
	int num;
	struct node *ptrdiff;
};

void insert(struct node**,struct node**,struct node*,struct node*);
void displayForward(struct node*,struct node*);
void displayBackward(struct node*,struct node*);
struct node* newnode(int);
struct node *XOR(struct node *, struct node *);
void delete_node(struct node **,struct node **,int);

int main()
{
	struct node *head,*prev,*tail;

	head=prev=tail=NULL;

	insert(&#038;head,&#038;tail,prev,newnode(23));
	insert(&#038;head,&#038;tail,prev,newnode(13));
	insert(&#038;head,&#038;tail,prev,newnode(33));
	insert(&#038;head,&#038;tail,prev,newnode(32));
	insert(&#038;head,&#038;tail,prev,newnode(3));
	insert(&#038;head,&#038;tail,prev,newnode(73));
	insert(&#038;head,&#038;tail,prev,newnode(53));
	insert(&#038;head,&#038;tail,prev,newnode(63));
	insert(&#038;head,&#038;tail,prev,newnode(2));
	insert(&#038;head,&#038;tail,prev,newnode(12));
	
	printf(&quot;\nFoward Traversal\n&quot;);
	
	prev=NULL;
	displayForward(head,prev);

	printf(&quot;\nBackward Traversal\n&quot;);
	
	prev=NULL;
	displayBackward(tail,prev);

	delete_node(&#038;head,&#038;tail,2);
	printf(&quot;\nForward Traversal after Deletion\n&quot;);
	
	prev=NULL;
	displayForward(head,prev);

	printf(&quot;\nBackward Traversal after Deletion\n&quot;);
	
	prev=NULL;
	displayForward(tail,prev);

	return 0;
}

struct node* newnode(int value)
{
	struct node *np;
	np=(struct node*)malloc(sizeof(struct node));
	np-&#062;num=value;
	np-&#062;ptrdiff=NULL;

	return np;
}

void insert(struct node **head,struct node **tail,struct node *prev,struct node *np)
{
	struct node *current=*head,*prev_prev,*temp,*next;
	if(*head==NULL)
	{
		np-&#062;ptrdiff=XOR(prev,NULL);
		*head=np;
		*tail=np;
	}
	else
	{
		if((*head)-&#062;num &#062; np-&#062;num)
		{
			next=XOR((*head)-&#062;ptrdiff,prev);
			if(next==NULL)
				*tail=*head;
			(*head)-&#062;ptrdiff=XOR(np,next);
			np-&#062;ptrdiff=XOR(NULL,(*head));
			*head=np;
		}
		else
		{	
			while(current!=NULL &#038;&#038; current-&#062;num num)
			{
				temp=current;
				current=XOR(current-&#062;ptrdiff,prev);
				prev=temp;
			}
			if(current==NULL)
			{
				prev_prev=XOR(prev-&#062;ptrdiff,current);
				prev-&#062;ptrdiff=XOR(prev_prev,np);
				np-&#062;ptrdiff=XOR(prev,NULL);
				*tail=np;
			}
			else
			{
				prev_prev=XOR(prev-&#062;ptrdiff,current);
				next=XOR(prev,current-&#062;ptrdiff);
				prev-&#062;ptrdiff=XOR(prev_prev,np);
				np-&#062;ptrdiff=XOR(prev,current);
				current-&#062;ptrdiff=XOR(np,next);
			}
		}
	}
}

void delete_node(struct node **start,struct node **end,int value)
{
	struct node *current,*temp,*temp_next,*prev,*prev_prev,*cur_next_next;
	current=*start;
	prev=NULL;

	if(*start==NULL)
	{
		printf(&quot;Deletion is not allowed.Becoz, list is Empty&quot;);
		return;
	}
	 
	if((*start)-&#062;num == value)
	{
		temp=XOR((*start)-&#062;ptrdiff,NULL);
		if(temp==NULL)
		{
			printf(&quot;\nThe only node has been deleted. Thus the list is empty&quot;);
			free((*start));
			*start=*end=NULL;
		}
		else
		{
			temp_next=XOR(*start,temp-&#062;ptrdiff);
			free((*start));
			*start=temp;
			(*start)-&#062;ptrdiff=XOR(temp_next,NULL);
		}
		return;
	}
	else
	{
		while(current!=NULL &#038;&#038; current-&#062;num != value)
		{
			temp=current;
			current=XOR(current-&#062;ptrdiff,prev);
			prev=temp;
		}
		if(current==NULL)
		{
			printf(&quot;Sorry! node with %d value is not there in the list&quot;,value);
			return;
		}
		else
		{
			temp_next=XOR(current-&#062;ptrdiff,prev);
			prev_prev=XOR(prev-&#062;ptrdiff,current);
			if(temp_next==NULL)
			{
				prev-&#062;ptrdiff=XOR(prev_prev,NULL);
				*end=prev;
			}	
			else
			{
				cur_next_next=XOR(temp_next-&#062;ptrdiff,current);
				prev-&#062;ptrdiff=XOR(prev_prev,temp_next);
				temp_next-&#062;ptrdiff=XOR(prev,cur_next_next);
			}

		}
	}
}

void displayForward(struct node *start, struct node *prev)
{
  if(start == NULL) return;
 
  printf(&quot;%d\t&quot;,start-&#062;num);
  displayForward( XOR(start-&#062;ptrdiff, prev), start);
}

void displayBackward(struct node *end, struct node *prev)
{
  if(end == NULL) return;
 
  printf(&quot;%d\t&quot;,end-&#062;num);
  displayBackward( XOR(end-&#062;ptrdiff, prev), end);
}

struct node *XOR(struct node *a, struct node *b)
{
	return (struct node *)((long long)(a)^(long long)(b));
}]]></description>
		<content:encoded><![CDATA[<p>// Insertion, Deletion and Both direction traversal.</p>
<p>#include<br />
#include</p>
<p>struct node<br />
{<br />
	int num;<br />
	struct node *ptrdiff;<br />
};</p>
<p>void insert(struct node**,struct node**,struct node*,struct node*);<br />
void displayForward(struct node*,struct node*);<br />
void displayBackward(struct node*,struct node*);<br />
struct node* newnode(int);<br />
struct node *XOR(struct node *, struct node *);<br />
void delete_node(struct node **,struct node **,int);</p>
<p>int main()<br />
{<br />
	struct node *head,*prev,*tail;</p>
<p>	head=prev=tail=NULL;</p>
<p>	insert(&amp;head,&amp;tail,prev,newnode(23));<br />
	insert(&amp;head,&amp;tail,prev,newnode(13));<br />
	insert(&amp;head,&amp;tail,prev,newnode(33));<br />
	insert(&amp;head,&amp;tail,prev,newnode(32));<br />
	insert(&amp;head,&amp;tail,prev,newnode(3));<br />
	insert(&amp;head,&amp;tail,prev,newnode(73));<br />
	insert(&amp;head,&amp;tail,prev,newnode(53));<br />
	insert(&amp;head,&amp;tail,prev,newnode(63));<br />
	insert(&amp;head,&amp;tail,prev,newnode(2));<br />
	insert(&amp;head,&amp;tail,prev,newnode(12));</p>
<p>	printf(&#8220;\nFoward Traversal\n&#8221;);</p>
<p>	prev=NULL;<br />
	displayForward(head,prev);</p>
<p>	printf(&#8220;\nBackward Traversal\n&#8221;);</p>
<p>	prev=NULL;<br />
	displayBackward(tail,prev);</p>
<p>	delete_node(&amp;head,&amp;tail,2);<br />
	printf(&#8220;\nForward Traversal after Deletion\n&#8221;);</p>
<p>	prev=NULL;<br />
	displayForward(head,prev);</p>
<p>	printf(&#8220;\nBackward Traversal after Deletion\n&#8221;);</p>
<p>	prev=NULL;<br />
	displayForward(tail,prev);</p>
<p>	return 0;<br />
}</p>
<p>struct node* newnode(int value)<br />
{<br />
	struct node *np;<br />
	np=(struct node*)malloc(sizeof(struct node));<br />
	np-&gt;num=value;<br />
	np-&gt;ptrdiff=NULL;</p>
<p>	return np;<br />
}</p>
<p>void insert(struct node **head,struct node **tail,struct node *prev,struct node *np)<br />
{<br />
	struct node *current=*head,*prev_prev,*temp,*next;<br />
	if(*head==NULL)<br />
	{<br />
		np-&gt;ptrdiff=XOR(prev,NULL);<br />
		*head=np;<br />
		*tail=np;<br />
	}<br />
	else<br />
	{<br />
		if((*head)-&gt;num &gt; np-&gt;num)<br />
		{<br />
			next=XOR((*head)-&gt;ptrdiff,prev);<br />
			if(next==NULL)<br />
				*tail=*head;<br />
			(*head)-&gt;ptrdiff=XOR(np,next);<br />
			np-&gt;ptrdiff=XOR(NULL,(*head));<br />
			*head=np;<br />
		}<br />
		else<br />
		{<br />
			while(current!=NULL &amp;&amp; current-&gt;num num)<br />
			{<br />
				temp=current;<br />
				current=XOR(current-&gt;ptrdiff,prev);<br />
				prev=temp;<br />
			}<br />
			if(current==NULL)<br />
			{<br />
				prev_prev=XOR(prev-&gt;ptrdiff,current);<br />
				prev-&gt;ptrdiff=XOR(prev_prev,np);<br />
				np-&gt;ptrdiff=XOR(prev,NULL);<br />
				*tail=np;<br />
			}<br />
			else<br />
			{<br />
				prev_prev=XOR(prev-&gt;ptrdiff,current);<br />
				next=XOR(prev,current-&gt;ptrdiff);<br />
				prev-&gt;ptrdiff=XOR(prev_prev,np);<br />
				np-&gt;ptrdiff=XOR(prev,current);<br />
				current-&gt;ptrdiff=XOR(np,next);<br />
			}<br />
		}<br />
	}<br />
}</p>
<p>void delete_node(struct node **start,struct node **end,int value)<br />
{<br />
	struct node *current,*temp,*temp_next,*prev,*prev_prev,*cur_next_next;<br />
	current=*start;<br />
	prev=NULL;</p>
<p>	if(*start==NULL)<br />
	{<br />
		printf(&#8220;Deletion is not allowed.Becoz, list is Empty&#8221;);<br />
		return;<br />
	}</p>
<p>	if((*start)-&gt;num == value)<br />
	{<br />
		temp=XOR((*start)-&gt;ptrdiff,NULL);<br />
		if(temp==NULL)<br />
		{<br />
			printf(&#8220;\nThe only node has been deleted. Thus the list is empty&#8221;);<br />
			free((*start));<br />
			*start=*end=NULL;<br />
		}<br />
		else<br />
		{<br />
			temp_next=XOR(*start,temp-&gt;ptrdiff);<br />
			free((*start));<br />
			*start=temp;<br />
			(*start)-&gt;ptrdiff=XOR(temp_next,NULL);<br />
		}<br />
		return;<br />
	}<br />
	else<br />
	{<br />
		while(current!=NULL &amp;&amp; current-&gt;num != value)<br />
		{<br />
			temp=current;<br />
			current=XOR(current-&gt;ptrdiff,prev);<br />
			prev=temp;<br />
		}<br />
		if(current==NULL)<br />
		{<br />
			printf(&#8220;Sorry! node with %d value is not there in the list&#8221;,value);<br />
			return;<br />
		}<br />
		else<br />
		{<br />
			temp_next=XOR(current-&gt;ptrdiff,prev);<br />
			prev_prev=XOR(prev-&gt;ptrdiff,current);<br />
			if(temp_next==NULL)<br />
			{<br />
				prev-&gt;ptrdiff=XOR(prev_prev,NULL);<br />
				*end=prev;<br />
			}<br />
			else<br />
			{<br />
				cur_next_next=XOR(temp_next-&gt;ptrdiff,current);<br />
				prev-&gt;ptrdiff=XOR(prev_prev,temp_next);<br />
				temp_next-&gt;ptrdiff=XOR(prev,cur_next_next);<br />
			}</p>
<p>		}<br />
	}<br />
}</p>
<p>void displayForward(struct node *start, struct node *prev)<br />
{<br />
  if(start == NULL) return;</p>
<p>  printf(&#8220;%d\t&#8221;,start-&gt;num);<br />
  displayForward( XOR(start-&gt;ptrdiff, prev), start);<br />
}</p>
<p>void displayBackward(struct node *end, struct node *prev)<br />
{<br />
  if(end == NULL) return;</p>
<p>  printf(&#8220;%d\t&#8221;,end-&gt;num);<br />
  displayBackward( XOR(end-&gt;ptrdiff, prev), end);<br />
}</p>
<p>struct node *XOR(struct node *a, struct node *b)<br />
{<br />
	return (struct node *)((long long)(a)^(long long)(b));<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: raj</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-6327</link>
		<dc:creator><![CDATA[raj]]></dc:creator>
		<pubDate>Mon, 31 Oct 2011 17:33:35 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-6327</guid>
		<description><![CDATA[&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;&lt;/code&gt; &lt;/pre&gt;
/* */
[#include
#include
typedef struct node
{
	int data;
	struct node *npx;
}node;
void createlist(node **p)
{
	node *prev=NULL,*next,*current;
	int i,j,n,x;
	current=*p;
	while(1)
	{
		printf(&quot;\nWant to add a node then give 1 else 0 : &quot;);
		scanf(&quot;%d&quot;,&#038;n);
		if(n!=1)
		{
			if(current==NULL)
			{
				current=malloc(sizeof(node));
				printf(&quot;\nGive node : &quot;);
				scanf(&quot;%d&quot;,&#038;current-&#062;data);
				current-&#062;npx=NULL;
				*p=current;
			}
			else
			{
				next=malloc(sizeof(node));
				printf(&quot;\nGive node : &quot;);
				scanf(&quot;%d&quot;,&#038;next-&#062;data);
				next-&#062;npx=NULL;			
				//(node *)((long long)(a)^(long long)(b))	
				current-&#062;npx=(node *)((long long)(prev)^(long long)(next));
				prev=current;
				current=next;
			}
		}
		else
			break;
	}
	
}
void print(node *p)
{
	node *prev,*current;
	prev=NULL;
	current=p;
	printf(&quot;\nLinked list is : &quot;);
	while(p!=NULL)
	{
		printf(&quot;%d\t&quot;,p-&#062;data);
		p=(node *)((long long)(prev)^(long long)(current-&#062;npx));
		prev=current;
		current=p;
		if(prev-&#062;npx==NULL)
			break;
	}
	printf(&quot;\n&quot;);
}
main()
{
	node *head=NULL;
	createlist(&#038;head);
	print(head);
}
]]]></description>
		<content:encoded><![CDATA[<pre> <code language="C"></code> </pre>
<p>/* */<br />
[#include<br />
#include<br />
typedef struct node<br />
{<br />
	int data;<br />
	struct node *npx;<br />
}node;<br />
void createlist(node **p)<br />
{<br />
	node *prev=NULL,*next,*current;<br />
	int i,j,n,x;<br />
	current=*p;<br />
	while(1)<br />
	{<br />
		printf(&#8220;\nWant to add a node then give 1 else 0 : &#8220;);<br />
		scanf(&#8220;%d&#8221;,&amp;n);<br />
		if(n!=1)<br />
		{<br />
			if(current==NULL)<br />
			{<br />
				current=malloc(sizeof(node));<br />
				printf(&#8220;\nGive node : &#8220;);<br />
				scanf(&#8220;%d&#8221;,&amp;current-&gt;data);<br />
				current-&gt;npx=NULL;<br />
				*p=current;<br />
			}<br />
			else<br />
			{<br />
				next=malloc(sizeof(node));<br />
				printf(&#8220;\nGive node : &#8220;);<br />
				scanf(&#8220;%d&#8221;,&amp;next-&gt;data);<br />
				next-&gt;npx=NULL;<br />
				//(node *)((long long)(a)^(long long)(b))<br />
				current-&gt;npx=(node *)((long long)(prev)^(long long)(next));<br />
				prev=current;<br />
				current=next;<br />
			}<br />
		}<br />
		else<br />
			break;<br />
	}</p>
<p>}<br />
void print(node *p)<br />
{<br />
	node *prev,*current;<br />
	prev=NULL;<br />
	current=p;<br />
	printf(&#8220;\nLinked list is : &#8220;);<br />
	while(p!=NULL)<br />
	{<br />
		printf(&#8220;%d\t&#8221;,p-&gt;data);<br />
		p=(node *)((long long)(prev)^(long long)(current-&gt;npx));<br />
		prev=current;<br />
		current=p;<br />
		if(prev-&gt;npx==NULL)<br />
			break;<br />
	}<br />
	printf(&#8220;\n&#8221;);<br />
}<br />
main()<br />
{<br />
	node *head=NULL;<br />
	createlist(&amp;head);<br />
	print(head);<br />
}<br />
]</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Yogesh</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-4853</link>
		<dc:creator><![CDATA[Yogesh]]></dc:creator>
		<pubDate>Mon, 08 Aug 2011 10:28:38 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-4853</guid>
		<description><![CDATA[But we always need the prev node address in order to traverse from a given node pointer. Its more like a single linked list where we rem the prev node of a current node ptr.]]></description>
		<content:encoded><![CDATA[<p>But we always need the prev node address in order to traverse from a given node pointer. Its more like a single linked list where we rem the prev node of a current node ptr.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kl</title>
		<link>http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/#comment-4228</link>
		<dc:creator><![CDATA[kl]]></dc:creator>
		<pubDate>Mon, 06 Jun 2011 07:28:38 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12367#comment-4228</guid>
		<description><![CDATA[struct b
{
int a;
int b;
};]]></description>
		<content:encoded><![CDATA[<p>struct b<br />
{<br />
int a;<br />
int b;<br />
};</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.048 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:07:38 -->

<!-- Compression = gzip -->