<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Vertical Sum in a given Binary Tree &#124; Set 1</title>
	<atom:link href="http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: joy</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39492</link>
		<dc:creator><![CDATA[joy]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 23:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39492</guid>
		<description><![CDATA[a little explanation would have gone a long way..]]></description>
		<content:encoded><![CDATA[<p>a little explanation would have gone a long way..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ultimate_coder</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39318</link>
		<dc:creator><![CDATA[ultimate_coder]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 07:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39318</guid>
		<description><![CDATA[C++ guys , using stl maps

void vertical_sum(struct node *root,int hd,map &#038;m){
if(!root) return;

//If horizontal dist(hd) do not exist, create one else increment with curr node&#039;s data

if(m.find(hd)==m.end()) m[hd]=root-&#062;data;

else if(m.find(hd)!=m.end()) m[hd]+=root-&#062;data;

vertical_sum(root-&#062;left,hd-1,m);
vertical_sum(root-&#062;right,hd+1,m);

}


// In main just print map as 
map::iterator itr=m.begin();

    while(itr!=m.end()){
    cout&#060;&#060;endl&#060;&#060;&#034;Hd &#034;&#060;first&#060;&#060;&#034;, sum is : &#034;&#060;second;
    itr++;
    }]]></description>
		<content:encoded><![CDATA[<p>C++ guys , using stl maps</p>
<p>void vertical_sum(struct node *root,int hd,map &amp;m){<br />
if(!root) return;</p>
<p>//If horizontal dist(hd) do not exist, create one else increment with curr node&#8217;s data</p>
<p>if(m.find(hd)==m.end()) m[hd]=root-&gt;data;</p>
<p>else if(m.find(hd)!=m.end()) m[hd]+=root-&gt;data;</p>
<p>vertical_sum(root-&gt;left,hd-1,m);<br />
vertical_sum(root-&gt;right,hd+1,m);</p>
<p>}</p>
<p>// In main just print map as<br />
map::iterator itr=m.begin();</p>
<p>    while(itr!=m.end()){<br />
    cout&lt;&lt;endl&lt;&lt;&quot;Hd &quot;&lt;first&lt;&lt;&quot;, sum is : &quot;&lt;second;<br />
    itr++;<br />
    }</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ultimate_coder</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39300</link>
		<dc:creator><![CDATA[ultimate_coder]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 05:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39300</guid>
		<description><![CDATA[[sourcecode language=&quot;C++&quot;][/sourcecode]
Sorry for late reply..yeah my approach was wrong. I must be trying to solve problem without hash map. You need leftmost and rightmost boundaries to do it without extra space( here space is  O(n)--worst case of skewed tree).

I think a inorder traversal will give us these boundaries.

If anyone knows how to get these boundaries more optimized, then please let me know :D.]]></description>
		<content:encoded><![CDATA[<p>Sorry for late reply..yeah my approach was wrong. I must be trying to solve problem without hash map. You need leftmost and rightmost boundaries to do it without extra space( here space is  O(n)&#8211;worst case of skewed tree).</p>
<p>I think a inorder traversal will give us these boundaries.</p>
<p>If anyone knows how to get these boundaries more optimized, then please let me know :D.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit Kumar</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39166</link>
		<dc:creator><![CDATA[Rohit Kumar]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 15:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39166</guid>
		<description><![CDATA[c code
https://ideone.com/KuKTN2]]></description>
		<content:encoded><![CDATA[<p>c code<br />
<a href="https://ideone.com/KuKTN2" rel="nofollow">https://ideone.com/KuKTN2</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit Kumar</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39165</link>
		<dc:creator><![CDATA[Rohit Kumar]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 15:07:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39165</guid>
		<description><![CDATA[code in c language
https://ideone.com/KuKTN2]]></description>
		<content:encoded><![CDATA[<p>code in c language<br />
<a href="https://ideone.com/KuKTN2" rel="nofollow">https://ideone.com/KuKTN2</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rohit Kumar</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-39164</link>
		<dc:creator><![CDATA[Rohit Kumar]]></dc:creator>
		<pubDate>Thu, 19 Jun 2014 14:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-39164</guid>
		<description><![CDATA[#include
#include
struct node
{
    int data;
    struct node *prev;
    struct node* next;
};
int elements(struct node*);
void weight(struct node*,int*,int);
int vertical(struct node*);
int height(struct node*);
struct node* newNode(int data)
{
  struct node* node =
      (struct node*)malloc(sizeof(struct node));
  node-&#062;data = data;
  node-&#062;prev = NULL;
  node-&#062;next = NULL;
  return(node);
}
int main()
{
    int n;
   struct node *root  = newNode(1);
  root-&#062;prev         = newNode(2);
  root-&#062;next        = newNode(3);
  root-&#062;prev-&#062;prev   = newNode(4);
  root-&#062;prev-&#062;next  = newNode(5);
  root-&#062;next-&#062;prev = newNode(6);
  root-&#062;next-&#062;next = newNode(7);
  root-&#062;next-&#062;prev-&#062;prev=newNode(13);
//  root-&#062;prev-&#062;next-&#062;prev=newNode(300);
//  root-&#062;prev-&#062;next-&#062;prev-&#062;next=newNode(100);
//  root-&#062;prev-&#062;prev-&#062;next=newNode(200);
   vertical(root);
    return 0;
}
int vertical(struct node*root)
{
   if(root==NULL)return root-&#062;data;
   int n,h1,h2,a[100],b[100],i=0,j,k=0,sum;
   n=elements(root);
   h1=height(root-&#062;prev);
   h2=height(root-&#062;next);
   weight(root,a,i);
   for(j=-h1;j&#060;h2;j++)
   {i=0;sum=0;
          while(i&#060;2*n)
         {i++;
          if(a[i]==j)sum=sum+a[i-1];
            i++;
          }
        b[k++]=sum;
   }
   i=0;
   while(iprev);
     elements(root-&#062;next);
     return count;
}
void weight(struct node*root,int *a,int i)
{
   if(root==NULL)return;
   static int j;
   a[j++]=root-&#062;data;
   a[j++]=i;
   weight(root-&#062;prev,a,i-1);
   weight(root-&#062;next,a,i+1);
}
int height(struct node*root)
{
    if(root==NULL)return 0;
    int h;
    h=1+((height(root-&#062;prev)&#062;height(root-&#062;next)?height(root-&#062;prev):height(root-&#062;next)));
    return h;
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include<br />
struct node<br />
{<br />
    int data;<br />
    struct node *prev;<br />
    struct node* next;<br />
};<br />
int elements(struct node*);<br />
void weight(struct node*,int*,int);<br />
int vertical(struct node*);<br />
int height(struct node*);<br />
struct node* newNode(int data)<br />
{<br />
  struct node* node =<br />
      (struct node*)malloc(sizeof(struct node));<br />
  node-&gt;data = data;<br />
  node-&gt;prev = NULL;<br />
  node-&gt;next = NULL;<br />
  return(node);<br />
}<br />
int main()<br />
{<br />
    int n;<br />
   struct node *root  = newNode(1);<br />
  root-&gt;prev         = newNode(2);<br />
  root-&gt;next        = newNode(3);<br />
  root-&gt;prev-&gt;prev   = newNode(4);<br />
  root-&gt;prev-&gt;next  = newNode(5);<br />
  root-&gt;next-&gt;prev = newNode(6);<br />
  root-&gt;next-&gt;next = newNode(7);<br />
  root-&gt;next-&gt;prev-&gt;prev=newNode(13);<br />
//  root-&gt;prev-&gt;next-&gt;prev=newNode(300);<br />
//  root-&gt;prev-&gt;next-&gt;prev-&gt;next=newNode(100);<br />
//  root-&gt;prev-&gt;prev-&gt;next=newNode(200);<br />
   vertical(root);<br />
    return 0;<br />
}<br />
int vertical(struct node*root)<br />
{<br />
   if(root==NULL)return root-&gt;data;<br />
   int n,h1,h2,a[100],b[100],i=0,j,k=0,sum;<br />
   n=elements(root);<br />
   h1=height(root-&gt;prev);<br />
   h2=height(root-&gt;next);<br />
   weight(root,a,i);<br />
   for(j=-h1;j&lt;h2;j++)<br />
   {i=0;sum=0;<br />
          while(i&lt;2*n)<br />
         {i++;<br />
          if(a[i]==j)sum=sum+a[i-1];<br />
            i++;<br />
          }<br />
        b[k++]=sum;<br />
   }<br />
   i=0;<br />
   while(iprev);<br />
     elements(root-&gt;next);<br />
     return count;<br />
}<br />
void weight(struct node*root,int *a,int i)<br />
{<br />
   if(root==NULL)return;<br />
   static int j;<br />
   a[j++]=root-&gt;data;<br />
   a[j++]=i;<br />
   weight(root-&gt;prev,a,i-1);<br />
   weight(root-&gt;next,a,i+1);<br />
}<br />
int height(struct node*root)<br />
{<br />
    if(root==NULL)return 0;<br />
    int h;<br />
    h=1+((height(root-&gt;prev)&gt;height(root-&gt;next)?height(root-&gt;prev):height(root-&gt;next)));<br />
    return h;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tranquil</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-38954</link>
		<dc:creator><![CDATA[tranquil]]></dc:creator>
		<pubDate>Tue, 17 Jun 2014 14:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-38954</guid>
		<description><![CDATA[The right child of the left child of root(here 5) and the left child of right child of the root(here 6) will always be in the same vertical line (for root = 1).  Also, every leftmost(2, 4) and rightmost nodes(3, 7) of each level will fall in a different vertical line. It is easy to picturize that there will not be any vertical lines other than these. Also each node will fall in one and oly one vertical line. This can be exploited to solve this in O(n) time and O(1) extra space.

vector getAllVerticalSum(TreeNode * root){
    TreeNode * head = root;
    while(head-&#062;left){
          ans.push_back(getVerticalSum(head-&#062;left);
          head = head-&#062;left
    }
    head = root;
    while(head-&#062;right){
         ans.push_back(getVerticalSum(head-&#062;right);
         head = head-&#062;right;
    }
}

int getVerticalSum(TreeNode* root){
    if(!root) return 0;
    int l = 0, r = 0;
    if(root-&#062;left){
        l = getVerticalSum(root-&#062;left-&#062;right);
    }
    if(root-&#062;right){
        r = getVerticalSum(root-&#062;right-&#062;left);
    }
    return l + r + root-&#062;val;
}]]></description>
		<content:encoded><![CDATA[<p>The right child of the left child of root(here 5) and the left child of right child of the root(here 6) will always be in the same vertical line (for root = 1).  Also, every leftmost(2, 4) and rightmost nodes(3, 7) of each level will fall in a different vertical line. It is easy to picturize that there will not be any vertical lines other than these. Also each node will fall in one and oly one vertical line. This can be exploited to solve this in O(n) time and O(1) extra space.</p>
<p>vector getAllVerticalSum(TreeNode * root){<br />
    TreeNode * head = root;<br />
    while(head-&gt;left){<br />
          ans.push_back(getVerticalSum(head-&gt;left);<br />
          head = head-&gt;left<br />
    }<br />
    head = root;<br />
    while(head-&gt;right){<br />
         ans.push_back(getVerticalSum(head-&gt;right);<br />
         head = head-&gt;right;<br />
    }<br />
}</p>
<p>int getVerticalSum(TreeNode* root){<br />
    if(!root) return 0;<br />
    int l = 0, r = 0;<br />
    if(root-&gt;left){<br />
        l = getVerticalSum(root-&gt;left-&gt;right);<br />
    }<br />
    if(root-&gt;right){<br />
        r = getVerticalSum(root-&gt;right-&gt;left);<br />
    }<br />
    return l + r + root-&gt;val;<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vishnu</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-38369</link>
		<dc:creator><![CDATA[Vishnu]]></dc:creator>
		<pubDate>Fri, 13 Jun 2014 03:19:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-38369</guid>
		<description><![CDATA[How is horizontal distance being considered in this? Would this not create a new DLL node for every tree node rather than a DLL node for every vertical line in the binary tree?

Please correct my understand if it is wrong.]]></description>
		<content:encoded><![CDATA[<p>How is horizontal distance being considered in this? Would this not create a new DLL node for every tree node rather than a DLL node for every vertical line in the binary tree?</p>
<p>Please correct my understand if it is wrong.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-38188</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 09:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-38188</guid>
		<description><![CDATA[here you are changing the structure of  the tree which sometimes is  not allowed and can you please explain your vertical sum function ?]]></description>
		<content:encoded><![CDATA[<p>here you are changing the structure of  the tree which sometimes is  not allowed and can you please explain your vertical sum function ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: ANA</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-38187</link>
		<dc:creator><![CDATA[ANA]]></dc:creator>
		<pubDate>Wed, 11 Jun 2014 09:52:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-38187</guid>
		<description><![CDATA[c++ solution 

https://ideone.com/IY30E4]]></description>
		<content:encoded><![CDATA[<p>c++ solution </p>
<p><a href="https://ideone.com/IY30E4" rel="nofollow">https://ideone.com/IY30E4</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: instance</title>
		<link>http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/#comment-37901</link>
		<dc:creator><![CDATA[instance]]></dc:creator>
		<pubDate>Sun, 08 Jun 2014 06:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=18215#comment-37901</guid>
		<description><![CDATA[Solution in O(n) with O(1) extra space.

http://ideone.com/1bmMgg]]></description>
		<content:encoded><![CDATA[<p>Solution in O(n) with O(1) extra space.</p>
<p><a href="http://ideone.com/1bmMgg" rel="nofollow">http://ideone.com/1bmMgg</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.050 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:23:50 -->

<!-- Compression = gzip -->