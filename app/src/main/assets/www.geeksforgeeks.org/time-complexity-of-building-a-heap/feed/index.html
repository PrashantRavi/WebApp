<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Time Complexity of building a heap</title>
	<atom:link href="http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Sriram Ganesh</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-39816</link>
		<dc:creator><![CDATA[Sriram Ganesh]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 18:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-39816</guid>
		<description><![CDATA[http://www.cse.iitk.ac.in/users/sbaswana/Courses/ESO211/heap.pdf/
This link is not working.]]></description>
		<content:encoded><![CDATA[<p><a href="http://www.cse.iitk.ac.in/users/sbaswana/Courses/ESO211/heap.pdf/" rel="nofollow">http://www.cse.iitk.ac.in/users/sbaswana/Courses/ESO211/heap.pdf/</a><br />
This link is not working.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: groomnestle</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-30744</link>
		<dc:creator><![CDATA[groomnestle]]></dc:creator>
		<pubDate>Sun, 15 Dec 2013 21:37:00 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-30744</guid>
		<description><![CDATA[It is easier to write heapsort with first heap index as 1 instead of 0, in this case you can correlate parent and children with a simple formula: 
parent = k, left child = 2k, right child= 2k+1.]]></description>
		<content:encoded><![CDATA[<p>It is easier to write heapsort with first heap index as 1 instead of 0, in this case you can correlate parent and children with a simple formula:<br />
parent = k, left child = 2k, right child= 2k+1.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sandeep</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4518</link>
		<dc:creator><![CDATA[Sandeep]]></dc:creator>
		<pubDate>Tue, 05 Jul 2011 12:01:26 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4518</guid>
		<description><![CDATA[@Venki:  Both O(n) and O(nLogn) are upper bounds for build heap.  O(n) is tighter upper bound.]]></description>
		<content:encoded><![CDATA[<p>@Venki:  Both O(n) and O(nLogn) are upper bounds for build heap.  O(n) is tighter upper bound.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Venki</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4517</link>
		<dc:creator><![CDATA[Venki]]></dc:creator>
		<pubDate>Tue, 05 Jul 2011 10:33:51 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4517</guid>
		<description><![CDATA[The complexity O(n log n) is an upper bound. The upper bound is calculated assuming that every node is of height log n. But in reality it is not the case. Height of node varies in the heap. By definition, height of a node is the longest path length from that node to leaf node. This way the root is at maximum height, followed by next level subtrees.

The build-heap time complexity is function of node&#039;s height f(h). How can we express f(h)? Given a binary-heap having N elements, we can observe that there will be maximum of f(h) = [N/2^(h+1)] nodes at height h. For example, given N = 7 i.e. a full binary tree of height 2, the root is at height of 2 and f(2) = 7/8 = 0, f(1) = 7/4 = 1, f(0) = 7/2 = 3, all satisfying our assumption. Infact, it is an approximation and as the height of tree increases our approximation reach exact limit.

Now, it is easy to check the tighter bound on building the heap. To build heap, we call heapify() whose complexity is O(h) and we call it on nodes from nodes n/2 to 1. These nodes form internal nodes of binary heap. To find exact computational cost we need to sum the cost of heapifying each node. Yet we are interested in asymptotic bound. We need to find the cost of *&lt;em&gt;a node&lt;/em&gt;* at each level and integrate (sum) them to find the complexity.

Mathematically T(n) = summation of [h x f(h)] in the interval 0 to logN (i.e. height of tree). After solving the integration, we will arrive at 2N which is linear in N.

Hope it helps in better understanding the heap build analysis. The tighter bound is O(n) and upper bound is O(n log n).

@Sandeep, little correction required in the post.]]></description>
		<content:encoded><![CDATA[<p>The complexity O(n log n) is an upper bound. The upper bound is calculated assuming that every node is of height log n. But in reality it is not the case. Height of node varies in the heap. By definition, height of a node is the longest path length from that node to leaf node. This way the root is at maximum height, followed by next level subtrees.</p>
<p>The build-heap time complexity is function of node&#8217;s height f(h). How can we express f(h)? Given a binary-heap having N elements, we can observe that there will be maximum of f(h) = [N/2^(h+1)] nodes at height h. For example, given N = 7 i.e. a full binary tree of height 2, the root is at height of 2 and f(2) = 7/8 = 0, f(1) = 7/4 = 1, f(0) = 7/2 = 3, all satisfying our assumption. Infact, it is an approximation and as the height of tree increases our approximation reach exact limit.</p>
<p>Now, it is easy to check the tighter bound on building the heap. To build heap, we call heapify() whose complexity is O(h) and we call it on nodes from nodes n/2 to 1. These nodes form internal nodes of binary heap. To find exact computational cost we need to sum the cost of heapifying each node. Yet we are interested in asymptotic bound. We need to find the cost of *<em>a node</em>* at each level and integrate (sum) them to find the complexity.</p>
<p>Mathematically T(n) = summation of [h x f(h)] in the interval 0 to logN (i.e. height of tree). After solving the integration, we will arrive at 2N which is linear in N.</p>
<p>Hope it helps in better understanding the heap build analysis. The tighter bound is O(n) and upper bound is O(n log n).</p>
<p>@Sandeep, little correction required in the post.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4403</link>
		<dc:creator><![CDATA[Amit]]></dc:creator>
		<pubDate>Wed, 22 Jun 2011 07:15:16 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4403</guid>
		<description><![CDATA[If you index i=1 to n/2 you can observe that you will need to modify your Heapify function to work (try to apply this and you will able to see the differnece ).... so in Cormen to avoid this modification we start with i=n/2 to 1

Both indexing will work but the efficient way will be the latter case....]]></description>
		<content:encoded><![CDATA[<p>If you index i=1 to n/2 you can observe that you will need to modify your Heapify function to work (try to apply this and you will able to see the differnece )&#8230;. so in Cormen to avoid this modification we start with i=n/2 to 1</p>
<p>Both indexing will work but the efficient way will be the latter case&#8230;.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: tk</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4226</link>
		<dc:creator><![CDATA[tk]]></dc:creator>
		<pubDate>Mon, 06 Jun 2011 06:58:39 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4226</guid>
		<description><![CDATA[Ineresting fact. Good to know.]]></description>
		<content:encoded><![CDATA[<p>Ineresting fact. Good to know.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: kartik</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4174</link>
		<dc:creator><![CDATA[kartik]]></dc:creator>
		<pubDate>Sat, 28 May 2011 17:34:47 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4174</guid>
		<description><![CDATA[I think its because the way Heapify process works.  When we Heapify a node at index i, we assume that all the subtrees of i are heapified.  Also, the Heapify process must go in upward direction to make sure that the maximum (or minimum) element is at the top.]]></description>
		<content:encoded><![CDATA[<p>I think its because the way Heapify process works.  When we Heapify a node at index i, we assume that all the subtrees of i are heapified.  Also, the Heapify process must go in upward direction to make sure that the maximum (or minimum) element is at the top.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vinay</title>
		<link>http://www.geeksforgeeks.org/time-complexity-of-building-a-heap/#comment-4173</link>
		<dc:creator><![CDATA[Vinay]]></dc:creator>
		<pubDate>Sat, 28 May 2011 17:13:22 +0000</pubDate>
		<guid isPermaLink="false">http://geeksforgeeks.org/?p=12580#comment-4173</guid>
		<description><![CDATA[one conceptual question from Cormen:why the loop goes down from heapsize/2 to 1 and not increment from 1 to heapsize/2?]]></description>
		<content:encoded><![CDATA[<p>one conceptual question from Cormen:why the loop goes down from heapsize/2 to 1 and not increment from 1 to heapsize/2?</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.039 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:41:20 -->

<!-- Compression = gzip -->