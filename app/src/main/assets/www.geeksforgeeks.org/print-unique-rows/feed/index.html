<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Print unique rows in a given boolean matrix</title>
	<atom:link href="http://www.geeksforgeeks.org/print-unique-rows/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/print-unique-rows/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: guest</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-37069</link>
		<dc:creator><![CDATA[guest]]></dc:creator>
		<pubDate>Fri, 30 May 2014 13:17:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-37069</guid>
		<description><![CDATA[convert each row to a string nd chk if it has previously occured or not]]></description>
		<content:encoded><![CDATA[<p>convert each row to a string nd chk if it has previously occured or not</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: mani</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-34934</link>
		<dc:creator><![CDATA[mani]]></dc:creator>
		<pubDate>Sun, 20 Apr 2014 18:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-34934</guid>
		<description><![CDATA[Hi, Can you please give a detailed explanation for your code?]]></description>
		<content:encoded><![CDATA[<p>Hi, Can you please give a detailed explanation for your code?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: AT</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-33281</link>
		<dc:creator><![CDATA[AT]]></dc:creator>
		<pubDate>Sat, 08 Mar 2014 03:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-33281</guid>
		<description><![CDATA[hey size of array will be 2^32 or 2^64 .
And what if length of row is greater than 64 .]]></description>
		<content:encoded><![CDATA[<p>hey size of array will be 2^32 or 2^64 .<br />
And what if length of row is greater than 64 .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vu Duc Minh</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-31075</link>
		<dc:creator><![CDATA[Vu Duc Minh]]></dc:creator>
		<pubDate>Fri, 27 Dec 2013 17:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-31075</guid>
		<description><![CDATA[And to avoid multiplication, you can use &quot;+&quot; with irrational number; for example, assign sqrt(2), sqrt(3),sqrt(5) ... to the first, second ... column, etc.]]></description>
		<content:encoded><![CDATA[<p>And to avoid multiplication, you can use &#8220;+&#8221; with irrational number; for example, assign sqrt(2), sqrt(3),sqrt(5) &#8230; to the first, second &#8230; column, etc.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vu Duc Minh</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-31074</link>
		<dc:creator><![CDATA[Vu Duc Minh]]></dc:creator>
		<pubDate>Fri, 27 Dec 2013 17:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-31074</guid>
		<description><![CDATA[&quot;gud 1&quot; .... dont use this kind of typos in public forum.]]></description>
		<content:encoded><![CDATA[<p>&#8220;gud 1&#8221; &#8230;. dont use this kind of typos in public forum.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Vu Duc Minh</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-31073</link>
		<dc:creator><![CDATA[Vu Duc Minh]]></dc:creator>
		<pubDate>Fri, 27 Dec 2013 17:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-31073</guid>
		<description><![CDATA[This is a hash-based solution.]]></description>
		<content:encoded><![CDATA[<p>This is a hash-based solution.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: vamshi</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-30457</link>
		<dc:creator><![CDATA[vamshi]]></dc:creator>
		<pubDate>Thu, 05 Dec 2013 20:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-30457</guid>
		<description><![CDATA[gud 1....i dnt see any flwas in this..but if number of rows/columns are very large....den integer overflow ca happen.....also we need to have all prime numbers list]]></description>
		<content:encoded><![CDATA[<p>gud 1&#8230;.i dnt see any flwas in this..but if number of rows/columns are very large&#8230;.den integer overflow ca happen&#8230;..also we need to have all prime numbers list</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Coder011</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-30396</link>
		<dc:creator><![CDATA[Coder011]]></dc:creator>
		<pubDate>Wed, 04 Dec 2013 09:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-30396</guid>
		<description><![CDATA[A modified approach for using a trie. In this code I have implemented a trie as a BST, and the inserted the row like we do insertion in a BST, go right for 1 and go left for 0

Link to ideone: http://ideone.com/xlPYBh

Code:

// Created by Coder011

// Program : &quot;To find the number of unique rows in a boolean matrix&quot;

#include 

#include 

#include 

#include 

#include 

using namespace std;

typedef struct node

{

	int val;

	struct node *left;

	struct node *right;

}node;

node *newNode(int x)

{

	node *root=(node *)calloc(1,sizeof(node));

	root-&#062;val=x;

	root-&#062;left=root-&#062;right=NULL;

	return root;

}

node *insert(node *root,int *a,int sz,int curr)

{

	if(curr&#062;sz)

	 return NULL;

	else

	{

	    if(!root)

            root=newNode(a[curr-1]);

		if(a[curr])

		 {

		 	 root-&#062;right=insert(root-&#062;right,a,sz,curr+1);

		 }

		 else

		 {

            root-&#062;left=insert(root-&#062;left,a,sz,curr+1);

         }

    }

    return root;

}

void fun(vector path)

{

	for(int i=1;i&#060;(int)path.size();i++)

	  cout&#060;&#060;path[i]&#060;&#060;&#034; &#034;;

	cout&#060;&#060;&#034;n&#034;;

}

void inorder(node *root,vector path)

{

	if(!root)

	  return;

	path.push_back(root-&#062;val);

	if(!root-&#062;left &#038;&#038; !root-&#062;right)

	  { fun(path); return; }

	inorder(root-&#062;left,path);

	inorder(root-&#062;right,path);

	path.pop_back();

}

int main()

{

	int n,m;

	cin&#062;&#062;n&#062;&#062;m;

	int a[n+1][m+1];

	struct node *root=newNode(-2);  // Create a dummy root

	for(int i=0;i&#060;n;i++)

	for(int j=0;j&#062;a[i][j];

	for(int i=0;i&#060;n;i++)

		{

		    root=insert(root,a[i],m,0);

		}

    printf(&#034;The unique rows in the given matrix are :n&#034;);

	vector path;

	inorder(root,path);

	return 0;

}]]></description>
		<content:encoded><![CDATA[<p>A modified approach for using a trie. In this code I have implemented a trie as a BST, and the inserted the row like we do insertion in a BST, go right for 1 and go left for 0</p>
<p>Link to ideone: <a href="http://ideone.com/xlPYBh" rel="nofollow">http://ideone.com/xlPYBh</a></p>
<p>Code:</p>
<p>// Created by Coder011</p>
<p>// Program : &#8220;To find the number of unique rows in a boolean matrix&#8221;</p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>#include </p>
<p>using namespace std;</p>
<p>typedef struct node</p>
<p>{</p>
<p>	int val;</p>
<p>	struct node *left;</p>
<p>	struct node *right;</p>
<p>}node;</p>
<p>node *newNode(int x)</p>
<p>{</p>
<p>	node *root=(node *)calloc(1,sizeof(node));</p>
<p>	root-&gt;val=x;</p>
<p>	root-&gt;left=root-&gt;right=NULL;</p>
<p>	return root;</p>
<p>}</p>
<p>node *insert(node *root,int *a,int sz,int curr)</p>
<p>{</p>
<p>	if(curr&gt;sz)</p>
<p>	 return NULL;</p>
<p>	else</p>
<p>	{</p>
<p>	    if(!root)</p>
<p>            root=newNode(a[curr-1]);</p>
<p>		if(a[curr])</p>
<p>		 {</p>
<p>		 	 root-&gt;right=insert(root-&gt;right,a,sz,curr+1);</p>
<p>		 }</p>
<p>		 else</p>
<p>		 {</p>
<p>            root-&gt;left=insert(root-&gt;left,a,sz,curr+1);</p>
<p>         }</p>
<p>    }</p>
<p>    return root;</p>
<p>}</p>
<p>void fun(vector path)</p>
<p>{</p>
<p>	for(int i=1;i&lt;(int)path.size();i++)</p>
<p>	  cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;</p>
<p>	cout&lt;&lt;&quot;n&quot;;</p>
<p>}</p>
<p>void inorder(node *root,vector path)</p>
<p>{</p>
<p>	if(!root)</p>
<p>	  return;</p>
<p>	path.push_back(root-&gt;val);</p>
<p>	if(!root-&gt;left &amp;&amp; !root-&gt;right)</p>
<p>	  { fun(path); return; }</p>
<p>	inorder(root-&gt;left,path);</p>
<p>	inorder(root-&gt;right,path);</p>
<p>	path.pop_back();</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>	int n,m;</p>
<p>	cin&gt;&gt;n&gt;&gt;m;</p>
<p>	int a[n+1][m+1];</p>
<p>	struct node *root=newNode(-2);  // Create a dummy root</p>
<p>	for(int i=0;i&lt;n;i++)</p>
<p>	for(int j=0;j&gt;a[i][j];</p>
<p>	for(int i=0;i&lt;n;i++)</p>
<p>		{</p>
<p>		    root=insert(root,a[i],m,0);</p>
<p>		}</p>
<p>    printf(&quot;The unique rows in the given matrix are :n&quot;);</p>
<p>	vector path;</p>
<p>	inorder(root,path);</p>
<p>	return 0;</p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: guest</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-30189</link>
		<dc:creator><![CDATA[guest]]></dc:creator>
		<pubDate>Wed, 27 Nov 2013 22:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-30189</guid>
		<description><![CDATA[how to take hash of 0(row)????Ir will be 0(R)......]]></description>
		<content:encoded><![CDATA[<p>how to take hash of 0(row)????Ir will be 0(R)&#8230;&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: siren09</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-30188</link>
		<dc:creator><![CDATA[siren09]]></dc:creator>
		<pubDate>Wed, 27 Nov 2013 21:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-30188</guid>
		<description><![CDATA[Why are all the algos so inefficient ??? This problem can be easily solved in O(ROW * COL) and auxiliary space complexity of O(ROW). Use hash tables.... and for each row, just calculate the decimal equivalent of the binary array ....they insert the decimal value in the hash table...in case of repetition, it will be ignored as value already exists in the hash table...thats it !]]></description>
		<content:encoded><![CDATA[<p>Why are all the algos so inefficient ??? This problem can be easily solved in O(ROW * COL) and auxiliary space complexity of O(ROW). Use hash tables&#8230;. and for each row, just calculate the decimal equivalent of the binary array &#8230;.they insert the decimal value in the hash table&#8230;in case of repetition, it will be ignored as value already exists in the hash table&#8230;thats it !</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Amit Goswami</title>
		<link>http://www.geeksforgeeks.org/print-unique-rows/#comment-29823</link>
		<dc:creator><![CDATA[Amit Goswami]]></dc:creator>
		<pubDate>Thu, 14 Nov 2013 03:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=24561#comment-29823</guid>
		<description><![CDATA[for each row 
  xorRow[row] = xor all indexes with 1 (or zero)

for each row 
  check if xorRow[row] equals any elem in xorRow[]

Time : O(row * row) + O(col * row)
Space : O(row)]]></description>
		<content:encoded><![CDATA[<p>for each row<br />
  xorRow[row] = xor all indexes with 1 (or zero)</p>
<p>for each row<br />
  check if xorRow[row] equals any elem in xorRow[]</p>
<p>Time : O(row * row) + O(col * row)<br />
Space : O(row)</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.040 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:08:53 -->

<!-- Compression = gzip -->