<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Median in a stream of integers (running integers)</title>
	<atom:link href="http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Ankur Jain</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-39480</link>
		<dc:creator><![CDATA[Ankur Jain]]></dc:creator>
		<pubDate>Sun, 22 Jun 2014 17:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-39480</guid>
		<description><![CDATA[how does heapify work in case of deletion ...
i think , it doesn&#039;t work perfectly ...


somebody explain the  exact procedure how deletion of heap  i .e how heapify places the element in its exact position]]></description>
		<content:encoded><![CDATA[<p>how does heapify work in case of deletion &#8230;<br />
i think , it doesn&#8217;t work perfectly &#8230;</p>
<p>somebody explain the  exact procedure how deletion of heap  i .e how heapify places the element in its exact position</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: HevvyD</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-38763</link>
		<dc:creator><![CDATA[HevvyD]]></dc:creator>
		<pubDate>Mon, 16 Jun 2014 02:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-38763</guid>
		<description><![CDATA[how would u set this up to make it print the median that is present in the array instead of calculating the median? For example, if the array contained values: 7, 9, 3 it would then print out the 7 because it is in between the array when it is ascending]]></description>
		<content:encoded><![CDATA[<p>how would u set this up to make it print the median that is present in the array instead of calculating the median? For example, if the array contained values: 7, 9, 3 it would then print out the 7 because it is in between the array when it is ascending</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: toughtimes</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-38696</link>
		<dc:creator><![CDATA[toughtimes]]></dc:creator>
		<pubDate>Sun, 15 Jun 2014 14:15:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-38696</guid>
		<description><![CDATA[same problem!! sift down should be done!!]]></description>
		<content:encoded><![CDATA[<p>same problem!! sift down should be done!!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jugal</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-38346</link>
		<dc:creator><![CDATA[jugal]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 18:41:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-38346</guid>
		<description><![CDATA[@venki   : here is my code using doubly linked list with O(n) complexity. It is also working for duplicates.

#include
#include

using namespace std;

struct node
{	int data;
	struct node* next;
	struct node* prev;	
};

struct node* head = NULL;
struct node* m1 = NULL;
int count = 0;

void print_list() {
	struct node* temp = head;
	while(temp != NULL)
	{	cout &#060;data &#060;&quot;;
		temp = temp-&#062;next;	}
	cout &#060;data;
	}else
	{	if(count &#038; 1)
		{	if(m1-&#062;data data)
				m1 = m1-&#062;next;
			return m1-&#062;data;
		}else
		{	if(m1-&#062;data &#062; node-&#062;data)
				m1 = m1-&#062;prev;
			return (m1-&#062;data + m1-&#062;next-&#062;data)/2;			
		}
	}
}


void push(int data)
{
	struct node* temp = (struct node*)malloc(sizeof(struct node));
	temp-&#062;data = data;
	temp-&#062;next = NULL;
	temp-&#062;prev = NULL;
	if(head == NULL)
		head = temp;
	else
	{
		struct node* current = head;
		struct node* previous = NULL;
		while(current != NULL &#038;&#038; current-&#062;data next;
		}
		if(current == head)
		{
			temp-&#062;next = head;
			head-&#062;prev = temp;
			head = temp;
		}
		else if(current==NULL)
		{
			temp-&#062;prev = previous;
			previous-&#062;next = temp;
		}
		else
		{
			temp-&#062;prev = previous;
			temp-&#062;next = current;
			current-&#062;prev = temp;
			previous-&#062;next = temp;
		}
	}
	print_list();
	cout &#060;&#060; median(temp) &#060;&#060; endl;
}



int main()
{
	int a[] = {5, 5, 3, 2, 8, 7, 9, 10, 6, 11, 4};
	int n = sizeof(a)/sizeof(a[0]);

	for(int i=0;i&#060;n;i++)
		push(a[i]);}]]></description>
		<content:encoded><![CDATA[<p>@venki   : here is my code using doubly linked list with O(n) complexity. It is also working for duplicates.</p>
<p>#include<br />
#include</p>
<p>using namespace std;</p>
<p>struct node<br />
{	int data;<br />
	struct node* next;<br />
	struct node* prev;<br />
};</p>
<p>struct node* head = NULL;<br />
struct node* m1 = NULL;<br />
int count = 0;</p>
<p>void print_list() {<br />
	struct node* temp = head;<br />
	while(temp != NULL)<br />
	{	cout &lt;data &lt;&#8220;;<br />
		temp = temp-&gt;next;	}<br />
	cout &lt;data;<br />
	}else<br />
	{	if(count &amp; 1)<br />
		{	if(m1-&gt;data data)<br />
				m1 = m1-&gt;next;<br />
			return m1-&gt;data;<br />
		}else<br />
		{	if(m1-&gt;data &gt; node-&gt;data)<br />
				m1 = m1-&gt;prev;<br />
			return (m1-&gt;data + m1-&gt;next-&gt;data)/2;<br />
		}<br />
	}<br />
}</p>
<p>void push(int data)<br />
{<br />
	struct node* temp = (struct node*)malloc(sizeof(struct node));<br />
	temp-&gt;data = data;<br />
	temp-&gt;next = NULL;<br />
	temp-&gt;prev = NULL;<br />
	if(head == NULL)<br />
		head = temp;<br />
	else<br />
	{<br />
		struct node* current = head;<br />
		struct node* previous = NULL;<br />
		while(current != NULL &amp;&amp; current-&gt;data next;<br />
		}<br />
		if(current == head)<br />
		{<br />
			temp-&gt;next = head;<br />
			head-&gt;prev = temp;<br />
			head = temp;<br />
		}<br />
		else if(current==NULL)<br />
		{<br />
			temp-&gt;prev = previous;<br />
			previous-&gt;next = temp;<br />
		}<br />
		else<br />
		{<br />
			temp-&gt;prev = previous;<br />
			temp-&gt;next = current;<br />
			current-&gt;prev = temp;<br />
			previous-&gt;next = temp;<br />
		}<br />
	}<br />
	print_list();<br />
	cout &lt;&lt; median(temp) &lt;&lt; endl;<br />
}</p>
<p>int main()<br />
{<br />
	int a[] = {5, 5, 3, 2, 8, 7, 9, 10, 6, 11, 4};<br />
	int n = sizeof(a)/sizeof(a[0]);</p>
<p>	for(int i=0;i&lt;n;i++)<br />
		push(a[i]);}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-38344</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 18:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-38344</guid>
		<description><![CDATA[#include
#include

using namespace std;

struct node
{    int data;
    struct node* next;
    struct node* prev;    
};

struct node* head = NULL;
struct node* m1 = NULL;
int count = 0;

void print_list() {
    struct node* temp = head;
    while(temp != NULL)
    {    cout &#060;data &#060;&quot;;
        temp = temp-&#062;next;    }
    cout &#060;data;
    }else
    {    if(count &#038; 1)
        {    if(m1-&#062;data data)
                m1 = m1-&#062;next;
            return m1-&#062;data;
        }else
        {    if(m1-&#062;data &#062; node-&#062;data)
                m1 = m1-&#062;prev;
            return (m1-&#062;data + m1-&#062;next-&#062;data)/2;            
        }
    }
}


void push(int data)
{
    struct node* temp = (struct node*)malloc(sizeof(struct node));
    temp-&#062;data = data;
    temp-&#062;next = NULL;
    temp-&#062;prev = NULL;
    if(head == NULL)
        head = temp;
    else
    {
        struct node* current = head;
        struct node* previous = NULL;
        while(current != NULL &#038;&#038; current-&#062;data next;
        }
        if(current == head)
        {
            temp-&#062;next = head;
            head-&#062;prev = temp;
            head = temp;
        }
        else if(current==NULL)
        {
            temp-&#062;prev = previous;
            previous-&#062;next = temp;
        }
        else
        {
            temp-&#062;prev = previous;
            temp-&#062;next = current;
            current-&#062;prev = temp;
            previous-&#062;next = temp;
        }
    }
    print_list();
    cout &#060;&#060; median(temp) &#060;&#060; endl;
}



int main()
{
    int a[] = {5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4};
    int n = sizeof(a)/sizeof(a[0]);

    for(int i=0;i&#060;n;i++)
        push(a[i]);
}]]></description>
		<content:encoded><![CDATA[<p>#include<br />
#include</p>
<p>using namespace std;</p>
<p>struct node<br />
{    int data;<br />
    struct node* next;<br />
    struct node* prev;<br />
};</p>
<p>struct node* head = NULL;<br />
struct node* m1 = NULL;<br />
int count = 0;</p>
<p>void print_list() {<br />
    struct node* temp = head;<br />
    while(temp != NULL)<br />
    {    cout &lt;data &lt;&#8220;;<br />
        temp = temp-&gt;next;    }<br />
    cout &lt;data;<br />
    }else<br />
    {    if(count &amp; 1)<br />
        {    if(m1-&gt;data data)<br />
                m1 = m1-&gt;next;<br />
            return m1-&gt;data;<br />
        }else<br />
        {    if(m1-&gt;data &gt; node-&gt;data)<br />
                m1 = m1-&gt;prev;<br />
            return (m1-&gt;data + m1-&gt;next-&gt;data)/2;<br />
        }<br />
    }<br />
}</p>
<p>void push(int data)<br />
{<br />
    struct node* temp = (struct node*)malloc(sizeof(struct node));<br />
    temp-&gt;data = data;<br />
    temp-&gt;next = NULL;<br />
    temp-&gt;prev = NULL;<br />
    if(head == NULL)<br />
        head = temp;<br />
    else<br />
    {<br />
        struct node* current = head;<br />
        struct node* previous = NULL;<br />
        while(current != NULL &amp;&amp; current-&gt;data next;<br />
        }<br />
        if(current == head)<br />
        {<br />
            temp-&gt;next = head;<br />
            head-&gt;prev = temp;<br />
            head = temp;<br />
        }<br />
        else if(current==NULL)<br />
        {<br />
            temp-&gt;prev = previous;<br />
            previous-&gt;next = temp;<br />
        }<br />
        else<br />
        {<br />
            temp-&gt;prev = previous;<br />
            temp-&gt;next = current;<br />
            current-&gt;prev = temp;<br />
            previous-&gt;next = temp;<br />
        }<br />
    }<br />
    print_list();<br />
    cout &lt;&lt; median(temp) &lt;&lt; endl;<br />
}</p>
<p>int main()<br />
{<br />
    int a[] = {5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4};<br />
    int n = sizeof(a)/sizeof(a[0]);</p>
<p>    for(int i=0;i&lt;n;i++)<br />
        push(a[i]);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: jugal</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-38339</link>
		<dc:creator><![CDATA[jugal]]></dc:creator>
		<pubDate>Thu, 12 Jun 2014 17:00:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-38339</guid>
		<description><![CDATA[@venki   : I have a soution with O(n) time complexity.
We can do it with doubly link list and need to maintain it sorted  and maintain one boolean flag to keep track of even or odd number of elements in to the list. 
flag = 0 means even entries and 1 for odd entries.



Algorithm
a) insert new element in to the list at appropriate location.
b) We know the previous median
flag = ~flag

if (flag == 0)
{
    if(address_previous_median &#060; new_element)
    {
         new_median = (address_previous_median + next_element) / 2;
         strore these two addresses in variable
    }
    else
    {
         new_median = (address_previous_median + previous_element) / 2;
         strore these two addresses in variable
    }
}
else
{
    //do same as above but take care if new element is inserted in between two median.
}


plz give your feedback whether i m right or wrong. According to me it&#039;s time complexity is O(n). In the below comment i have uploaded my code and it&#039;s working fine.]]></description>
		<content:encoded><![CDATA[<p>@venki   : I have a soution with O(n) time complexity.<br />
We can do it with doubly link list and need to maintain it sorted  and maintain one boolean flag to keep track of even or odd number of elements in to the list.<br />
flag = 0 means even entries and 1 for odd entries.</p>
<p>Algorithm<br />
a) insert new element in to the list at appropriate location.<br />
b) We know the previous median<br />
flag = ~flag</p>
<p>if (flag == 0)<br />
{<br />
    if(address_previous_median &lt; new_element)<br />
    {<br />
         new_median = (address_previous_median + next_element) / 2;<br />
         strore these two addresses in variable<br />
    }<br />
    else<br />
    {<br />
         new_median = (address_previous_median + previous_element) / 2;<br />
         strore these two addresses in variable<br />
    }<br />
}<br />
else<br />
{<br />
    //do same as above but take care if new element is inserted in between two median.<br />
}</p>
<p>plz give your feedback whether i m right or wrong. According to me it&#039;s time complexity is O(n). In the below comment i have uploaded my code and it&#039;s working fine.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: alien</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-33063</link>
		<dc:creator><![CDATA[alien]]></dc:creator>
		<pubDate>Thu, 27 Feb 2014 23:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-33063</guid>
		<description><![CDATA[awesome algorithm.. can it be done inplace with some other algorithm?]]></description>
		<content:encoded><![CDATA[<p>awesome algorithm.. can it be done inplace with some other algorithm?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Neha</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-27053</link>
		<dc:creator><![CDATA[Neha]]></dc:creator>
		<pubDate>Wed, 28 Aug 2013 03:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-27053</guid>
		<description><![CDATA[IMO that sol doesn&#039;t handle the constraint that it is a dynamic array, am I missing something?]]></description>
		<content:encoded><![CDATA[<p>IMO that sol doesn&#8217;t handle the constraint that it is a dynamic array, am I missing something?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Neha</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-27054</link>
		<dc:creator><![CDATA[Neha]]></dc:creator>
		<pubDate>Wed, 28 Aug 2013 03:48:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-27054</guid>
		<description><![CDATA[IMO that sol doesn&#039;t handle the constraint that it is a dynamic array, am I missing something?]]></description>
		<content:encoded><![CDATA[<p>IMO that sol doesn&#8217;t handle the constraint that it is a dynamic array, am I missing something?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Anshul Chauhan</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-25896</link>
		<dc:creator><![CDATA[Anshul Chauhan]]></dc:creator>
		<pubDate>Sun, 21 Jul 2013 14:49:32 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-25896</guid>
		<description><![CDATA[Its a running stream of integers...you can&#039;t apply quick select if you have to maintain the median in running stream.]]></description>
		<content:encoded><![CDATA[<p>Its a running stream of integers&#8230;you can&#039;t apply quick select if you have to maintain the median in running stream.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Abhishek</title>
		<link>http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/#comment-22138</link>
		<dc:creator><![CDATA[Abhishek]]></dc:creator>
		<pubDate>Sun, 14 Jul 2013 13:53:30 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=14873#comment-22138</guid>
		<description><![CDATA[Look carefully Initially when only 3 elements have been added to the heaps, the median is not 97 as u mentioned. It is 94. So when 96 comes it needs to be added to the min heap. After this operation the median will become 95.]]></description>
		<content:encoded><![CDATA[<p>Look carefully Initially when only 3 elements have been added to the heaps, the median is not 97 as u mentioned. It is 94. So when 96 comes it needs to be added to the min heap. After this operation the median will become 95.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.046 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 14:13:59 -->

<!-- Compression = gzip -->