<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Find the maximum element in an array which is first increasing and then decreasing</title>
	<atom:link href="http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/</link>
	<description>A computer science portal for geeks</description>
	<lastBuildDate>Tue, 17 Nov 2015 05:17:31 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.8</generator>
	<item>
		<title>By: Goku</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-39785</link>
		<dc:creator><![CDATA[Goku]]></dc:creator>
		<pubDate>Wed, 25 Jun 2014 12:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-39785</guid>
		<description><![CDATA[Array is first increasing and then decreasing.Your test case doesn&#039;t follow it.]]></description>
		<content:encoded><![CDATA[<p>Array is first increasing and then decreasing.Your test case doesn&#8217;t follow it.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: wrestler</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-38044</link>
		<dc:creator><![CDATA[wrestler]]></dc:creator>
		<pubDate>Tue, 10 Jun 2014 01:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-38044</guid>
		<description><![CDATA[You are passing the same value of n everytime so this will not work.]]></description>
		<content:encoded><![CDATA[<p>You are passing the same value of n everytime so this will not work.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-37787</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 21:29:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-37787</guid>
		<description><![CDATA[This work for duplicates too....


int maxinde(int a[],int n)

{

    int i=0,j=n-1;

    while(ia[j])

            j--;

        else if(a[i]&#060;a[j])

            i++;      

        else

        {

            i++;j--;

        }

        

    }

     return a[i]; 

}]]></description>
		<content:encoded><![CDATA[<p>This work for duplicates too&#8230;.</p>
<p>int maxinde(int a[],int n)</p>
<p>{</p>
<p>    int i=0,j=n-1;</p>
<p>    while(ia[j])</p>
<p>            j&#8211;;</p>
<p>        else if(a[i]&lt;a[j])</p>
<p>            i++;      </p>
<p>        else</p>
<p>        {</p>
<p>            i++;j&#8211;;</p>
<p>        }</p>
<p>    }</p>
<p>     return a[i]; </p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-37785</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 21:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-37785</guid>
		<description><![CDATA[Here is the solution to handle duplicates....

int maxinde(int a[],int n)

{

    int i=0,j=n-1;

    while(ia[j])

            j--;

        else if(a[i]&#060;a[j])

            i++;      

        else

        {

            i++;j--;

        }

        

    }

     return a[i]; 

}]]></description>
		<content:encoded><![CDATA[<p>Here is the solution to handle duplicates&#8230;.</p>
<p>int maxinde(int a[],int n)</p>
<p>{</p>
<p>    int i=0,j=n-1;</p>
<p>    while(ia[j])</p>
<p>            j&#8211;;</p>
<p>        else if(a[i]&lt;a[j])</p>
<p>            i++;      </p>
<p>        else</p>
<p>        {</p>
<p>            i++;j&#8211;;</p>
<p>        }</p>
<p>    }</p>
<p>     return a[i]; </p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: danny</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-37786</link>
		<dc:creator><![CDATA[danny]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 21:26:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-37786</guid>
		<description><![CDATA[Another approach better then first but not so better then second method..

int maxinde(int a[],int n)

{

    int i=0,j=n-1;

    while(ia[j])

            j--;

        else if(a[i]&#060;a[j])

            i++;      

        else

        {

            i++;j--;

        }

        

    }

     return a[i]; 

}]]></description>
		<content:encoded><![CDATA[<p>Another approach better then first but not so better then second method..</p>
<p>int maxinde(int a[],int n)</p>
<p>{</p>
<p>    int i=0,j=n-1;</p>
<p>    while(ia[j])</p>
<p>            j&#8211;;</p>
<p>        else if(a[i]&lt;a[j])</p>
<p>            i++;      </p>
<p>        else</p>
<p>        {</p>
<p>            i++;j&#8211;;</p>
<p>        }</p>
<p>    }</p>
<p>     return a[i]; </p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-37784</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 21:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-37784</guid>
		<description><![CDATA[Here is the solution to handle duplicates...

int maxinde(int a[],int n)

{

    int i=0,j=n-1;

    while(ia[j])

            j--;

        else if(a[i]&#060;a[j])

            i++;      

     }

     return a[i]; 

}]]></description>
		<content:encoded><![CDATA[<p>Here is the solution to handle duplicates&#8230;</p>
<p>int maxinde(int a[],int n)</p>
<p>{</p>
<p>    int i=0,j=n-1;</p>
<p>    while(ia[j])</p>
<p>            j&#8211;;</p>
<p>        else if(a[i]&lt;a[j])</p>
<p>            i++;      </p>
<p>     }</p>
<p>     return a[i]; </p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guest</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-37783</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Fri, 06 Jun 2014 21:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-37783</guid>
		<description><![CDATA[Another approach better then first but not so better then second method...

Function:

int maxinde(int a[],int n)

{

int i=0,j=n-1;

while(ia[j])

j--;

else if(a[i]&#060;a[j])

i++; 

}

return a[i]; 

}]]></description>
		<content:encoded><![CDATA[<p>Another approach better then first but not so better then second method&#8230;</p>
<p>Function:</p>
<p>int maxinde(int a[],int n)</p>
<p>{</p>
<p>int i=0,j=n-1;</p>
<p>while(ia[j])</p>
<p>j&#8211;;</p>
<p>else if(a[i]&lt;a[j])</p>
<p>i++; </p>
<p>}</p>
<p>return a[i]; </p>
<p>}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: meh</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-33999</link>
		<dc:creator><![CDATA[meh]]></dc:creator>
		<pubDate>Sat, 29 Mar 2014 03:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-33999</guid>
		<description><![CDATA[I believe this doesn&#039;t handle the case when array has duplicated elements, right?


For example: { 4, 4, 4, 4, 5 } or { 5, 4, 4, 4, 4 }


There&#039;s no way to know which side to choose when splitting the problem based on mid index.]]></description>
		<content:encoded><![CDATA[<p>I believe this doesn&#8217;t handle the case when array has duplicated elements, right?</p>
<p>For example: { 4, 4, 4, 4, 5 } or { 5, 4, 4, 4, 4 }</p>
<p>There&#8217;s no way to know which side to choose when splitting the problem based on mid index.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Priyam ExtinctBird Dhanuka</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-26631</link>
		<dc:creator><![CDATA[Priyam ExtinctBird Dhanuka]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 13:04:43 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-26631</guid>
		<description><![CDATA[Why cant we just do this and reduce the number of   if&#039;s everytime we recurse.
Another argument n is passed which is nothing but size of the array.

int BinSearch(int *a, int low, int high, int n).
{
	int mid;
	mid=(low+high)/2;
	if(mid==n-1&#124;&#124;mid==0)
		return mid;
	if(a[mid-1]&#060;a[mid]&#038;&#038;a[mid]&#062;a[mid+1])
		return mid;
	else
	if(a[mid-1]&#060;a[mid]&#038;&#038;a[mid]&#060;a[mid+1])
		return BinSearch(a, mid+1, high, n);
	else
	if(a[mid-1]&#062;a[mid]&#038;&#038;a[mid]&#062;a[mid+1])
		return BinSearch(a, low, mid-1, n);
}]]></description>
		<content:encoded><![CDATA[<p>Why cant we just do this and reduce the number of   if&#039;s everytime we recurse.<br />
Another argument n is passed which is nothing but size of the array.</p>
<p>int BinSearch(int *a, int low, int high, int n).<br />
{<br />
	int mid;<br />
	mid=(low+high)/2;<br />
	if(mid==n-1||mid==0)<br />
		return mid;<br />
	if(a[mid-1]&lt;a[mid]&amp;&amp;a[mid]&gt;a[mid+1])<br />
		return mid;<br />
	else<br />
	if(a[mid-1]&lt;a[mid]&amp;&amp;a[mid]&lt;a[mid+1])<br />
		return BinSearch(a, mid+1, high, n);<br />
	else<br />
	if(a[mid-1]&gt;a[mid]&amp;&amp;a[mid]&gt;a[mid+1])<br />
		return BinSearch(a, low, mid-1, n);<br />
}</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: pd60193</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-26630</link>
		<dc:creator><![CDATA[pd60193]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 13:03:14 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-26630</guid>
		<description><![CDATA[Why cant we just do this and reduce the number of   if&#039;s everytime we recurse.
Another argument n is passed which is nothing but size of the array.
&lt;pre&gt; &lt;code language=&quot;C&quot;&gt;


int BinSearch(int *a,int low,int high,int n)
{
	int mid;
	mid=(low+high)/2;
	if(mid==n-1&#124;&#124;mid==0)
		return mid;
	if(a[mid-1]&#060;a[mid]&#038;&#038;a[mid]&#062;a[mid+1])
		return mid;
	else
	if(a[mid-1]&#060;a[mid]&#038;&#038;a[mid]&#060;a[mid+1])
		return BinSearch(a,mid+1,high,n);
	else
	if(a[mid-1]&#062;a[mid]&#038;&#038;a[mid]&#062;a[mid+1])
		return BinSearch(a,low,mid-1,n);
}
&lt;/code&gt; &lt;/pre&gt;]]></description>
		<content:encoded><![CDATA[<p>Why cant we just do this and reduce the number of   if&#8217;s everytime we recurse.<br />
Another argument n is passed which is nothing but size of the array.</p>
<pre> <code language="C">


int BinSearch(int *a,int low,int high,int n)
{
	int mid;
	mid=(low+high)/2;
	if(mid==n-1||mid==0)
		return mid;
	if(a[mid-1]&lt;a[mid]&amp;&amp;a[mid]&gt;a[mid+1])
		return mid;
	else
	if(a[mid-1]&lt;a[mid]&amp;&amp;a[mid]&lt;a[mid+1])
		return BinSearch(a,mid+1,high,n);
	else
	if(a[mid-1]&gt;a[mid]&amp;&amp;a[mid]&gt;a[mid+1])
		return BinSearch(a,low,mid-1,n);
}
</code> </pre>
]]></content:encoded>
	</item>
	<item>
		<title>By: Ravisoni1776</title>
		<link>http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/#comment-23031</link>
		<dc:creator><![CDATA[Ravisoni1776]]></dc:creator>
		<pubDate>Wed, 31 Jul 2013 20:22:26 +0000</pubDate>
		<guid isPermaLink="false">http://www.cdn.geeksforgeeks.org/?p=17028#comment-23031</guid>
		<description><![CDATA[for arr[] = {1, 3, 50, 10, 12, 7, 6} program will give output 12 instead of 50, right code is:(a small change in GFG program)

#include &lt;stdio.h&gt;

int findMaximum(int arr[], int low, int high)
{
    int a,b;
   /* Base Case: Only one element is present in arr[low..high]*/
   if (low == high)
     return arr[low];

   /* If there are two elements and first is greater then
      the first element is maximum */
   if ((high == low + 1) &amp;&amp; arr[low] &gt;= arr[high])
      return arr[low];

   /* If there are two elements and second is greater then
      the second element is maximum */
   if ((high == low + 1) &amp;&amp; arr[low] &lt; arr[high])
      return arr[high];

   int mid = (low + high)/2;   /*low + (high - low)/2;*/

   /* If we reach a point where arr[mid] is greater than both of
     its adjacent elements arr[mid-1] and arr[mid+1], then arr[mid]
     is the maximum element*/
   if ( arr[mid] &gt; arr[mid + 1] &amp;&amp; arr[mid] &gt; arr[mid - 1])
      return arr[mid];

   /* If arr[mid] is greater than the next element and smaller than the previous
    element then maximum lies on left side of mid */
   if (arr[mid] &gt; arr[mid + 1] &amp;&amp; arr[mid] &lt; arr[mid - 1])
     return findMaximum(arr, low, mid-1);
     // **if arr[mid] is less than both previous and next element in array
    if (arr[mid] &lt; arr[mid + 1] &amp;&amp; arr[mid] &lt; arr[mid - 1])
    {
        a = findMaximum(arr,low,mid-1);
        b = findMaximum(arr,mid+1,high);
        if(a&gt;b)
        return a;
        else
        return b;
    }
   else // when arr[mid] is greater than arr[mid-1] and smaller than arr[mid+1]
     return findMaximum(arr, mid + 1, high);
}

/* Driver program to check above functions */
int main()
{
   int arr[] = {1, 3, 50, 10, 12, 7, 6};
   int n = sizeof(arr)/sizeof(arr[0]);
   printf(&quot;The maximum element is %d&quot;, findMaximum(arr, 0, n-1));
   getchar();
   return 0;
}]]></description>
		<content:encoded><![CDATA[<p>for arr[] = {1, 3, 50, 10, 12, 7, 6} program will give output 12 instead of 50, right code is:(a small change in GFG program)</p>
<p>#include <stdio .h></p>
<p>int findMaximum(int arr[], int low, int high)<br />
{<br />
    int a,b;<br />
   /* Base Case: Only one element is present in arr[low..high]*/<br />
   if (low == high)<br />
     return arr[low];</p>
<p>   /* If there are two elements and first is greater then<br />
      the first element is maximum */<br />
   if ((high == low + 1) &#038;&#038; arr[low] >= arr[high])<br />
      return arr[low];</p>
<p>   /* If there are two elements and second is greater then<br />
      the second element is maximum */<br />
   if ((high == low + 1) &#038;&#038; arr[low] < arr[high])
      return arr[high];

   int mid = (low + high)/2;   /*low + (high - low)/2;*/

   /* If we reach a point where arr[mid] is greater than both of
     its adjacent elements arr[mid-1] and arr[mid+1], then arr[mid]
     is the maximum element*/
   if ( arr[mid] > arr[mid + 1] &#038;&#038; arr[mid] > arr[mid &#8211; 1])<br />
      return arr[mid];</p>
<p>   /* If arr[mid] is greater than the next element and smaller than the previous<br />
    element then maximum lies on left side of mid */<br />
   if (arr[mid] > arr[mid + 1] &#038;&#038; arr[mid] < arr[mid - 1])
     return findMaximum(arr, low, mid-1);
     // **if arr[mid] is less than both previous and next element in array
    if (arr[mid] < arr[mid + 1] &#038;&#038; arr[mid] < arr[mid - 1])
    {
        a = findMaximum(arr,low,mid-1);
        b = findMaximum(arr,mid+1,high);
        if(a>b)<br />
        return a;<br />
        else<br />
        return b;<br />
    }<br />
   else // when arr[mid] is greater than arr[mid-1] and smaller than arr[mid+1]<br />
     return findMaximum(arr, mid + 1, high);<br />
}</p>
<p>/* Driver program to check above functions */<br />
int main()<br />
{<br />
   int arr[] = {1, 3, 50, 10, 12, 7, 6};<br />
   int n = sizeof(arr)/sizeof(arr[0]);<br />
   printf(&#8220;The maximum element is %d&#8221;, findMaximum(arr, 0, n-1));<br />
   getchar();<br />
   return 0;<br />
}</stdio></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Dynamic page generated in 0.094 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-11-24 13:24:50 -->

<!-- Compression = gzip -->