<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Top 5 Questions about C/C++ Pointers</title>
	<atom:link href="http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: allen_lxbs</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-7442</link>
		<dc:creator><![CDATA[allen_lxbs]]></dc:creator>
		<pubDate>Tue, 29 Sep 2015 07:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-7442</guid>
		<description><![CDATA[haha , i know all of them .]]></description>
		<content:encoded><![CDATA[<p>haha , i know all of them .</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Hariom Yadav</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-5657</link>
		<dc:creator><![CDATA[Hariom Yadav]]></dc:creator>
		<pubDate>Tue, 08 Apr 2014 08:59:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-5657</guid>
		<description><![CDATA[i need some more questions..]]></description>
		<content:encoded><![CDATA[<p>i need some more questions..</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Rob Desbois</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-5094</link>
		<dc:creator><![CDATA[Rob Desbois]]></dc:creator>
		<pubDate>Tue, 01 Oct 2013 08:39:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-5094</guid>
		<description><![CDATA[&#062;  Why is this code a invalid answer? gcc compile it just fine and it gets the job done. What else do you expect?
Just because code compiles doesn&#039;t mean it&#039;s valid. There is plenty of code that will compile but yields undefined behaviour - calling main from within your code is explicitly disallowed by the standard.
The answer is invalid C++ because it calls main directly, and because it relies on j being 1, which isn&#039;t guaranteed. In other words, in different scenarios this code could: work perfectly; count from 10 to 1000; count from 1001 to 1000...the long way around; loop infinitely (due to calling main); call terminate(); explode in a fireball and cause your computer to meltdown. Ok that last one is less likely ;-) but the point is the behaviour is not specified, so the code is potentially unreliable and unportable

&#062; You are right &#039;void main(int)&#039; is not valid, but &#039;int main(int)&#039; is.  It
 is implementation defined according to C standard 5.1.2.2.1; C++ 
standard 3.6.1.  The two you mentioned are required to be implemented in
 addition to whatever the compiler want to support.
You&#039;re right too, I must&#039;ve missed that sentence. 

&#062; Knowing [How many levels of pointers we can have] does not help anything except for the compiler/ tool writer.
Perhaps not, but  it&#039;s the answer to the question. Your answer is accurate, but not precise. If I were asking the question then I would expect the answer to give the exact number is. Of course few, if any, C++ developers will find this to be a practical limitation, but that doesn&#039;t stop it from being the precise answer to the question.]]></description>
		<content:encoded><![CDATA[<p>&gt;  Why is this code a invalid answer? gcc compile it just fine and it gets the job done. What else do you expect?<br />
Just because code compiles doesn&#8217;t mean it&#8217;s valid. There is plenty of code that will compile but yields undefined behaviour &#8211; calling main from within your code is explicitly disallowed by the standard.<br />
The answer is invalid C++ because it calls main directly, and because it relies on j being 1, which isn&#8217;t guaranteed. In other words, in different scenarios this code could: work perfectly; count from 10 to 1000; count from 1001 to 1000&#8230;the long way around; loop infinitely (due to calling main); call terminate(); explode in a fireball and cause your computer to meltdown. Ok that last one is less likely ðŸ˜‰ but the point is the behaviour is not specified, so the code is potentially unreliable and unportable</p>
<p>&gt; You are right &#8216;void main(int)&#8217; is not valid, but &#8216;int main(int)&#8217; is.  It<br />
 is implementation defined according to C standard 5.1.2.2.1; C++<br />
standard 3.6.1.  The two you mentioned are required to be implemented in<br />
 addition to whatever the compiler want to support.<br />
You&#8217;re right too, I must&#8217;ve missed that sentence. </p>
<p>&gt; Knowing [How many levels of pointers we can have] does not help anything except for the compiler/ tool writer.<br />
Perhaps not, but  it&#8217;s the answer to the question. Your answer is accurate, but not precise. If I were asking the question then I would expect the answer to give the exact number is. Of course few, if any, C++ developers will find this to be a practical limitation, but that doesn&#8217;t stop it from being the precise answer to the question.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: yuanfang</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-5088</link>
		<dc:creator><![CDATA[yuanfang]]></dc:creator>
		<pubDate>Mon, 30 Sep 2013 17:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-5088</guid>
		<description><![CDATA[That&#039;s sum from 1 to 1000, isn&#039;t it?]]></description>
		<content:encoded><![CDATA[<p>That&#8217;s sum from 1 to 1000, isn&#8217;t it?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: yuanfang</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-5087</link>
		<dc:creator><![CDATA[yuanfang]]></dc:creator>
		<pubDate>Mon, 30 Sep 2013 17:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-5087</guid>
		<description><![CDATA[*You are right. Some of my wording is not rigorous and precise. &quot;Top 5 Questions about C/C++ Pointers&quot; maybe a better name.

Wow, in what world is &quot;Count from 1 to 1000 without using loops&quot; a top question about C++ pointers? It&#039;s not a question about pointers at all. The way to achieve it is, as you say, recursion, which is also unrelated to pointers. The only link between the question and pointers is a bizarrely contrived and invalid answer.

*The question is not about pointers, but the implementation somehow is. At lease, temporal function pointers and pointer arithmetic are used.  Of course recursion is not about pointer, but its implementation could be.  Why is this code a invalid answer? gcc compile it just fine and it gets the job done. What else do you expect?

Stating something is true &quot;according to C language&quot; and then assuming it is valid for C++ is a risky business: it may or may not be true, as C++ is not a superset of
C. Your assertion that it is true in C is incorrect: generally speaking (j == 1) will be true if the program was invoked without arguments, however the standard does allow this argument to be 0.
The signature of your main() function is not a valid one; the only standard-supported signatures are int(void) and int(int, char*[]).

*You are right &#039;void main(int)&#039; is not valid, but &#039;int main(int)&#039; is.  It is implementation defined according to C standard 5.1.2.2.1; C++ standard 3.6.1.  The two you mentioned are required to be implemented in addition to whatever the compiler want to support. 

Most importantly though: the standard requires that &#039;the function main shall not be used within a program&#039;, which makes the recursive calling of it undefined behaviour.


*Good to know. I&#039;ll look into that. 

Just to add to your answer to question 3: the [C++11] standard sets the minimum-acceptable support for number of pointer, array and function declarators modifying a type at 256.


*Knowing that does not help anything except for the compiler/ tool writer.

Your answer to question 4 again refers to the C language.]]></description>
		<content:encoded><![CDATA[<p>*You are right. Some of my wording is not rigorous and precise. &#8220;Top 5 Questions about C/C++ Pointers&#8221; maybe a better name.</p>
<p>Wow, in what world is &#8220;Count from 1 to 1000 without using loops&#8221; a top question about C++ pointers? It&#8217;s not a question about pointers at all. The way to achieve it is, as you say, recursion, which is also unrelated to pointers. The only link between the question and pointers is a bizarrely contrived and invalid answer.</p>
<p>*The question is not about pointers, but the implementation somehow is. At lease, temporal function pointers and pointer arithmetic are used.  Of course recursion is not about pointer, but its implementation could be.  Why is this code a invalid answer? gcc compile it just fine and it gets the job done. What else do you expect?</p>
<p>Stating something is true &#8220;according to C language&#8221; and then assuming it is valid for C++ is a risky business: it may or may not be true, as C++ is not a superset of<br />
C. Your assertion that it is true in C is incorrect: generally speaking (j == 1) will be true if the program was invoked without arguments, however the standard does allow this argument to be 0.<br />
The signature of your main() function is not a valid one; the only standard-supported signatures are int(void) and int(int, char*[]).</p>
<p>*You are right &#8216;void main(int)&#8217; is not valid, but &#8216;int main(int)&#8217; is.  It is implementation defined according to C standard 5.1.2.2.1; C++ standard 3.6.1.  The two you mentioned are required to be implemented in addition to whatever the compiler want to support. </p>
<p>Most importantly though: the standard requires that &#8216;the function main shall not be used within a program&#8217;, which makes the recursive calling of it undefined behaviour.</p>
<p>*Good to know. I&#8217;ll look into that. </p>
<p>Just to add to your answer to question 3: the [C++11] standard sets the minimum-acceptable support for number of pointer, array and function declarators modifying a type at 256.</p>
<p>*Knowing that does not help anything except for the compiler/ tool writer.</p>
<p>Your answer to question 4 again refers to the C language.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Michael</title>
		<link>http://www.programcreek.com/2013/09/top-5-questions-about-c-pointers/#comment-5086</link>
		<dc:creator><![CDATA[Michael]]></dc:creator>
		<pubDate>Mon, 30 Sep 2013 16:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=9399#comment-5086</guid>
		<description><![CDATA[Count from 1 to 1000 without using loops
RIGHT answer:
return (1+1000)*1000/2;
(no loops, no recursion, no tricky and unreadable code, just rule we all learnt in elementary school)]]></description>
		<content:encoded><![CDATA[<p>Count from 1 to 1000 without using loops<br />
RIGHT answer:<br />
return (1+1000)*1000/2;<br />
(no loops, no recursion, no tricky and unreadable code, just rule we all learnt in elementary school)</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->