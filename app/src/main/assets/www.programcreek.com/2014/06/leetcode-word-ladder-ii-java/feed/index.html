<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: LeetCode &#8211; Word Ladder II (Java)</title>
	<atom:link href="http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: Prabhat Meghwal</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-14912</link>
		<dc:creator><![CDATA[Prabhat Meghwal]]></dc:creator>
		<pubDate>Sun, 02 Oct 2016 11:51:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-14912</guid>
		<description><![CDATA[&quot;BSF&quot; Really :O]]></description>
		<content:encoded><![CDATA[<p>&#8220;BSF&#8221; Really :O</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Matias SM</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-10048</link>
		<dc:creator><![CDATA[Matias SM]]></dc:creator>
		<pubDate>Sat, 02 Apr 2016 23:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-10048</guid>
		<description><![CDATA[I don&#039;t understand why would you need to keep the words in the dictionary (instead of deleting them right away, like in the previous case). If you reach a word again, it means that the result will be necessarily of a longer distance, so it can&#039;t be in the shortest path. For the case of the end word, a simple validation when removing the word from the dict, will do the trick (or a different approach than having it in the dict).

I believe you should keep processing to get all the shortest path solutions, but filtering should be done at the WordNode level. That is: once you find the shortest distance, you don&#039;t process nodes with greater distance than that. Also, because of the way the &quot;graph&quot; is generated in this case, you know that nodes are queued in increasing distance order, so you can stop processing once the best distance is passed.]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t understand why would you need to keep the words in the dictionary (instead of deleting them right away, like in the previous case). If you reach a word again, it means that the result will be necessarily of a longer distance, so it can&#8217;t be in the shortest path. For the case of the end word, a simple validation when removing the word from the dict, will do the trick (or a different approach than having it in the dict).</p>
<p>I believe you should keep processing to get all the shortest path solutions, but filtering should be done at the WordNode level. That is: once you find the shortest distance, you don&#8217;t process nodes with greater distance than that. Also, because of the way the &#8220;graph&#8221; is generated in this case, you know that nodes are queued in increasing distance order, so you can stop processing once the best distance is passed.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prakash</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-8642</link>
		<dc:creator><![CDATA[Prakash]]></dc:creator>
		<pubDate>Mon, 25 Jan 2016 18:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-8642</guid>
		<description><![CDATA[No, You are thinking it in with 1 example only .
Code is correct on single Iteration of nested loop it will create all possible Threads for LinkedList.
Each thread will return the different path once word match is found.
Array List will hold all possible path.]]></description>
		<content:encoded><![CDATA[<p>No, You are thinking it in with 1 example only .<br />
Code is correct on single Iteration of nested loop it will create all possible Threads for LinkedList.<br />
Each thread will return the different path once word match is found.<br />
Array List will hold all possible path.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Mohamed Hassan</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-7706</link>
		<dc:creator><![CDATA[Mohamed Hassan]]></dc:creator>
		<pubDate>Thu, 10 Dec 2015 15:31:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-7706</guid>
		<description><![CDATA[you must remove used elements to avoid loops]]></description>
		<content:encoded><![CDATA[<p>you must remove used elements to avoid loops</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Billionaire</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-7617</link>
		<dc:creator><![CDATA[Billionaire]]></dc:creator>
		<pubDate>Sun, 22 Nov 2015 04:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-7617</guid>
		<description><![CDATA[Why remove used elements from hashset can boost performance? Isn&#039;t that hashset is O(1) time complexity?]]></description>
		<content:encoded><![CDATA[<p>Why remove used elements from hashset can boost performance? Isn&#8217;t that hashset is O(1) time complexity?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Jayesh</title>
		<link>http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/#comment-7505</link>
		<dc:creator><![CDATA[Jayesh]]></dc:creator>
		<pubDate>Mon, 19 Oct 2015 06:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14550#comment-7505</guid>
		<description><![CDATA[If anyone interested for both BFS and DFS approach for finding Word Ladder: 

http://javabypatel.blogspot.in/2015/10/word-ladder-doublets-word-links-word-golf.html]]></description>
		<content:encoded><![CDATA[<p>If anyone interested for both BFS and DFS approach for finding Word Ladder: </p>
<p><a href="http://javabypatel.blogspot.in/2015/10/word-ladder-doublets-word-links-word-golf.html" rel="nofollow">http://javabypatel.blogspot.in/2015/10/word-ladder-doublets-word-links-word-golf.html</a></p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->