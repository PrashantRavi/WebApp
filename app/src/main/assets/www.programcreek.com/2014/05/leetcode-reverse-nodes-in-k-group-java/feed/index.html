<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: LeetCode &#8211; Reverse Nodes in k-Group (Java)</title>
	<atom:link href="http://www.programcreek.com/2014/05/leetcode-reverse-nodes-in-k-group-java/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2014/05/leetcode-reverse-nodes-in-k-group-java/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: SG</title>
		<link>http://www.programcreek.com/2014/05/leetcode-reverse-nodes-in-k-group-java/#comment-15040</link>
		<dc:creator><![CDATA[SG]]></dc:creator>
		<pubDate>Thu, 06 Oct 2016 01:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=15434#comment-15040</guid>
		<description><![CDATA[Reverse K group using stack.    

public void reverseKGroup(int k){        
        Stack tempStack = new Stack();
        Node current = root;
        Node previous = null; 
        int i = 0;
        while(current != null){
            if(i!=0 &#038;&#038; i%k == 0){
                Node curr = tempStack.pop();      
                if(i==k){
                    root = curr; 
                }else{
                    previous.next = curr; 
                }
                while(!tempStack.empty()){
                    Node n = tempStack.pop();
                    curr.next = n;
                    curr = n;                   
                }
                curr.next = current;
                previous = curr;
            }
            tempStack.push(current);
            current = current.next; 
            i++;
        } 
        
        if(i%k == 0){
            Node curr = tempStack.pop();                  
            previous.next = curr; 
            while(!tempStack.empty()){
                Node n = tempStack.pop();
                curr.next = n;
                curr = n;                   
            }
            curr.next = current;
            previous = curr;
        }
    }]]></description>
		<content:encoded><![CDATA[<p>Reverse K group using stack.    </p>
<p>public void reverseKGroup(int k){<br />
        Stack tempStack = new Stack();<br />
        Node current = root;<br />
        Node previous = null;<br />
        int i = 0;<br />
        while(current != null){<br />
            if(i!=0 &amp;&amp; i%k == 0){<br />
                Node curr = tempStack.pop();<br />
                if(i==k){<br />
                    root = curr;<br />
                }else{<br />
                    previous.next = curr;<br />
                }<br />
                while(!tempStack.empty()){<br />
                    Node n = tempStack.pop();<br />
                    curr.next = n;<br />
                    curr = n;<br />
                }<br />
                curr.next = current;<br />
                previous = curr;<br />
            }<br />
            tempStack.push(current);<br />
            current = current.next;<br />
            i++;<br />
        } </p>
<p>        if(i%k == 0){<br />
            Node curr = tempStack.pop();<br />
            previous.next = curr;<br />
            while(!tempStack.empty()){<br />
                Node n = tempStack.pop();<br />
                curr.next = n;<br />
                curr = n;<br />
            }<br />
            curr.next = current;<br />
            previous = curr;<br />
        }<br />
    }</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->