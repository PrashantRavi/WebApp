<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: LeetCode &#8211; Minimum Window Substring (Java)</title>
	<atom:link href="http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: Larry Okeke</title>
		<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/#comment-9873</link>
		<dc:creator><![CDATA[Larry Okeke]]></dc:creator>
		<pubDate>Mon, 21 Mar 2016 09:58:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14229#comment-9873</guid>
		<description><![CDATA[This runs in O(n log n). but the idea is easier to understand.

count through word till you&#039;ve gotten all the characters in your target substring, and then compare  the length to last  result.



&lt;code&gt;

import java.util.*;

public class shortest_window{

	public static void main(String[] args){

		String word = &quot;ADOBECODEBANC&quot;;

		String target = &quot;ABC&quot;;

		System.out.println(solution(word, target));

	}

	public static String solution(String word, String targ){

		if(word==null &#124;&#124; word.length() &#060; 1 ) return &#034;&#034;;

		if(targ==null &#124;&#124; targ.length() &#060; 1) return &#034;&#034;;

 		

 		char arr = new targ.toCharArray(); 

		String shortest = word;

		for(int i =0; i &#060; word.length(); i++){

			String temp = &#034;&#034;;

			ArrayList target = new ArrayList();

			for(Character c: arr){

				target.add((Character)c);

			}

			for(int j = i; j  temp.length()) shortest = temp;

					break;

				} 

			}

}	

			return shortest;

		}

	}

&lt;/code&gt;
]]></description>
		<content:encoded><![CDATA[<p>This runs in O(n log n). but the idea is easier to understand.</p>
<p>count through word till you&#8217;ve gotten all the characters in your target substring, and then compare  the length to last  result.</p>
<p><code></p>
<p>import java.util.*;</p>
<p>public class shortest_window{</p>
<p>	public static void main(String[] args){</p>
<p>		String word = "ADOBECODEBANC";</p>
<p>		String target = "ABC";</p>
<p>		System.out.println(solution(word, target));</p>
<p>	}</p>
<p>	public static String solution(String word, String targ){</p>
<p>		if(word==null || word.length() &lt; 1 ) return &quot;&quot;;</p>
<p>		if(targ==null || targ.length() &lt; 1) return &quot;&quot;;</p>
<p> 		char arr = new targ.toCharArray(); </p>
<p>		String shortest = word;</p>
<p>		for(int i =0; i &lt; word.length(); i++){</p>
<p>			String temp = &quot;&quot;;</p>
<p>			ArrayList target = new ArrayList();</p>
<p>			for(Character c: arr){</p>
<p>				target.add((Character)c);</p>
<p>			}</p>
<p>			for(int j = i; j  temp.length()) shortest = temp;</p>
<p>					break;</p>
<p>				} </p>
<p>			}</p>
<p>}	</p>
<p>			return shortest;</p>
<p>		}</p>
<p>	}</p>
<p></code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Renzo</title>
		<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/#comment-9136</link>
		<dc:creator><![CDATA[Renzo]]></dc:creator>
		<pubDate>Thu, 18 Feb 2016 14:40:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14229#comment-9136</guid>
		<description><![CDATA[Python Solution: https://github.com/renzon/code_interview_training/blob/master/min_str_window.py]]></description>
		<content:encoded><![CDATA[<p>Python Solution: <a href="https://github.com/renzon/code_interview_training/blob/master/min_str_window.py" rel="nofollow">https://github.com/renzon/code_interview_training/blob/master/min_str_window.py</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: gao can</title>
		<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/#comment-8839</link>
		<dc:creator><![CDATA[gao can]]></dc:creator>
		<pubDate>Mon, 01 Feb 2016 22:13:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14229#comment-8839</guid>
		<description><![CDATA[No, it doesn&#039;t need to do it. Although it is a good idea to decrease count by 1. Then taking one character out of the map and increase left by 1.
S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;.
Think about this case, first we find &quot;ADOBEC&quot; then when count == t.length(), left is A since we can not drop any of character then we move left to D and move A from map and count--. This is the method that you talk about.
But we can keep count as 3 and without moving left, we still move i to next A,
then it becomes &quot;ADOBECODEBA&quot;, here count == 3 == t.length(), but now we can move left from the first A to C, it becomes &quot;CODEBA&quot;.
See, that is the reason we don&#039;t need to decrease count by 1.]]></description>
		<content:encoded><![CDATA[<p>No, it doesn&#8217;t need to do it. Although it is a good idea to decrease count by 1. Then taking one character out of the map and increase left by 1.<br />
S = &#8220;ADOBECODEBANC&#8221;, T = &#8220;ABC&#8221;.<br />
Think about this case, first we find &#8220;ADOBEC&#8221; then when count == t.length(), left is A since we can not drop any of character then we move left to D and move A from map and count&#8211;. This is the method that you talk about.<br />
But we can keep count as 3 and without moving left, we still move i to next A,<br />
then it becomes &#8220;ADOBECODEBA&#8221;, here count == 3 == t.length(), but now we can move left from the first A to C, it becomes &#8220;CODEBA&#8221;.<br />
See, that is the reason we don&#8217;t need to decrease count by 1.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Kyle</title>
		<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/#comment-7455</link>
		<dc:creator><![CDATA[Kyle]]></dc:creator>
		<pubDate>Mon, 05 Oct 2015 06:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14229#comment-7455</guid>
		<description><![CDATA[You&#039;re right. :)]]></description>
		<content:encoded><![CDATA[<p>You&#8217;re right. ðŸ™‚</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Nand Jha</title>
		<link>http://www.programcreek.com/2014/05/leetcode-minimum-window-substring-java/#comment-7268</link>
		<dc:creator><![CDATA[Nand Jha]]></dc:creator>
		<pubDate>Fri, 07 Aug 2015 20:03:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=14229#comment-7268</guid>
		<description><![CDATA[count == t.length()
After doing the operation when you meet your desired count of characters in T, you need to decrease count by 1 as you are removing character one by one. AT the end when it will find the desired smallest length it would take one character out of the map and hence it should decrease that count by 1 as well.]]></description>
		<content:encoded><![CDATA[<p>count == t.length()<br />
After doing the operation when you meet your desired count of characters in T, you need to decrease count by 1 as you are removing character one by one. AT the end when it will find the desired smallest length it would take one character out of the map and hence it should decrease that count by 1 as well.</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->