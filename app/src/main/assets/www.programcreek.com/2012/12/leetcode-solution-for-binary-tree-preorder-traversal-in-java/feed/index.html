<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: Leetcode &#8211; Binary Tree Preorder Traversal (Java)</title>
	<atom:link href="http://www.programcreek.com/2012/12/leetcode-solution-for-binary-tree-preorder-traversal-in-java/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2012/12/leetcode-solution-for-binary-tree-preorder-traversal-in-java/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: fishwen</title>
		<link>http://www.programcreek.com/2012/12/leetcode-solution-for-binary-tree-preorder-traversal-in-java/#comment-7354</link>
		<dc:creator><![CDATA[fishwen]]></dc:creator>
		<pubDate>Sun, 06 Sep 2015 14:53:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10567#comment-7354</guid>
		<description><![CDATA[http://www.javabeat.net/binary-search-tree-traversal-java/]]></description>
		<content:encoded><![CDATA[<p><a href="http://www.javabeat.net/binary-search-tree-traversal-java/" rel="nofollow">http://www.javabeat.net/binary-search-tree-traversal-java/</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Prabhat Kumar Kashyap</title>
		<link>http://www.programcreek.com/2012/12/leetcode-solution-for-binary-tree-preorder-traversal-in-java/#comment-6576</link>
		<dc:creator><![CDATA[Prabhat Kumar Kashyap]]></dc:creator>
		<pubDate>Sun, 18 Jan 2015 19:50:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10567#comment-6576</guid>
		<description><![CDATA[//Recursive Preorder, Inorder, PostOrder traversals.

import java.util.ArrayList;

import java.util.List;

public class TreeTraversal {

	static List orderedList = new ArrayList();

	public static void preOrderTraversal(TreeNode root){

		if(root == null)

			return;

		orderedList.add(root.val);

		preOrderTraversal(root.left);

		preOrderTraversal(root.right);

	}

	public static void inOrderTraversal(TreeNode root){

		if(root == null)

			return;

		inOrderTraversal(root.left);

		orderedList.add(root.val);

		inOrderTraversal(root.right);

	}

	public static void postOrderTraversal(TreeNode root){

		if(root == null)

			return;

		postOrderTraversal(root.left);

		postOrderTraversal(root.right);

		orderedList.add(root.val);

	}

	public static void main(String[] args) {

		TreeNode root = new TreeNode(2);

		TreeNode left = new TreeNode(1);

		TreeNode right = new TreeNode(3);

		root.left = left;

		root.right = right;

	

		System.out.print(&quot;nPreorder traversal of 2 1 3: &quot;);

		preOrderTraversal(root);

		for(Integer i:orderedList)

			System.out.print(i + &quot; &quot;);

		orderedList.clear();

		System.out.print(&quot;nIneorder traversal of 2 1 3: &quot;);

		inOrderTraversal(root);

		for(Integer i:orderedList)

			System.out.print(i + &quot; &quot;);

		orderedList.clear();

		System.out.print(&quot;nPostorder traversal of 2 1 3: &quot;);

		postOrderTraversal(root);

		for(Integer i:orderedList)

			System.out.print(i + &quot; &quot;);		

	}
}

/*
OUTPUT:
Preorder traversal of 2 1 3: 2 1 3 
Ineorder traversal of 2 1 3: 1 2 3 
Postorder traversal of 2 1 3: 1 3 2 
*/
]]></description>
		<content:encoded><![CDATA[<p>//Recursive Preorder, Inorder, PostOrder traversals.</p>
<p>import java.util.ArrayList;</p>
<p>import java.util.List;</p>
<p>public class TreeTraversal {</p>
<p>	static List orderedList = new ArrayList();</p>
<p>	public static void preOrderTraversal(TreeNode root){</p>
<p>		if(root == null)</p>
<p>			return;</p>
<p>		orderedList.add(root.val);</p>
<p>		preOrderTraversal(root.left);</p>
<p>		preOrderTraversal(root.right);</p>
<p>	}</p>
<p>	public static void inOrderTraversal(TreeNode root){</p>
<p>		if(root == null)</p>
<p>			return;</p>
<p>		inOrderTraversal(root.left);</p>
<p>		orderedList.add(root.val);</p>
<p>		inOrderTraversal(root.right);</p>
<p>	}</p>
<p>	public static void postOrderTraversal(TreeNode root){</p>
<p>		if(root == null)</p>
<p>			return;</p>
<p>		postOrderTraversal(root.left);</p>
<p>		postOrderTraversal(root.right);</p>
<p>		orderedList.add(root.val);</p>
<p>	}</p>
<p>	public static void main(String[] args) {</p>
<p>		TreeNode root = new TreeNode(2);</p>
<p>		TreeNode left = new TreeNode(1);</p>
<p>		TreeNode right = new TreeNode(3);</p>
<p>		root.left = left;</p>
<p>		root.right = right;</p>
<p>		System.out.print(&#8220;nPreorder traversal of 2 1 3: &#8220;);</p>
<p>		preOrderTraversal(root);</p>
<p>		for(Integer i:orderedList)</p>
<p>			System.out.print(i + &#8221; &#8220;);</p>
<p>		orderedList.clear();</p>
<p>		System.out.print(&#8220;nIneorder traversal of 2 1 3: &#8220;);</p>
<p>		inOrderTraversal(root);</p>
<p>		for(Integer i:orderedList)</p>
<p>			System.out.print(i + &#8221; &#8220;);</p>
<p>		orderedList.clear();</p>
<p>		System.out.print(&#8220;nPostorder traversal of 2 1 3: &#8220;);</p>
<p>		postOrderTraversal(root);</p>
<p>		for(Integer i:orderedList)</p>
<p>			System.out.print(i + &#8221; &#8220;);		</p>
<p>	}<br />
}</p>
<p>/*<br />
OUTPUT:<br />
Preorder traversal of 2 1 3: 2 1 3<br />
Ineorder traversal of 2 1 3: 1 2 3<br />
Postorder traversal of 2 1 3: 1 3 2<br />
*/</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: abgalphabet</title>
		<link>http://www.programcreek.com/2012/12/leetcode-solution-for-binary-tree-preorder-traversal-in-java/#comment-5605</link>
		<dc:creator><![CDATA[abgalphabet]]></dc:creator>
		<pubDate>Sun, 16 Mar 2014 05:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10567#comment-5605</guid>
		<description><![CDATA[it would be better to use recursion rather than imperative to solve binary tree traversal.
here is my version.

    private  List traversePreOrder(TreeNode root) {
  if(root == null) return Collections.EMPTY_LIST;

  List ordered = new ArrayList();

  ordered.add(root.value);
  ordered.addAll(traversePreOrder(root.left));
  ordered.addAll(traversePreOrder(root.right));

  return ordered;

    }]]></description>
		<content:encoded><![CDATA[<p>it would be better to use recursion rather than imperative to solve binary tree traversal.<br />
here is my version.</p>
<p>    private  List traversePreOrder(TreeNode root) {<br />
  if(root == null) return Collections.EMPTY_LIST;</p>
<p>  List ordered = new ArrayList();</p>
<p>  ordered.add(root.value);<br />
  ordered.addAll(traversePreOrder(root.left));<br />
  ordered.addAll(traversePreOrder(root.right));</p>
<p>  return ordered;</p>
<p>    }</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->