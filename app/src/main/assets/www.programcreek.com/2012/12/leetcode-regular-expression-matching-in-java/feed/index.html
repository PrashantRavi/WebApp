<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: LeetCode &#8211; Regular Expression Matching in Java</title>
	<atom:link href="http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/</link>
	<description>More Pictures, Less Words</description>
	<lastBuildDate>Fri, 28 Oct 2016 02:57:00 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.5.4</generator>
	<item>
		<title>By: Suresh</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-15448</link>
		<dc:creator><![CDATA[Suresh]]></dc:creator>
		<pubDate>Thu, 20 Oct 2016 08:47:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-15448</guid>
		<description><![CDATA[This was accepted for me...

&lt;code&gt; 
bool isMatch(char *s, char *p) {                                
                                                                
    if (*s == &#039;&#039; &#038;&#038; *p == &#039;&#039;) {                             
        return true;                                            
    }                                                           
                                                                
    if (*(p+1) == &#039;*&#039;) {                                        
                                                                
        char ch = *p;                                           
        int any = 0;                                            
                                                                
        if (isMatch(s, p+2)) return true;                       
                                                                
        while (*(s+any) != &#039;&#039; &#038;&#038;                              
               (*(s+any) == ch &#124;&#124; ch == &#039;.&#039;)) {                 
            if (isMatch(s+any+1, p+2)) return true;             
            any = any + 1;                                      
        }                                                       
        return false;                                           
    }                                                           
                                                                
    if (*s == &#039;&#039; &#124;&#124; *p == &#039;&#039;) {                             
        return false;                                           
    }                                                           
                                                                
    if (*s == *p) {                                             
        if (isMatch(s+1, p+1)) return true;                     
    }                                                           
                                                                
    if (*p == &#039;.&#039;) {                                            
        if (isMatch(s+1, p+1)) return true;                     
    }                                                           
                                                                
    return false;                                               
}                                                               
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>This was accepted for me&#8230;</p>
<p><code><br />
bool isMatch(char *s, char *p) {                                </p>
<p>    if (*s == '' &amp;&amp; *p == '') {<br />
        return true;<br />
    }                                                           </p>
<p>    if (*(p+1) == '*') {                                        </p>
<p>        char ch = *p;<br />
        int any = 0;                                            </p>
<p>        if (isMatch(s, p+2)) return true;                       </p>
<p>        while (*(s+any) != '' &amp;&amp;<br />
               (*(s+any) == ch || ch == '.')) {<br />
            if (isMatch(s+any+1, p+2)) return true;<br />
            any = any + 1;<br />
        }<br />
        return false;<br />
    }                                                           </p>
<p>    if (*s == '' || *p == '') {<br />
        return false;<br />
    }                                                           </p>
<p>    if (*s == *p) {<br />
        if (isMatch(s+1, p+1)) return true;<br />
    }                                                           </p>
<p>    if (*p == '.') {<br />
        if (isMatch(s+1, p+1)) return true;<br />
    }                                                           </p>
<p>    return false;<br />
}<br />
</code></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Suresh</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-15443</link>
		<dc:creator><![CDATA[Suresh]]></dc:creator>
		<pubDate>Thu, 20 Oct 2016 07:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-15443</guid>
		<description><![CDATA[Mine failing for 
&quot;ab&quot;
&quot;.*&quot;

Not sure how they match 
if &quot;.*&quot; matches nothing, it must fail
If  &quot;.*&quot; matches 1 &quot;a&quot;, it must still fail

???]]></description>
		<content:encoded><![CDATA[<p>Mine failing for<br />
&#8220;ab&#8221;<br />
&#8220;.*&#8221;</p>
<p>Not sure how they match<br />
if &#8220;.*&#8221; matches nothing, it must fail<br />
If  &#8220;.*&#8221; matches 1 &#8220;a&#8221;, it must still fail</p>
<p>???</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Shelley Tong</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-12835</link>
		<dc:creator><![CDATA[Shelley Tong]]></dc:creator>
		<pubDate>Sun, 24 Jul 2016 04:54:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-12835</guid>
		<description><![CDATA[In regular expressions, does this count as a regular expression?
p****

In my mind, the input with string: p and pattern: p**** would return true. but the solution program doesn&#039;t...............]]></description>
		<content:encoded><![CDATA[<p>In regular expressions, does this count as a regular expression?<br />
p****</p>
<p>In my mind, the input with string: p and pattern: p**** would return true. but the solution program doesn&#8217;t&#8230;&#8230;&#8230;&#8230;&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: JL</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-11415</link>
		<dc:creator><![CDATA[JL]]></dc:creator>
		<pubDate>Sat, 28 May 2016 00:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-11415</guid>
		<description><![CDATA[isMatch(String s, int s_pos, String p, int p_pos)]]></description>
		<content:encoded><![CDATA[<p>isMatch(String s, int s_pos, String p, int p_pos)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Matias SM</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-10060</link>
		<dc:creator><![CDATA[Matias SM]]></dc:creator>
		<pubDate>Sun, 03 Apr 2016 19:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-10060</guid>
		<description><![CDATA[A non-recursive approach. It assumes the existence of an invalid matchingChar which may not be a valid assumption (but could be easily replaced with an optional or null and Character usage).

&lt;code&gt;
boolean isMatch(String str, String pattern) {
    if (str.isEmpty() ^ pattern.isEmpty()) return false;

    boolean isMatchingStar = false;
    char matchingChar = &#039;&#039;; //a non-valid char

    int i = 0;
    int p = 0;
    while (i  p &#038;&#038; ! isMatchingStar) {
            matchingChar = pattern.charAt(p);
            //may add check for special char for sanity (invalid expression)
            ++p;
            if (pattern.length() &#062; p &#038;&#038; pattern.charAt(p) == &#039;*&#039;) { //look ahead for *
                isMatchingStar = true;
                ++p;
            }
        } else if (! isMatchingStar) {
            matchingChar = &#039;&#039;; //or some other invalid char
        }
        if (str.charAt(i) == matchingChar &#124;&#124; matchingChar == &#039;.&#039;) {
            ++i;
        } else {
            if (! isMatchingStar) return false;
            else isMatchingStar = false;
        }
    }
    
    //we completed the str, need to check if there is still pattern to match
    while (p &#060; pattern.length()) {
        int next = p + 1;
        //if there is a char but no wildcard, pattern not matched
        if (pattern.length() &#060;= next &#124;&#124; pattern.charAt(next) != &#039;*&#039;)
            return false;
        p = next + 1;
    }
    return true;
}
&lt;/code&gt;
Time complexity O(N), Space O(1)]]></description>
		<content:encoded><![CDATA[<p>A non-recursive approach. It assumes the existence of an invalid matchingChar which may not be a valid assumption (but could be easily replaced with an optional or null and Character usage).</p>
<p><code><br />
boolean isMatch(String str, String pattern) {<br />
    if (str.isEmpty() ^ pattern.isEmpty()) return false;</p>
<p>    boolean isMatchingStar = false;<br />
    char matchingChar = ''; //a non-valid char</p>
<p>    int i = 0;<br />
    int p = 0;<br />
    while (i  p &amp;&amp; ! isMatchingStar) {<br />
            matchingChar = pattern.charAt(p);<br />
            //may add check for special char for sanity (invalid expression)<br />
            ++p;<br />
            if (pattern.length() &gt; p &amp;&amp; pattern.charAt(p) == '*') { //look ahead for *<br />
                isMatchingStar = true;<br />
                ++p;<br />
            }<br />
        } else if (! isMatchingStar) {<br />
            matchingChar = ''; //or some other invalid char<br />
        }<br />
        if (str.charAt(i) == matchingChar || matchingChar == '.') {<br />
            ++i;<br />
        } else {<br />
            if (! isMatchingStar) return false;<br />
            else isMatchingStar = false;<br />
        }<br />
    }</p>
<p>    //we completed the str, need to check if there is still pattern to match<br />
    while (p &lt; pattern.length()) {<br />
        int next = p + 1;<br />
        //if there is a char but no wildcard, pattern not matched<br />
        if (pattern.length() &lt;= next || pattern.charAt(next) != &#039;*&#039;)<br />
            return false;<br />
        p = next + 1;<br />
    }<br />
    return true;<br />
}<br />
</code><br />
Time complexity O(N), Space O(1)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Qiongjie</title>
		<link>http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/#comment-9005</link>
		<dc:creator><![CDATA[Qiongjie]]></dc:creator>
		<pubDate>Thu, 11 Feb 2016 05:25:00 +0000</pubDate>
		<guid isPermaLink="false">http://www.programcreek.com/?p=10985#comment-9005</guid>
		<description><![CDATA[I only check the short version of your code. It fails for this case: isMatch(&quot;ab*b&quot;, &quot;ab*bb&quot;);]]></description>
		<content:encoded><![CDATA[<p>I only check the short version of your code. It fails for this case: isMatch(&#8220;ab*b&#8221;, &#8220;ab*bb&#8221;);</p>
]]></content:encoded>
	</item>
</channel>
</rss>

<!-- Localized -->